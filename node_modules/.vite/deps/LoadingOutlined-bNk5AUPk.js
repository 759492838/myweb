import { Ot as nextTick, et as createVNode, pt as h } from "./vue.runtime.esm-bundler-D9ZX2hko.js";

//#region node_modules/@ctrl/tinycolor/dist/module/util.js
/**
* Take input from [0, n] and return it as [0, 1]
* @hidden
*/
function bound01(n, max) {
	if (isOnePointZero(n)) n = "100%";
	var isPercent = isPercentage(n);
	n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
	if (isPercent) n = parseInt(String(n * max), 10) / 100;
	if (Math.abs(n - max) < 1e-6) return 1;
	if (max === 360) n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
	else n = n % max / parseFloat(String(max));
	return n;
}
/**
* Force a number between 0 and 1
* @hidden
*/
function clamp01(val) {
	return Math.min(1, Math.max(0, val));
}
/**
* Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
* <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
* @hidden
*/
function isOnePointZero(n) {
	return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
/**
* Check to see if string passed in is a percentage
* @hidden
*/
function isPercentage(n) {
	return typeof n === "string" && n.indexOf("%") !== -1;
}
/**
* Return a valid alpha value [0,1] with all invalid values being set to 1
* @hidden
*/
function boundAlpha(a) {
	a = parseFloat(a);
	if (isNaN(a) || a < 0 || a > 1) a = 1;
	return a;
}
/**
* Replace a decimal with it's percentage value
* @hidden
*/
function convertToPercentage(n) {
	if (n <= 1) return "".concat(Number(n) * 100, "%");
	return n;
}
/**
* Force a hex value to have 2 characters
* @hidden
*/
function pad2(c) {
	return c.length === 1 ? "0" + c : String(c);
}

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/conversion.js
/**
* Handle bounds / percentage checking to conform to CSS color spec
* <http://www.w3.org/TR/css3-color/>
* *Assumes:* r, g, b in [0, 255] or [0, 1]
* *Returns:* { r, g, b } in [0, 255]
*/
function rgbToRgb(r, g, b) {
	return {
		r: bound01(r, 255) * 255,
		g: bound01(g, 255) * 255,
		b: bound01(b, 255) * 255
	};
}
/**
* Converts an RGB color value to HSL.
* *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
* *Returns:* { h, s, l } in [0,1]
*/
function rgbToHsl(r, g, b) {
	r = bound01(r, 255);
	g = bound01(g, 255);
	b = bound01(b, 255);
	var max = Math.max(r, g, b);
	var min = Math.min(r, g, b);
	var h$1 = 0;
	var s = 0;
	var l = (max + min) / 2;
	if (max === min) {
		s = 0;
		h$1 = 0;
	} else {
		var d = max - min;
		s = l > .5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h$1 = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h$1 = (b - r) / d + 2;
				break;
			case b:
				h$1 = (r - g) / d + 4;
				break;
			default: break;
		}
		h$1 /= 6;
	}
	return {
		h: h$1,
		s,
		l
	};
}
function hue2rgb(p, q, t) {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	if (t < 1 / 6) return p + (q - p) * (6 * t);
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
}
/**
* Converts an HSL color value to RGB.
*
* *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
* *Returns:* { r, g, b } in the set [0, 255]
*/
function hslToRgb(h$1, s, l) {
	var r;
	var g;
	var b;
	h$1 = bound01(h$1, 360);
	s = bound01(s, 100);
	l = bound01(l, 100);
	if (s === 0) {
		g = l;
		b = l;
		r = l;
	} else {
		var q = l < .5 ? l * (1 + s) : l + s - l * s;
		var p = 2 * l - q;
		r = hue2rgb(p, q, h$1 + 1 / 3);
		g = hue2rgb(p, q, h$1);
		b = hue2rgb(p, q, h$1 - 1 / 3);
	}
	return {
		r: r * 255,
		g: g * 255,
		b: b * 255
	};
}
/**
* Converts an RGB color value to HSV
*
* *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
* *Returns:* { h, s, v } in [0,1]
*/
function rgbToHsv(r, g, b) {
	r = bound01(r, 255);
	g = bound01(g, 255);
	b = bound01(b, 255);
	var max = Math.max(r, g, b);
	var min = Math.min(r, g, b);
	var h$1 = 0;
	var v = max;
	var d = max - min;
	var s = max === 0 ? 0 : d / max;
	if (max === min) h$1 = 0;
	else {
		switch (max) {
			case r:
				h$1 = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h$1 = (b - r) / d + 2;
				break;
			case b:
				h$1 = (r - g) / d + 4;
				break;
			default: break;
		}
		h$1 /= 6;
	}
	return {
		h: h$1,
		s,
		v
	};
}
/**
* Converts an HSV color value to RGB.
*
* *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
* *Returns:* { r, g, b } in the set [0, 255]
*/
function hsvToRgb(h$1, s, v) {
	h$1 = bound01(h$1, 360) * 6;
	s = bound01(s, 100);
	v = bound01(v, 100);
	var i = Math.floor(h$1);
	var f = h$1 - i;
	var p = v * (1 - s);
	var q = v * (1 - f * s);
	var t = v * (1 - (1 - f) * s);
	var mod = i % 6;
	var r = [
		v,
		q,
		p,
		p,
		t,
		v
	][mod];
	var g = [
		t,
		v,
		v,
		q,
		p,
		p
	][mod];
	var b = [
		p,
		p,
		t,
		v,
		v,
		q
	][mod];
	return {
		r: r * 255,
		g: g * 255,
		b: b * 255
	};
}
/**
* Converts an RGB color to hex
*
* Assumes r, g, and b are contained in the set [0, 255]
* Returns a 3 or 6 character hex
*/
function rgbToHex(r, g, b, allow3Char) {
	var hex = [
		pad2(Math.round(r).toString(16)),
		pad2(Math.round(g).toString(16)),
		pad2(Math.round(b).toString(16))
	];
	if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
	return hex.join("");
}
/**
* Converts an RGBA color plus alpha transparency to hex
*
* Assumes r, g, b are contained in the set [0, 255] and
* a in [0, 1]. Returns a 4 or 8 character rgba hex
*/
function rgbaToHex(r, g, b, a, allow4Char) {
	var hex = [
		pad2(Math.round(r).toString(16)),
		pad2(Math.round(g).toString(16)),
		pad2(Math.round(b).toString(16)),
		pad2(convertDecimalToHex(a))
	];
	if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
	return hex.join("");
}
/** Converts a decimal to a hex value */
function convertDecimalToHex(d) {
	return Math.round(parseFloat(d) * 255).toString(16);
}
/** Converts a hex value to a decimal */
function convertHexToDecimal(h$1) {
	return parseIntFromHex(h$1) / 255;
}
/** Parse a base-16 hex value into a base-10 integer */
function parseIntFromHex(val) {
	return parseInt(val, 16);
}
function numberInputToObject(color) {
	return {
		r: color >> 16,
		g: (color & 65280) >> 8,
		b: color & 255
	};
}

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
/**
* @hidden
*/
var names = {
	aliceblue: "#f0f8ff",
	antiquewhite: "#faebd7",
	aqua: "#00ffff",
	aquamarine: "#7fffd4",
	azure: "#f0ffff",
	beige: "#f5f5dc",
	bisque: "#ffe4c4",
	black: "#000000",
	blanchedalmond: "#ffebcd",
	blue: "#0000ff",
	blueviolet: "#8a2be2",
	brown: "#a52a2a",
	burlywood: "#deb887",
	cadetblue: "#5f9ea0",
	chartreuse: "#7fff00",
	chocolate: "#d2691e",
	coral: "#ff7f50",
	cornflowerblue: "#6495ed",
	cornsilk: "#fff8dc",
	crimson: "#dc143c",
	cyan: "#00ffff",
	darkblue: "#00008b",
	darkcyan: "#008b8b",
	darkgoldenrod: "#b8860b",
	darkgray: "#a9a9a9",
	darkgreen: "#006400",
	darkgrey: "#a9a9a9",
	darkkhaki: "#bdb76b",
	darkmagenta: "#8b008b",
	darkolivegreen: "#556b2f",
	darkorange: "#ff8c00",
	darkorchid: "#9932cc",
	darkred: "#8b0000",
	darksalmon: "#e9967a",
	darkseagreen: "#8fbc8f",
	darkslateblue: "#483d8b",
	darkslategray: "#2f4f4f",
	darkslategrey: "#2f4f4f",
	darkturquoise: "#00ced1",
	darkviolet: "#9400d3",
	deeppink: "#ff1493",
	deepskyblue: "#00bfff",
	dimgray: "#696969",
	dimgrey: "#696969",
	dodgerblue: "#1e90ff",
	firebrick: "#b22222",
	floralwhite: "#fffaf0",
	forestgreen: "#228b22",
	fuchsia: "#ff00ff",
	gainsboro: "#dcdcdc",
	ghostwhite: "#f8f8ff",
	goldenrod: "#daa520",
	gold: "#ffd700",
	gray: "#808080",
	green: "#008000",
	greenyellow: "#adff2f",
	grey: "#808080",
	honeydew: "#f0fff0",
	hotpink: "#ff69b4",
	indianred: "#cd5c5c",
	indigo: "#4b0082",
	ivory: "#fffff0",
	khaki: "#f0e68c",
	lavenderblush: "#fff0f5",
	lavender: "#e6e6fa",
	lawngreen: "#7cfc00",
	lemonchiffon: "#fffacd",
	lightblue: "#add8e6",
	lightcoral: "#f08080",
	lightcyan: "#e0ffff",
	lightgoldenrodyellow: "#fafad2",
	lightgray: "#d3d3d3",
	lightgreen: "#90ee90",
	lightgrey: "#d3d3d3",
	lightpink: "#ffb6c1",
	lightsalmon: "#ffa07a",
	lightseagreen: "#20b2aa",
	lightskyblue: "#87cefa",
	lightslategray: "#778899",
	lightslategrey: "#778899",
	lightsteelblue: "#b0c4de",
	lightyellow: "#ffffe0",
	lime: "#00ff00",
	limegreen: "#32cd32",
	linen: "#faf0e6",
	magenta: "#ff00ff",
	maroon: "#800000",
	mediumaquamarine: "#66cdaa",
	mediumblue: "#0000cd",
	mediumorchid: "#ba55d3",
	mediumpurple: "#9370db",
	mediumseagreen: "#3cb371",
	mediumslateblue: "#7b68ee",
	mediumspringgreen: "#00fa9a",
	mediumturquoise: "#48d1cc",
	mediumvioletred: "#c71585",
	midnightblue: "#191970",
	mintcream: "#f5fffa",
	mistyrose: "#ffe4e1",
	moccasin: "#ffe4b5",
	navajowhite: "#ffdead",
	navy: "#000080",
	oldlace: "#fdf5e6",
	olive: "#808000",
	olivedrab: "#6b8e23",
	orange: "#ffa500",
	orangered: "#ff4500",
	orchid: "#da70d6",
	palegoldenrod: "#eee8aa",
	palegreen: "#98fb98",
	paleturquoise: "#afeeee",
	palevioletred: "#db7093",
	papayawhip: "#ffefd5",
	peachpuff: "#ffdab9",
	peru: "#cd853f",
	pink: "#ffc0cb",
	plum: "#dda0dd",
	powderblue: "#b0e0e6",
	purple: "#800080",
	rebeccapurple: "#663399",
	red: "#ff0000",
	rosybrown: "#bc8f8f",
	royalblue: "#4169e1",
	saddlebrown: "#8b4513",
	salmon: "#fa8072",
	sandybrown: "#f4a460",
	seagreen: "#2e8b57",
	seashell: "#fff5ee",
	sienna: "#a0522d",
	silver: "#c0c0c0",
	skyblue: "#87ceeb",
	slateblue: "#6a5acd",
	slategray: "#708090",
	slategrey: "#708090",
	snow: "#fffafa",
	springgreen: "#00ff7f",
	steelblue: "#4682b4",
	tan: "#d2b48c",
	teal: "#008080",
	thistle: "#d8bfd8",
	tomato: "#ff6347",
	turquoise: "#40e0d0",
	violet: "#ee82ee",
	wheat: "#f5deb3",
	white: "#ffffff",
	whitesmoke: "#f5f5f5",
	yellow: "#ffff00",
	yellowgreen: "#9acd32"
};

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/format-input.js
/**
* Given a string or object, convert that input to RGB
*
* Possible string inputs:
* ```
* "red"
* "#f00" or "f00"
* "#ff0000" or "ff0000"
* "#ff000000" or "ff000000"
* "rgb 255 0 0" or "rgb (255, 0, 0)"
* "rgb 1.0 0 0" or "rgb (1, 0, 0)"
* "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
* "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
* "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
* "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
* "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
* ```
*/
function inputToRGB(color) {
	var rgb = {
		r: 0,
		g: 0,
		b: 0
	};
	var a = 1;
	var s = null;
	var v = null;
	var l = null;
	var ok = false;
	var format = false;
	if (typeof color === "string") color = stringInputToObject(color);
	if (typeof color === "object") {
		if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
			rgb = rgbToRgb(color.r, color.g, color.b);
			ok = true;
			format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
		} else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
			s = convertToPercentage(color.s);
			v = convertToPercentage(color.v);
			rgb = hsvToRgb(color.h, s, v);
			ok = true;
			format = "hsv";
		} else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
			s = convertToPercentage(color.s);
			l = convertToPercentage(color.l);
			rgb = hslToRgb(color.h, s, l);
			ok = true;
			format = "hsl";
		}
		if (Object.prototype.hasOwnProperty.call(color, "a")) a = color.a;
	}
	a = boundAlpha(a);
	return {
		ok,
		format: color.format || format,
		r: Math.min(255, Math.max(rgb.r, 0)),
		g: Math.min(255, Math.max(rgb.g, 0)),
		b: Math.min(255, Math.max(rgb.b, 0)),
		a
	};
}
var CSS_UNIT = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
	CSS_UNIT: new RegExp(CSS_UNIT),
	rgb: /* @__PURE__ */ new RegExp("rgb" + PERMISSIVE_MATCH3),
	rgba: /* @__PURE__ */ new RegExp("rgba" + PERMISSIVE_MATCH4),
	hsl: /* @__PURE__ */ new RegExp("hsl" + PERMISSIVE_MATCH3),
	hsla: /* @__PURE__ */ new RegExp("hsla" + PERMISSIVE_MATCH4),
	hsv: /* @__PURE__ */ new RegExp("hsv" + PERMISSIVE_MATCH3),
	hsva: /* @__PURE__ */ new RegExp("hsva" + PERMISSIVE_MATCH4),
	hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
	hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
/**
* Permissive string parsing.  Take in a number of formats, and output an object
* based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
*/
function stringInputToObject(color) {
	color = color.trim().toLowerCase();
	if (color.length === 0) return false;
	var named = false;
	if (names[color]) {
		color = names[color];
		named = true;
	} else if (color === "transparent") return {
		r: 0,
		g: 0,
		b: 0,
		a: 0,
		format: "name"
	};
	var match = matchers.rgb.exec(color);
	if (match) return {
		r: match[1],
		g: match[2],
		b: match[3]
	};
	match = matchers.rgba.exec(color);
	if (match) return {
		r: match[1],
		g: match[2],
		b: match[3],
		a: match[4]
	};
	match = matchers.hsl.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		l: match[3]
	};
	match = matchers.hsla.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		l: match[3],
		a: match[4]
	};
	match = matchers.hsv.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		v: match[3]
	};
	match = matchers.hsva.exec(color);
	if (match) return {
		h: match[1],
		s: match[2],
		v: match[3],
		a: match[4]
	};
	match = matchers.hex8.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1]),
		g: parseIntFromHex(match[2]),
		b: parseIntFromHex(match[3]),
		a: convertHexToDecimal(match[4]),
		format: named ? "name" : "hex8"
	};
	match = matchers.hex6.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1]),
		g: parseIntFromHex(match[2]),
		b: parseIntFromHex(match[3]),
		format: named ? "name" : "hex"
	};
	match = matchers.hex4.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1] + match[1]),
		g: parseIntFromHex(match[2] + match[2]),
		b: parseIntFromHex(match[3] + match[3]),
		a: convertHexToDecimal(match[4] + match[4]),
		format: named ? "name" : "hex8"
	};
	match = matchers.hex3.exec(color);
	if (match) return {
		r: parseIntFromHex(match[1] + match[1]),
		g: parseIntFromHex(match[2] + match[2]),
		b: parseIntFromHex(match[3] + match[3]),
		format: named ? "name" : "hex"
	};
	return false;
}
/**
* Check to see if it looks like a CSS unit
* (see `matchers` above for definition).
*/
function isValidCSSUnit(color) {
	return Boolean(matchers.CSS_UNIT.exec(String(color)));
}

//#endregion
//#region node_modules/@ant-design/colors/dist/index.esm.js
var hueStep = 2;
var saturationStep = .16;
var saturationStep2 = .05;
var brightnessStep1 = .05;
var brightnessStep2 = .15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [
	{
		index: 7,
		opacity: .15
	},
	{
		index: 6,
		opacity: .25
	},
	{
		index: 5,
		opacity: .3
	},
	{
		index: 5,
		opacity: .45
	},
	{
		index: 5,
		opacity: .65
	},
	{
		index: 5,
		opacity: .85
	},
	{
		index: 4,
		opacity: .9
	},
	{
		index: 3,
		opacity: .95
	},
	{
		index: 2,
		opacity: .97
	},
	{
		index: 1,
		opacity: .98
	}
];
function toHsv(_ref) {
	var r = _ref.r, g = _ref.g, b = _ref.b;
	var hsv = rgbToHsv(r, g, b);
	return {
		h: hsv.h * 360,
		s: hsv.s,
		v: hsv.v
	};
}
function toHex(_ref2) {
	var r = _ref2.r, g = _ref2.g, b = _ref2.b;
	return "#".concat(rgbToHex(r, g, b, false));
}
function mix(rgb1, rgb2, amount) {
	var p = amount / 100;
	return {
		r: (rgb2.r - rgb1.r) * p + rgb1.r,
		g: (rgb2.g - rgb1.g) * p + rgb1.g,
		b: (rgb2.b - rgb1.b) * p + rgb1.b
	};
}
function getHue(hsv, i, light) {
	var hue;
	if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
	else hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
	if (hue < 0) hue += 360;
	else if (hue >= 360) hue -= 360;
	return hue;
}
function getSaturation(hsv, i, light) {
	if (hsv.h === 0 && hsv.s === 0) return hsv.s;
	var saturation;
	if (light) saturation = hsv.s - saturationStep * i;
	else if (i === darkColorCount) saturation = hsv.s + saturationStep;
	else saturation = hsv.s + saturationStep2 * i;
	if (saturation > 1) saturation = 1;
	if (light && i === lightColorCount && saturation > .1) saturation = .1;
	if (saturation < .06) saturation = .06;
	return Number(saturation.toFixed(2));
}
function getValue(hsv, i, light) {
	var value;
	if (light) value = hsv.v + brightnessStep1 * i;
	else value = hsv.v - brightnessStep2 * i;
	if (value > 1) value = 1;
	return Number(value.toFixed(2));
}
function generate$1(color) {
	var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var patterns = [];
	var pColor = inputToRGB(color);
	for (var i = lightColorCount; i > 0; i -= 1) {
		var hsv = toHsv(pColor);
		var colorString = toHex(inputToRGB({
			h: getHue(hsv, i, true),
			s: getSaturation(hsv, i, true),
			v: getValue(hsv, i, true)
		}));
		patterns.push(colorString);
	}
	patterns.push(toHex(pColor));
	for (var _i = 1; _i <= darkColorCount; _i += 1) {
		var _hsv = toHsv(pColor);
		var _colorString = toHex(inputToRGB({
			h: getHue(_hsv, _i),
			s: getSaturation(_hsv, _i),
			v: getValue(_hsv, _i)
		}));
		patterns.push(_colorString);
	}
	if (opts.theme === "dark") return darkColorMap.map(function(_ref3) {
		var index = _ref3.index, opacity = _ref3.opacity;
		return toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index]), opacity * 100));
	});
	return patterns;
}
var presetPrimaryColors = {
	red: "#F5222D",
	volcano: "#FA541C",
	orange: "#FA8C16",
	gold: "#FAAD14",
	yellow: "#FADB14",
	lime: "#A0D911",
	green: "#52C41A",
	cyan: "#13C2C2",
	blue: "#1890FF",
	geekblue: "#2F54EB",
	purple: "#722ED1",
	magenta: "#EB2F96",
	grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key) {
	presetPalettes[key] = generate$1(presetPrimaryColors[key]);
	presetPalettes[key].primary = presetPalettes[key][5];
	presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
		theme: "dark",
		backgroundColor: "#141414"
	});
	presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});
var red = presetPalettes.red;
var volcano = presetPalettes.volcano;
var gold = presetPalettes.gold;
var orange = presetPalettes.orange;
var yellow = presetPalettes.yellow;
var lime = presetPalettes.lime;
var green = presetPalettes.green;
var cyan = presetPalettes.cyan;
var blue = presetPalettes.blue;
var geekblue = presetPalettes.geekblue;
var purple = presetPalettes.purple;
var magenta = presetPalettes.magenta;
var grey = presetPalettes.grey;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/insert-css.js
var containers = [];
var styleElements = [];
var usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
function createStyleElement() {
	var styleElement = document.createElement("style");
	styleElement.setAttribute("type", "text/css");
	return styleElement;
}
function insertCss(css, options) {
	options = options || {};
	if (css === void 0) throw new Error(usage);
	var position = options.prepend === true ? "prepend" : "append";
	var container = options.container !== void 0 ? options.container : document.querySelector("head");
	var containerId = containers.indexOf(container);
	if (containerId === -1) {
		containerId = containers.push(container) - 1;
		styleElements[containerId] = {};
	}
	var styleElement;
	if (styleElements[containerId] !== void 0 && styleElements[containerId][position] !== void 0) styleElement = styleElements[containerId][position];
	else {
		styleElement = styleElements[containerId][position] = createStyleElement();
		if (position === "prepend") container.insertBefore(styleElement, container.childNodes[0]);
		else container.appendChild(styleElement);
	}
	if (css.charCodeAt(0) === 65279) css = css.substr(1, css.length);
	if (styleElement.styleSheet) styleElement.styleSheet.cssText += css;
	else styleElement.textContent += css;
	return styleElement;
}
var insert_css_default = insertCss;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/utils.js
function _objectSpread$12(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$12(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$12(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function warn(valid, message) {
	if (!valid && console !== void 0) console.error("Warning: ".concat(message));
}
function warning(valid, message) {
	warn(valid, "[@ant-design/icons-vue] ".concat(message));
}
function isIconDefinition(target) {
	return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
}
function generate(node, key, rootProps) {
	if (!rootProps) return h(node.tag, _objectSpread$12({ key }, node.attrs), (node.children || []).map(function(child, index) {
		return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
	}));
	return h(node.tag, _objectSpread$12({ key }, rootProps, node.attrs), (node.children || []).map(function(child, index) {
		return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
	}));
}
function getSecondaryColor(primaryColor) {
	return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
	if (!twoToneColor) return [];
	return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var svgBaseProps = {
	width: "1em",
	height: "1em",
	fill: "currentColor",
	"aria-hidden": "true",
	focusable: "false"
};
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var cssInjectedFlag = false;
var useInsertStyles = function useInsertStyles$1() {
	var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
	nextTick(function() {
		if (!cssInjectedFlag) {
			if (typeof window !== "undefined" && window.document && window.document.documentElement) insert_css_default(styleStr, { prepend: true });
			cssInjectedFlag = true;
		}
	});
};

//#endregion
//#region node_modules/@ant-design/icons-vue/es/components/IconBase.js
var _excluded$1 = [
	"icon",
	"primaryColor",
	"secondaryColor"
];
function _objectWithoutProperties$1(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$1(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _objectSpread$11(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$11(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$11(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var twoToneColorPalette = {
	primaryColor: "#333",
	secondaryColor: "#E6E6E6",
	calculated: false
};
function setTwoToneColors(_ref) {
	var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
	twoToneColorPalette.primaryColor = primaryColor;
	twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
	twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
	return _objectSpread$11({}, twoToneColorPalette);
}
var IconBase = function IconBase$1(props, context) {
	var _props$context$attrs = _objectSpread$11({}, props, context.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$1);
	var colors = twoToneColorPalette;
	if (primaryColor) colors = {
		primaryColor,
		secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
	};
	useInsertStyles();
	warning(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
	if (!isIconDefinition(icon)) return null;
	var target = icon;
	if (target && typeof target.icon === "function") target = _objectSpread$11({}, target, { icon: target.icon(colors.primaryColor, colors.secondaryColor) });
	return generate(target.icon, "svg-".concat(target.name), _objectSpread$11({}, restProps, {
		"data-icon": target.name,
		width: "1em",
		height: "1em",
		fill: "currentColor",
		"aria-hidden": "true"
	}));
};
IconBase.props = {
	icon: Object,
	primaryColor: String,
	secondaryColor: String,
	focusable: String
};
IconBase.inheritAttrs = false;
IconBase.displayName = "IconBase";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
var IconBase_default = IconBase;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/components/twoTonePrimaryColor.js
function _slicedToArray$1(arr, i) {
	return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
	var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
	if (_i == null) return;
	var _arr = [];
	var _n = true;
	var _d = false;
	var _s, _e;
	try {
		for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
			_arr.push(_s.value);
			if (i && _arr.length === i) break;
		}
	} catch (err) {
		_d = true;
		_e = err;
	} finally {
		try {
			if (!_n && _i["return"] != null) _i["return"]();
		} finally {
			if (_d) throw _e;
		}
	}
	return _arr;
}
function _arrayWithHoles$1(arr) {
	if (Array.isArray(arr)) return arr;
}
function setTwoToneColor(twoToneColor) {
	var _normalizeTwoToneColo2 = _slicedToArray$1(normalizeTwoToneColors(twoToneColor), 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
	return IconBase_default.setTwoToneColors({
		primaryColor,
		secondaryColor
	});
}
function getTwoToneColor() {
	var colors = IconBase_default.getTwoToneColors();
	if (!colors.calculated) return colors.primaryColor;
	return [colors.primaryColor, colors.secondaryColor];
}

//#endregion
//#region node_modules/@ant-design/icons-vue/es/components/AntdIcon.js
var _excluded = [
	"class",
	"icon",
	"spin",
	"rotate",
	"tabindex",
	"twoToneColor",
	"onClick"
];
function _slicedToArray(arr, i) {
	return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit(arr, i) {
	var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
	if (_i == null) return;
	var _arr = [];
	var _n = true;
	var _d = false;
	var _s, _e;
	try {
		for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
			_arr.push(_s.value);
			if (i && _arr.length === i) break;
		}
	} catch (err) {
		_d = true;
		_e = err;
	} finally {
		try {
			if (!_n && _i["return"] != null) _i["return"]();
		} finally {
			if (_d) throw _e;
		}
	}
	return _arr;
}
function _arrayWithHoles(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectSpread$10(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$10(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$10(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
setTwoToneColor("#1890ff");
var Icon = function Icon$1(props, context) {
	var _classObj;
	var _props$context$attrs = _objectSpread$10({}, props, context.attrs), cls = _props$context$attrs["class"], icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded);
	var classObj = (_classObj = { anticon: true }, _defineProperty$10(_classObj, "anticon-".concat(icon.name), Boolean(icon.name)), _defineProperty$10(_classObj, cls, cls), _classObj);
	var svgClassString = spin === "" || !!spin || icon.name === "loading" ? "anticon-spin" : "";
	var iconTabIndex = tabindex;
	if (iconTabIndex === void 0 && onClick) {
		iconTabIndex = -1;
		restProps.tabindex = iconTabIndex;
	}
	var svgStyle = rotate ? {
		msTransform: "rotate(".concat(rotate, "deg)"),
		transform: "rotate(".concat(rotate, "deg)")
	} : void 0;
	var _normalizeTwoToneColo2 = _slicedToArray(normalizeTwoToneColors(twoToneColor), 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
	return createVNode("span", _objectSpread$10({
		"role": "img",
		"aria-label": icon.name
	}, restProps, {
		"onClick": onClick,
		"class": classObj
	}), [createVNode(IconBase_default, {
		"class": svgClassString,
		"icon": icon,
		"primaryColor": primaryColor,
		"secondaryColor": secondaryColor,
		"style": svgStyle
	}, null)]);
};
Icon.props = {
	spin: Boolean,
	rotate: Number,
	icon: Object,
	twoToneColor: String
};
Icon.displayName = "AntdIcon";
Icon.inheritAttrs = false;
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
var AntdIcon_default = Icon;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CheckCircleFilled.js
var CheckCircleFilled$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" }
		}]
	},
	"name": "check-circle",
	"theme": "filled"
};
var CheckCircleFilled_default = CheckCircleFilled$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/CheckCircleFilled.js
function _objectSpread$9(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$9(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$9(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var CheckCircleFilled = function CheckCircleFilled$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$9({}, _objectSpread$9({}, props, context.attrs), { "icon": CheckCircleFilled_default }), null);
};
CheckCircleFilled.displayName = "CheckCircleFilled";
CheckCircleFilled.inheritAttrs = false;
var CheckCircleFilled_default$1 = CheckCircleFilled;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CheckCircleOutlined.js
var CheckCircleOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" }
		}]
	},
	"name": "check-circle",
	"theme": "outlined"
};
var CheckCircleOutlined_default = CheckCircleOutlined$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/CheckCircleOutlined.js
function _objectSpread$8(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$8(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$8(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var CheckCircleOutlined = function CheckCircleOutlined$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$8({}, _objectSpread$8({}, props, context.attrs), { "icon": CheckCircleOutlined_default }), null);
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
CheckCircleOutlined.inheritAttrs = false;
var CheckCircleOutlined_default$1 = CheckCircleOutlined;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CloseCircleFilled.js
var CloseCircleFilled$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"fill-rule": "evenodd",
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" }
		}]
	},
	"name": "close-circle",
	"theme": "filled"
};
var CloseCircleFilled_default = CloseCircleFilled$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/CloseCircleFilled.js
function _objectSpread$7(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$7(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$7(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var CloseCircleFilled = function CloseCircleFilled$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$7({}, _objectSpread$7({}, props, context.attrs), { "icon": CloseCircleFilled_default }), null);
};
CloseCircleFilled.displayName = "CloseCircleFilled";
CloseCircleFilled.inheritAttrs = false;
var CloseCircleFilled_default$1 = CloseCircleFilled;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CloseCircleOutlined.js
var CloseCircleOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"fill-rule": "evenodd",
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z" }
		}]
	},
	"name": "close-circle",
	"theme": "outlined"
};
var CloseCircleOutlined_default = CloseCircleOutlined$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/CloseCircleOutlined.js
function _objectSpread$6(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$6(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$6(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var CloseCircleOutlined = function CloseCircleOutlined$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$6({}, _objectSpread$6({}, props, context.attrs), { "icon": CloseCircleOutlined_default }), null);
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
CloseCircleOutlined.inheritAttrs = false;
var CloseCircleOutlined_default$1 = CloseCircleOutlined;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CloseOutlined.js
var CloseOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"fill-rule": "evenodd",
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" }
		}]
	},
	"name": "close",
	"theme": "outlined"
};
var CloseOutlined_default = CloseOutlined$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/CloseOutlined.js
function _objectSpread$5(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$5(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$5(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var CloseOutlined = function CloseOutlined$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$5({}, _objectSpread$5({}, props, context.attrs), { "icon": CloseOutlined_default }), null);
};
CloseOutlined.displayName = "CloseOutlined";
CloseOutlined.inheritAttrs = false;
var CloseOutlined_default$1 = CloseOutlined;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/ExclamationCircleFilled.js
var ExclamationCircleFilled$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" }
		}]
	},
	"name": "exclamation-circle",
	"theme": "filled"
};
var ExclamationCircleFilled_default = ExclamationCircleFilled$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/ExclamationCircleFilled.js
function _objectSpread$4(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$4(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$4(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var ExclamationCircleFilled = function ExclamationCircleFilled$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$4({}, _objectSpread$4({}, props, context.attrs), { "icon": ExclamationCircleFilled_default }), null);
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
ExclamationCircleFilled.inheritAttrs = false;
var ExclamationCircleFilled_default$1 = ExclamationCircleFilled;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/ExclamationCircleOutlined.js
var ExclamationCircleOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" }
		}]
	},
	"name": "exclamation-circle",
	"theme": "outlined"
};
var ExclamationCircleOutlined_default = ExclamationCircleOutlined$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/ExclamationCircleOutlined.js
function _objectSpread$3(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$3(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$3(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var ExclamationCircleOutlined = function ExclamationCircleOutlined$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$3({}, _objectSpread$3({}, props, context.attrs), { "icon": ExclamationCircleOutlined_default }), null);
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
ExclamationCircleOutlined.inheritAttrs = false;
var ExclamationCircleOutlined_default$1 = ExclamationCircleOutlined;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/InfoCircleFilled.js
var InfoCircleFilled$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" }
		}]
	},
	"name": "info-circle",
	"theme": "filled"
};
var InfoCircleFilled_default = InfoCircleFilled$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/InfoCircleFilled.js
function _objectSpread$2(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$2(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$2(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var InfoCircleFilled = function InfoCircleFilled$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$2({}, _objectSpread$2({}, props, context.attrs), { "icon": InfoCircleFilled_default }), null);
};
InfoCircleFilled.displayName = "InfoCircleFilled";
InfoCircleFilled.inheritAttrs = false;
var InfoCircleFilled_default$1 = InfoCircleFilled;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/InfoCircleOutlined.js
var InfoCircleOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" }
		}]
	},
	"name": "info-circle",
	"theme": "outlined"
};
var InfoCircleOutlined_default = InfoCircleOutlined$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/InfoCircleOutlined.js
function _objectSpread$1(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty$1(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty$1(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var InfoCircleOutlined = function InfoCircleOutlined$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread$1({}, _objectSpread$1({}, props, context.attrs), { "icon": InfoCircleOutlined_default }), null);
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
InfoCircleOutlined.inheritAttrs = false;
var InfoCircleOutlined_default$1 = InfoCircleOutlined;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/LoadingOutlined.js
var LoadingOutlined$1 = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" }
		}]
	},
	"name": "loading",
	"theme": "outlined"
};
var LoadingOutlined_default = LoadingOutlined$1;

//#endregion
//#region node_modules/@ant-design/icons-vue/es/icons/LoadingOutlined.js
function _objectSpread(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? Object(arguments[i]) : {};
		var ownKeys = Object.keys(source);
		if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		}));
		ownKeys.forEach(function(key) {
			_defineProperty(target, key, source[key]);
		});
	}
	return target;
}
function _defineProperty(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var LoadingOutlined = function LoadingOutlined$2(props, context) {
	return createVNode(AntdIcon_default, _objectSpread({}, _objectSpread({}, props, context.attrs), { "icon": LoadingOutlined_default }), null);
};
LoadingOutlined.displayName = "LoadingOutlined";
LoadingOutlined.inheritAttrs = false;
var LoadingOutlined_default$1 = LoadingOutlined;

//#endregion
export { rgbToHsl as C, boundAlpha as D, bound01 as E, clamp01 as O, rgbToHex as S, rgbaToHex as T, generate$1 as _, ExclamationCircleFilled_default$1 as a, names as b, CloseCircleFilled_default$1 as c, AntdIcon_default as d, getTwoToneColor as f, warning as g, useInsertStyles as h, ExclamationCircleOutlined_default$1 as i, CheckCircleOutlined_default$1 as l, svgBaseProps as m, InfoCircleOutlined_default$1 as n, CloseOutlined_default$1 as o, setTwoToneColor as p, InfoCircleFilled_default$1 as r, CloseCircleOutlined_default$1 as s, LoadingOutlined_default$1 as t, CheckCircleFilled_default$1 as u, presetPrimaryColors as v, rgbToHsv as w, numberInputToObject as x, inputToRGB as y };
//# sourceMappingURL=LoadingOutlined-bNk5AUPk.js.map