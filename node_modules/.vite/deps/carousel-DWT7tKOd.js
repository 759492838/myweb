import { B as flattenChildren, I as withInstall, K as getSlot, N as _objectWithoutProperties, St as _defineProperty, _t as classNames_default, it as isObjectLike_default, lt as _root_default, st as _baseGetTag_default, t as useConfigInject_default, v as warning_default, w as vue_types_default, wt as _typeof, xt as _objectSpread2 } from "./useConfigInject-B_ZZSFXy.js";
import { $ as createTextVNode, Kn as ref, U as computed, _n as watchEffect, et as createVNode, nt as defineComponent } from "./vue.runtime.esm-bundler-D9ZX2hko.js";
import { a as supportsPassive_default, n as isObject_default, o as ResizeObserver_es_default, r as cloneElement, t as BaseMixin_default } from "./BaseMixin-CrhV1mbx.js";

//#region node_modules/lodash-es/isSymbol.js
/** `Object#toString` result references. */
var symbolTag = "[object Symbol]";
/**
* Checks if `value` is classified as a `Symbol` primitive or object.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
* @example
*
* _.isSymbol(Symbol.iterator);
* // => true
*
* _.isSymbol('abc');
* // => false
*/
function isSymbol(value) {
	return typeof value == "symbol" || isObjectLike_default(value) && _baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

//#endregion
//#region node_modules/lodash-es/_trimmedEndIndex.js
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
* Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
* character of `string`.
*
* @private
* @param {string} string The string to inspect.
* @returns {number} Returns the index of the last non-whitespace character.
*/
function trimmedEndIndex(string) {
	var index = string.length;
	while (index-- && reWhitespace.test(string.charAt(index)));
	return index;
}
var _trimmedEndIndex_default = trimmedEndIndex;

//#endregion
//#region node_modules/lodash-es/_baseTrim.js
/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;
/**
* The base implementation of `_.trim`.
*
* @private
* @param {string} string The string to trim.
* @returns {string} Returns the trimmed string.
*/
function baseTrim(string) {
	return string ? string.slice(0, _trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim_default = baseTrim;

//#endregion
//#region node_modules/lodash-es/toNumber.js
/** Used as references for various `Number` constants. */
var NAN = NaN;
/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;
/**
* Converts `value` to a number.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to process.
* @returns {number} Returns the number.
* @example
*
* _.toNumber(3.2);
* // => 3.2
*
* _.toNumber(Number.MIN_VALUE);
* // => 5e-324
*
* _.toNumber(Infinity);
* // => Infinity
*
* _.toNumber('3.2');
* // => 3.2
*/
function toNumber(value) {
	if (typeof value == "number") return value;
	if (isSymbol_default(value)) return NAN;
	if (isObject_default(value)) {
		var other = typeof value.valueOf == "function" ? value.valueOf() : value;
		value = isObject_default(other) ? other + "" : other;
	}
	if (typeof value != "string") return value === 0 ? value : +value;
	value = _baseTrim_default(value);
	var isBinary = reIsBinary.test(value);
	return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

//#endregion
//#region node_modules/ant-design-vue/es/_util/json2mq.js
/**
* source by `json2mq`
* https://github.com/akiran/json2mq.git
*/
var camel2hyphen = function camel2hyphen$1(str) {
	return str.replace(/[A-Z]/g, function(match) {
		return "-" + match.toLowerCase();
	}).toLowerCase();
};
var isDimension = function isDimension$1(feature) {
	return /[height|width]$/.test(feature);
};
var obj2mq = function obj2mq$1(obj) {
	var mq = "";
	var features = Object.keys(obj);
	features.forEach(function(feature, index) {
		var value = obj[feature];
		feature = camel2hyphen(feature);
		if (isDimension(feature) && typeof value === "number") value = value + "px";
		if (value === true) mq += feature;
		else if (value === false) mq += "not " + feature;
		else mq += "(" + feature + ": " + value + ")";
		if (index < features.length - 1) mq += " and ";
	});
	return mq;
};
function json2mq_default(query) {
	var mq = "";
	if (typeof query === "string") return query;
	if (query instanceof Array) {
		query.forEach(function(q, index) {
			mq += obj2mq(q);
			if (index < query.length - 1) mq += ", ";
		});
		return mq;
	}
	return obj2mq(query);
}

//#endregion
//#region node_modules/lodash-es/now.js
/**
* Gets the timestamp of the number of milliseconds that have elapsed since
* the Unix epoch (1 January 1970 00:00:00 UTC).
*
* @static
* @memberOf _
* @since 2.4.0
* @category Date
* @returns {number} Returns the timestamp.
* @example
*
* _.defer(function(stamp) {
*   console.log(_.now() - stamp);
* }, _.now());
* // => Logs the number of milliseconds it took for the deferred invocation.
*/
var now = function() {
	return _root_default.Date.now();
};
var now_default = now;

//#endregion
//#region node_modules/lodash-es/debounce.js
/** Error message constants. */
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
/**
* Creates a debounced function that delays invoking `func` until after `wait`
* milliseconds have elapsed since the last time the debounced function was
* invoked. The debounced function comes with a `cancel` method to cancel
* delayed `func` invocations and a `flush` method to immediately invoke them.
* Provide `options` to indicate whether `func` should be invoked on the
* leading and/or trailing edge of the `wait` timeout. The `func` is invoked
* with the last arguments provided to the debounced function. Subsequent
* calls to the debounced function return the result of the last `func`
* invocation.
*
* **Note:** If `leading` and `trailing` options are `true`, `func` is
* invoked on the trailing edge of the timeout only if the debounced function
* is invoked more than once during the `wait` timeout.
*
* If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
* until to the next tick, similar to `setTimeout` with a timeout of `0`.
*
* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
* for details over the differences between `_.debounce` and `_.throttle`.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Function
* @param {Function} func The function to debounce.
* @param {number} [wait=0] The number of milliseconds to delay.
* @param {Object} [options={}] The options object.
* @param {boolean} [options.leading=false]
*  Specify invoking on the leading edge of the timeout.
* @param {number} [options.maxWait]
*  The maximum time `func` is allowed to be delayed before it's invoked.
* @param {boolean} [options.trailing=true]
*  Specify invoking on the trailing edge of the timeout.
* @returns {Function} Returns the new debounced function.
* @example
*
* // Avoid costly calculations while the window size is in flux.
* jQuery(window).on('resize', _.debounce(calculateLayout, 150));
*
* // Invoke `sendMail` when clicked, debouncing subsequent calls.
* jQuery(element).on('click', _.debounce(sendMail, 300, {
*   'leading': true,
*   'trailing': false
* }));
*
* // Ensure `batchLog` is invoked once after 1 second of debounced calls.
* var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
* var source = new EventSource('/stream');
* jQuery(source).on('message', debounced);
*
* // Cancel the trailing debounced invocation.
* jQuery(window).on('popstate', debounced.cancel);
*/
function debounce(func, wait, options) {
	var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
	if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
	wait = toNumber_default(wait) || 0;
	if (isObject_default(options)) {
		leading = !!options.leading;
		maxing = "maxWait" in options;
		maxWait = maxing ? nativeMax(toNumber_default(options.maxWait) || 0, wait) : maxWait;
		trailing = "trailing" in options ? !!options.trailing : trailing;
	}
	function invokeFunc(time) {
		var args = lastArgs, thisArg = lastThis;
		lastArgs = lastThis = void 0;
		lastInvokeTime = time;
		result = func.apply(thisArg, args);
		return result;
	}
	function leadingEdge(time) {
		lastInvokeTime = time;
		timerId = setTimeout(timerExpired, wait);
		return leading ? invokeFunc(time) : result;
	}
	function remainingWait(time) {
		var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
		return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
	}
	function shouldInvoke(time) {
		var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
		return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	}
	function timerExpired() {
		var time = now_default();
		if (shouldInvoke(time)) return trailingEdge(time);
		timerId = setTimeout(timerExpired, remainingWait(time));
	}
	function trailingEdge(time) {
		timerId = void 0;
		if (trailing && lastArgs) return invokeFunc(time);
		lastArgs = lastThis = void 0;
		return result;
	}
	function cancel() {
		if (timerId !== void 0) clearTimeout(timerId);
		lastInvokeTime = 0;
		lastArgs = lastCallTime = lastThis = timerId = void 0;
	}
	function flush() {
		return timerId === void 0 ? result : trailingEdge(now_default());
	}
	function debounced() {
		var time = now_default(), isInvoking = shouldInvoke(time);
		lastArgs = arguments;
		lastThis = this;
		lastCallTime = time;
		if (isInvoking) {
			if (timerId === void 0) return leadingEdge(lastCallTime);
			if (maxing) {
				clearTimeout(timerId);
				timerId = setTimeout(timerExpired, wait);
				return invokeFunc(lastCallTime);
			}
		}
		if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
		return result;
	}
	debounced.cancel = cancel;
	debounced.flush = flush;
	return debounced;
}
var debounce_default = debounce;

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/default-props.js
var defaultProps = {
	accessibility: {
		type: Boolean,
		default: true
	},
	adaptiveHeight: {
		type: Boolean,
		default: false
	},
	afterChange: vue_types_default.any.def(null),
	arrows: {
		type: Boolean,
		default: true
	},
	autoplay: {
		type: Boolean,
		default: false
	},
	autoplaySpeed: vue_types_default.number.def(3e3),
	beforeChange: vue_types_default.any.def(null),
	centerMode: {
		type: Boolean,
		default: false
	},
	centerPadding: vue_types_default.string.def("50px"),
	cssEase: vue_types_default.string.def("ease"),
	dots: {
		type: Boolean,
		default: false
	},
	dotsClass: vue_types_default.string.def("slick-dots"),
	draggable: {
		type: Boolean,
		default: true
	},
	unslick: {
		type: Boolean,
		default: false
	},
	easing: vue_types_default.string.def("linear"),
	edgeFriction: vue_types_default.number.def(.35),
	fade: {
		type: Boolean,
		default: false
	},
	focusOnSelect: {
		type: Boolean,
		default: false
	},
	infinite: {
		type: Boolean,
		default: true
	},
	initialSlide: vue_types_default.number.def(0),
	lazyLoad: vue_types_default.any.def(null),
	verticalSwiping: {
		type: Boolean,
		default: false
	},
	asNavFor: vue_types_default.any.def(null),
	pauseOnDotsHover: {
		type: Boolean,
		default: false
	},
	pauseOnFocus: {
		type: Boolean,
		default: false
	},
	pauseOnHover: {
		type: Boolean,
		default: true
	},
	responsive: vue_types_default.array,
	rows: vue_types_default.number.def(1),
	rtl: {
		type: Boolean,
		default: false
	},
	slide: vue_types_default.string.def("div"),
	slidesPerRow: vue_types_default.number.def(1),
	slidesToScroll: vue_types_default.number.def(1),
	slidesToShow: vue_types_default.number.def(1),
	speed: vue_types_default.number.def(500),
	swipe: {
		type: Boolean,
		default: true
	},
	swipeEvent: vue_types_default.any.def(null),
	swipeToSlide: {
		type: Boolean,
		default: false
	},
	touchMove: {
		type: Boolean,
		default: true
	},
	touchThreshold: vue_types_default.number.def(5),
	useCSS: {
		type: Boolean,
		default: true
	},
	useTransform: {
		type: Boolean,
		default: true
	},
	variableWidth: {
		type: Boolean,
		default: false
	},
	vertical: {
		type: Boolean,
		default: false
	},
	waitForAnimate: {
		type: Boolean,
		default: true
	},
	children: vue_types_default.array,
	__propsSymbol__: vue_types_default.any
};
var default_props_default = defaultProps;

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/initial-state.js
var initialState = {
	animating: false,
	autoplaying: null,
	currentDirection: 0,
	currentLeft: null,
	currentSlide: 0,
	direction: 1,
	dragging: false,
	edgeDragged: false,
	initialized: false,
	lazyLoadedList: [],
	listHeight: null,
	listWidth: null,
	scrolling: false,
	slideCount: null,
	slideHeight: null,
	slideWidth: null,
	swipeLeft: null,
	swiped: false,
	swiping: false,
	touchObject: {
		startX: 0,
		startY: 0,
		curX: 0,
		curY: 0
	},
	trackStyle: {},
	trackWidth: 0,
	targetSlide: 0
};
var initial_state_default = initialState;

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/utils/innerSliderUtils.js
function clamp(number, lowerBound, upperBound) {
	return Math.max(lowerBound, Math.min(number, upperBound));
}
var safePreventDefault = function safePreventDefault$1(event) {
	if (![
		"touchstart",
		"touchmove",
		"wheel"
	].includes(event.type)) event.preventDefault();
};
var getOnDemandLazySlides = function getOnDemandLazySlides$1(spec) {
	var onDemandSlides = [];
	var startIndex = lazyStartIndex(spec);
	var endIndex = lazyEndIndex(spec);
	for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) if (spec.lazyLoadedList.indexOf(slideIndex) < 0) onDemandSlides.push(slideIndex);
	return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex$1(spec) {
	return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex$1(spec) {
	return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft$1(spec) {
	return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight$1(spec) {
	return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth = function getWidth$1(elem) {
	return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight$1(elem) {
	return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection$1(touchObject) {
	var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var swipeAngle;
	var xDist = touchObject.startX - touchObject.curX;
	var yDist = touchObject.startY - touchObject.curY;
	var r = Math.atan2(yDist, xDist);
	swipeAngle = Math.round(r * 180 / Math.PI);
	if (swipeAngle < 0) swipeAngle = 360 - Math.abs(swipeAngle);
	if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) return "left";
	if (swipeAngle >= 135 && swipeAngle <= 225) return "right";
	if (verticalSwiping === true) if (swipeAngle >= 35 && swipeAngle <= 135) return "up";
	else return "down";
	return "vertical";
};
var canGoNext = function canGoNext$1(spec) {
	var canGo = true;
	if (!spec.infinite) {
		if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) canGo = false;
		else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) canGo = false;
	}
	return canGo;
};
var extractObject = function extractObject$1(spec, keys) {
	var newObject = {};
	keys.forEach(function(key) {
		return newObject[key] = spec[key];
	});
	return newObject;
};
var initializedState = function initializedState$1(spec) {
	var slideCount = spec.children.length;
	var listNode = spec.listRef;
	var listWidth = Math.ceil(getWidth(listNode));
	var trackNode = spec.trackRef;
	var trackWidth = Math.ceil(getWidth(trackNode));
	var slideWidth;
	if (!spec.vertical) {
		var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
		if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") centerPaddingAdj *= listWidth / 100;
		slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
	} else slideWidth = listWidth;
	var slideHeight = listNode && getHeight(listNode.querySelector("[data-index=\"0\"]"));
	var listHeight = slideHeight * spec.slidesToShow;
	var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
	if (spec.rtl && spec.currentSlide === void 0) currentSlide = slideCount - 1 - spec.initialSlide;
	var lazyLoadedList = spec.lazyLoadedList || [];
	var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, {
		currentSlide,
		lazyLoadedList
	}), spec);
	lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
	var state = {
		slideCount,
		slideWidth,
		listWidth,
		trackWidth,
		currentSlide,
		slideHeight,
		listHeight,
		lazyLoadedList
	};
	if (spec.autoplaying === null && spec.autoplay) state["autoplaying"] = "playing";
	return state;
};
var slideHandler = function slideHandler$1(spec) {
	var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
	var lazyLoadedList = spec.lazyLoadedList;
	if (waitForAnimate && animating) return {};
	var animationSlide = index;
	var finalSlide;
	var animationLeft;
	var finalLeft;
	var state = {};
	var nextState = {};
	var targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);
	if (fade) {
		if (!infinite && (index < 0 || index >= slideCount)) return {};
		if (index < 0) animationSlide = index + slideCount;
		else if (index >= slideCount) animationSlide = index - slideCount;
		if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) lazyLoadedList = lazyLoadedList.concat(animationSlide);
		state = {
			animating: true,
			currentSlide: animationSlide,
			lazyLoadedList,
			targetSlide: animationSlide
		};
		nextState = {
			animating: false,
			targetSlide: animationSlide
		};
	} else {
		finalSlide = animationSlide;
		if (animationSlide < 0) {
			finalSlide = animationSlide + slideCount;
			if (!infinite) finalSlide = 0;
			else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;
		} else if (!canGoNext(spec) && animationSlide > currentSlide) animationSlide = finalSlide = currentSlide;
		else if (centerMode && animationSlide >= slideCount) {
			animationSlide = infinite ? slideCount : slideCount - 1;
			finalSlide = infinite ? 0 : slideCount - 1;
		} else if (animationSlide >= slideCount) {
			finalSlide = animationSlide - slideCount;
			if (!infinite) finalSlide = slideCount - slidesToShow;
			else if (slideCount % slidesToScroll !== 0) finalSlide = 0;
		}
		if (!infinite && animationSlide + slidesToShow >= slideCount) finalSlide = slideCount - slidesToShow;
		animationLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, { slideIndex: animationSlide }));
		finalLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, { slideIndex: finalSlide }));
		if (!infinite) {
			if (animationLeft === finalLeft) animationSlide = finalSlide;
			animationLeft = finalLeft;
		}
		if (lazyLoad) lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, { currentSlide: animationSlide })));
		if (!useCSS) state = {
			currentSlide: finalSlide,
			trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: finalLeft })),
			lazyLoadedList,
			targetSlide
		};
		else {
			state = {
				animating: true,
				currentSlide: finalSlide,
				trackStyle: getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: animationLeft })),
				lazyLoadedList,
				targetSlide
			};
			nextState = {
				animating: false,
				currentSlide: finalSlide,
				trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: finalLeft })),
				swipeLeft: null,
				targetSlide
			};
		}
	}
	return {
		state,
		nextState
	};
};
var changeSlide = function changeSlide$1(spec, options) {
	var previousInt, slideOffset, targetSlide;
	var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
	var indexOffset = slideCount % slidesToScroll !== 0 ? 0 : (slideCount - currentSlide) % slidesToScroll;
	if (options.message === "previous") {
		slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
		targetSlide = currentSlide - slideOffset;
		if (lazyLoad && !infinite) {
			previousInt = currentSlide - slideOffset;
			targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
		}
		if (!infinite) targetSlide = previousTargetSlide - slidesToScroll;
	} else if (options.message === "next") {
		slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
		targetSlide = currentSlide + slideOffset;
		if (lazyLoad && !infinite) targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
		if (!infinite) targetSlide = previousTargetSlide + slidesToScroll;
	} else if (options.message === "dots") targetSlide = options.index * options.slidesToScroll;
	else if (options.message === "children") {
		targetSlide = options.index;
		if (infinite) {
			var direction = siblingDirection(_objectSpread2(_objectSpread2({}, spec), {}, { targetSlide }));
			if (targetSlide > options.currentSlide && direction === "left") targetSlide = targetSlide - slideCount;
			else if (targetSlide < options.currentSlide && direction === "right") targetSlide = targetSlide + slideCount;
		}
	} else if (options.message === "index") targetSlide = Number(options.index);
	return targetSlide;
};
var keyHandler = function keyHandler$1(e, accessibility, rtl) {
	if (e.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility) return "";
	if (e.keyCode === 37) return rtl ? "next" : "previous";
	if (e.keyCode === 39) return rtl ? "previous" : "next";
	return "";
};
var swipeStart = function swipeStart$1(e, swipe, draggable) {
	e.target.tagName === "IMG" && safePreventDefault(e);
	if (!swipe || !draggable && e.type.indexOf("mouse") !== -1) return "";
	return {
		dragging: true,
		touchObject: {
			startX: e.touches ? e.touches[0].pageX : e.clientX,
			startY: e.touches ? e.touches[0].pageY : e.clientY,
			curX: e.touches ? e.touches[0].pageX : e.clientX,
			curY: e.touches ? e.touches[0].pageY : e.clientY
		}
	};
};
var swipeMove = function swipeMove$1(e, spec) {
	var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
	if (scrolling) return;
	if (animating) return safePreventDefault(e);
	if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e);
	var swipeLeft;
	var state = {};
	var curLeft = getTrackLeft(spec);
	touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;
	touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;
	touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
	var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
	if (!verticalSwiping && !swiping && verticalSwipeLength > 10) return { scrolling: true };
	if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;
	var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
	if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
	var dotCount = Math.ceil(slideCount / slidesToScroll);
	var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
	var touchSwipeLength = touchObject.swipeLength;
	if (!infinite) {
		if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
			touchSwipeLength = touchObject.swipeLength * edgeFriction;
			if (edgeDragged === false && onEdge) {
				onEdge(swipeDirection);
				state["edgeDragged"] = true;
			}
		}
	}
	if (!swiped && swipeEvent) {
		swipeEvent(swipeDirection);
		state["swiped"] = true;
	}
	if (!vertical) if (!rtl) swipeLeft = curLeft + touchSwipeLength * positionOffset;
	else swipeLeft = curLeft - touchSwipeLength * positionOffset;
	else swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
	if (verticalSwiping) swipeLeft = curLeft + touchSwipeLength * positionOffset;
	state = _objectSpread2(_objectSpread2({}, state), {}, {
		touchObject,
		swipeLeft,
		trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: swipeLeft }))
	});
	if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * .8) return state;
	if (touchObject.swipeLength > 10) {
		state["swiping"] = true;
		safePreventDefault(e);
	}
	return state;
};
var swipeEnd = function swipeEnd$1(e, spec) {
	var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
	if (!dragging) {
		if (swipe) safePreventDefault(e);
		return {};
	}
	var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
	var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
	var state = {
		dragging: false,
		edgeDragged: false,
		scrolling: false,
		swiping: false,
		swiped: false,
		swipeLeft: null,
		touchObject: {}
	};
	if (scrolling) return state;
	if (!touchObject.swipeLength) return state;
	if (touchObject.swipeLength > minSwipe) {
		safePreventDefault(e);
		if (onSwipe) onSwipe(swipeDirection);
		var slideCount, newSlide;
		var activeSlide = infinite ? currentSlide : targetSlide;
		switch (swipeDirection) {
			case "left":
			case "up":
				newSlide = activeSlide + getSlideCount(spec);
				slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
				state["currentDirection"] = 0;
				break;
			case "right":
			case "down":
				newSlide = activeSlide - getSlideCount(spec);
				slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
				state["currentDirection"] = 1;
				break;
			default: slideCount = activeSlide;
		}
		state["triggerSlideHandler"] = slideCount;
	} else {
		var currentLeft = getTrackLeft(spec);
		state["trackStyle"] = getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: currentLeft }));
	}
	return state;
};
var getNavigableIndexes = function getNavigableIndexes$1(spec) {
	var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
	var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
	var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
	var indexes = [];
	while (breakpoint < max) {
		indexes.push(breakpoint);
		breakpoint = counter + spec.slidesToScroll;
		counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
	}
	return indexes;
};
var checkNavigable = function checkNavigable$1(spec, index) {
	var navigables = getNavigableIndexes(spec);
	var prevNavigable = 0;
	if (index > navigables[navigables.length - 1]) index = navigables[navigables.length - 1];
	else for (var n in navigables) {
		if (index < navigables[n]) {
			index = prevNavigable;
			break;
		}
		prevNavigable = navigables[n];
	}
	return index;
};
var getSlideCount = function getSlideCount$1(spec) {
	var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
	if (spec.swipeToSlide) {
		var swipedSlide;
		var slickList = spec.listRef;
		var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
		Array.from(slides).every(function(slide) {
			if (!spec.vertical) {
				if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
					swipedSlide = slide;
					return false;
				}
			} else if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
				swipedSlide = slide;
				return false;
			}
			return true;
		});
		if (!swipedSlide) return 0;
		var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
		return Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
	} else return spec.slidesToScroll;
};
var checkSpecKeys = function checkSpecKeys$1(spec, keysArray) {
	return keysArray.reduce(function(value, key) {
		return value && spec.hasOwnProperty(key);
	}, true) ? null : console.error("Keys Missing:", spec);
};
var getTrackCSS = function getTrackCSS$1(spec) {
	checkSpecKeys(spec, [
		"left",
		"variableWidth",
		"slideCount",
		"slidesToShow",
		"slideWidth"
	]);
	var trackWidth, trackHeight;
	var trackChildren = spec.slideCount + 2 * spec.slidesToShow;
	if (!spec.vertical) trackWidth = getTotalSlides(spec) * spec.slideWidth;
	else trackHeight = trackChildren * spec.slideHeight;
	var style = {
		opacity: 1,
		transition: "",
		WebkitTransition: ""
	};
	if (spec.useTransform) {
		var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
		var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
		var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
		style = _objectSpread2(_objectSpread2({}, style), {}, {
			WebkitTransform,
			transform,
			msTransform
		});
	} else if (spec.vertical) style["top"] = spec.left;
	else style["left"] = spec.left;
	if (spec.fade) style = { opacity: 1 };
	if (trackWidth) style.width = trackWidth + "px";
	if (trackHeight) style.height = trackHeight + "px";
	if (window && !window.addEventListener && window.attachEvent) if (!spec.vertical) style.marginLeft = spec.left + "px";
	else style.marginTop = spec.left + "px";
	return style;
};
var getTrackAnimateCSS = function getTrackAnimateCSS$1(spec) {
	checkSpecKeys(spec, [
		"left",
		"variableWidth",
		"slideCount",
		"slidesToShow",
		"slideWidth",
		"speed",
		"cssEase"
	]);
	var style = getTrackCSS(spec);
	if (spec.useTransform) {
		style.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
		style.transition = "transform " + spec.speed + "ms " + spec.cssEase;
	} else if (spec.vertical) style.transition = "top " + spec.speed + "ms " + spec.cssEase;
	else style.transition = "left " + spec.speed + "ms " + spec.cssEase;
	return style;
};
var getTrackLeft = function getTrackLeft$1(spec) {
	if (spec.unslick) return 0;
	checkSpecKeys(spec, [
		"slideIndex",
		"trackRef",
		"infinite",
		"centerMode",
		"slideCount",
		"slidesToShow",
		"slidesToScroll",
		"slideWidth",
		"listWidth",
		"variableWidth",
		"slideHeight"
	]);
	var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
	var slideOffset = 0;
	var targetLeft;
	var targetSlide;
	var verticalOffset = 0;
	if (fade || spec.slideCount === 1) return 0;
	var slidesToOffset = 0;
	if (infinite) {
		slidesToOffset = -getPreClones(spec);
		if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
		if (centerMode) slidesToOffset += parseInt(slidesToShow / 2);
	} else {
		if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) slidesToOffset = slidesToShow - slideCount % slidesToScroll;
		if (centerMode) slidesToOffset = parseInt(slidesToShow / 2);
	}
	slideOffset = slidesToOffset * slideWidth;
	verticalOffset = slidesToOffset * slideHeight;
	if (!vertical) targetLeft = slideIndex * slideWidth * -1 + slideOffset;
	else targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
	if (variableWidth === true) {
		var targetSlideIndex;
		var trackElem = trackRef;
		targetSlideIndex = slideIndex + getPreClones(spec);
		targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
		targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
		if (centerMode === true) {
			targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
			targetSlide = trackElem && trackElem.children[targetSlideIndex];
			targetLeft = 0;
			for (var slide = 0; slide < targetSlideIndex; slide++) targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
			targetLeft -= parseInt(spec.centerPadding);
			targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
		}
	}
	return targetLeft;
};
var getPreClones = function getPreClones$1(spec) {
	if (spec.unslick || !spec.infinite) return 0;
	if (spec.variableWidth) return spec.slideCount;
	return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones$1(spec) {
	if (spec.unslick || !spec.infinite) return 0;
	return spec.slideCount;
};
var getTotalSlides = function getTotalSlides$1(spec) {
	return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection$1(spec) {
	if (spec.targetSlide > spec.currentSlide) {
		if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) return "left";
		return "right";
	} else {
		if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) return "right";
		return "left";
	}
};
var slidesOnRight = function slidesOnRight$1(_ref) {
	var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
	if (centerMode) {
		var right = (slidesToShow - 1) / 2 + 1;
		if (parseInt(centerPadding) > 0) right += 1;
		if (rtl && slidesToShow % 2 === 0) right += 1;
		return right;
	}
	if (rtl) return 0;
	return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft$1(_ref2) {
	var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
	if (centerMode) {
		var left = (slidesToShow - 1) / 2 + 1;
		if (parseInt(centerPadding) > 0) left += 1;
		if (!rtl && slidesToShow % 2 === 0) left += 1;
		return left;
	}
	if (rtl) return slidesToShow - 1;
	return 0;
};
var canUseDOM = function canUseDOM$1() {
	return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/track.js
var getSlideClasses = function getSlideClasses$1(spec) {
	var slickActive, slickCenter;
	var centerOffset, index;
	if (spec.rtl) index = spec.slideCount - 1 - spec.index;
	else index = spec.index;
	var slickCloned = index < 0 || index >= spec.slideCount;
	if (spec.centerMode) {
		centerOffset = Math.floor(spec.slidesToShow / 2);
		slickCenter = (index - spec.currentSlide) % spec.slideCount === 0;
		if (index > spec.currentSlide - centerOffset - 1 && index <= spec.currentSlide + centerOffset) slickActive = true;
	} else slickActive = spec.currentSlide <= index && index < spec.currentSlide + spec.slidesToShow;
	var focusedSlide;
	if (spec.targetSlide < 0) focusedSlide = spec.targetSlide + spec.slideCount;
	else if (spec.targetSlide >= spec.slideCount) focusedSlide = spec.targetSlide - spec.slideCount;
	else focusedSlide = spec.targetSlide;
	var slickCurrent = index === focusedSlide;
	return {
		"slick-slide": true,
		"slick-active": slickActive,
		"slick-center": slickCenter,
		"slick-cloned": slickCloned,
		"slick-current": slickCurrent
	};
};
var getSlideStyle = function getSlideStyle$1(spec) {
	var style = {};
	if (spec.variableWidth === void 0 || spec.variableWidth === false) style.width = spec.slideWidth + (typeof spec.slideWidth === "number" ? "px" : "");
	if (spec.fade) {
		style.position = "relative";
		if (spec.vertical) style.top = -spec.index * parseInt(spec.slideHeight) + "px";
		else style.left = -spec.index * parseInt(spec.slideWidth) + "px";
		style.opacity = spec.currentSlide === spec.index ? 1 : 0;
		if (spec.useCSS) style.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
	}
	return style;
};
var getKey = function getKey$1(child, fallbackKey) {
	return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides$1(spec, children) {
	var key;
	var slides = [];
	var preCloneSlides = [];
	var postCloneSlides = [];
	var childrenCount = children.length;
	var startIndex = lazyStartIndex(spec);
	var endIndex = lazyEndIndex(spec);
	children.forEach(function(elem, index) {
		var child;
		var childOnClickOptions = {
			message: "children",
			index,
			slidesToScroll: spec.slidesToScroll,
			currentSlide: spec.currentSlide
		};
		if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index) >= 0) child = elem;
		else child = createVNode("div");
		var childStyle = getSlideStyle(_objectSpread2(_objectSpread2({}, spec), {}, { index }));
		var slideClass = child.props.class || "";
		var slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index }));
		slides.push(cloneElement(child, {
			key: "original" + getKey(child, index),
			tabindex: "-1",
			"data-index": index,
			"aria-hidden": !slideClasses["slick-active"],
			class: classNames_default(slideClasses, slideClass),
			style: _objectSpread2(_objectSpread2({ outline: "none" }, child.props.style || {}), childStyle),
			onClick: function onClick() {
				if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
			}
		}));
		if (spec.infinite && spec.fade === false) {
			var preCloneNo = childrenCount - index;
			if (preCloneNo <= getPreClones(spec) && childrenCount !== spec.slidesToShow) {
				key = -preCloneNo;
				if (key >= startIndex) child = elem;
				slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: key }));
				preCloneSlides.push(cloneElement(child, {
					key: "precloned" + getKey(child, key),
					class: classNames_default(slideClasses, slideClass),
					tabindex: "-1",
					"data-index": key,
					"aria-hidden": !slideClasses["slick-active"],
					style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
					onClick: function onClick() {
						if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
					}
				}));
			}
			if (childrenCount !== spec.slidesToShow) {
				key = childrenCount + index;
				if (key < endIndex) child = elem;
				slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: key }));
				postCloneSlides.push(cloneElement(child, {
					key: "postcloned" + getKey(child, key),
					tabindex: "-1",
					"data-index": key,
					"aria-hidden": !slideClasses["slick-active"],
					class: classNames_default(slideClasses, slideClass),
					style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
					onClick: function onClick() {
						if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
					}
				}));
			}
		}
	});
	if (spec.rtl) return preCloneSlides.concat(slides, postCloneSlides).reverse();
	else return preCloneSlides.concat(slides, postCloneSlides);
};
var Track = function Track$1(_, _ref) {
	var attrs = _ref.attrs, slots = _ref.slots;
	var slides = renderSlides(attrs, flattenChildren(slots === null || slots === void 0 ? void 0 : slots.default()));
	var mouseEvents = {
		onMouseenter: attrs.onMouseenter,
		onMouseover: attrs.onMouseover,
		onMouseleave: attrs.onMouseleave
	};
	return createVNode("div", _objectSpread2({
		class: "slick-track",
		style: attrs.trackStyle
	}, mouseEvents), [slides]);
};
Track.inheritAttrs = false;
var track_default = Track;

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/dots.js
var getDotCount = function getDotCount$1(spec) {
	var dots;
	if (spec.infinite) dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
	else dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
	return dots;
};
var Dots = function Dots$1(_, _ref) {
	var attrs = _ref.attrs;
	var slideCount = attrs.slideCount, slidesToScroll = attrs.slidesToScroll, slidesToShow = attrs.slidesToShow, infinite = attrs.infinite, currentSlide = attrs.currentSlide, appendDots = attrs.appendDots, customPaging = attrs.customPaging, clickHandler = attrs.clickHandler, dotsClass = attrs.dotsClass, onMouseenter = attrs.onMouseenter, onMouseover = attrs.onMouseover, onMouseleave = attrs.onMouseleave;
	var dotCount = getDotCount({
		slideCount,
		slidesToScroll,
		slidesToShow,
		infinite
	});
	var mouseEvents = {
		onMouseenter,
		onMouseover,
		onMouseleave
	};
	var dots = [];
	var _loop = function _loop$1(i$1) {
		var _rightBound = (i$1 + 1) * slidesToScroll - 1;
		var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
		var _leftBound = rightBound - (slidesToScroll - 1);
		var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
		var className = classNames_default({ "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound });
		var dotOptions = {
			message: "dots",
			index: i$1,
			slidesToScroll,
			currentSlide
		};
		function onClick(e) {
			if (e) e.preventDefault();
			clickHandler(dotOptions);
		}
		dots = dots.concat(createVNode("li", {
			"key": i$1,
			"class": className
		}, [cloneElement(customPaging({ i: i$1 }), { onClick })]));
	};
	for (var i = 0; i < dotCount; i++) _loop(i);
	return cloneElement(appendDots({ dots }), _objectSpread2({ class: dotsClass }, mouseEvents));
};
Dots.inheritAttrs = false;
var dots_default = Dots;

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/arrows.js
function noop$1() {}
function handler(options, handle, e) {
	if (e) e.preventDefault();
	handle(options, e);
}
var PrevArrow = function PrevArrow$1(_, _ref) {
	var attrs = _ref.attrs;
	var clickHandler = attrs.clickHandler, infinite = attrs.infinite, currentSlide = attrs.currentSlide, slideCount = attrs.slideCount, slidesToShow = attrs.slidesToShow;
	var prevClasses = {
		"slick-arrow": true,
		"slick-prev": true
	};
	var prevHandler = function prevHandler$1(e) {
		handler({ message: "previous" }, clickHandler, e);
	};
	if (!infinite && (currentSlide === 0 || slideCount <= slidesToShow)) {
		prevClasses["slick-disabled"] = true;
		prevHandler = noop$1;
	}
	var prevArrowProps = {
		key: "0",
		"data-role": "none",
		class: prevClasses,
		style: { display: "block" },
		onClick: prevHandler
	};
	var customProps = {
		currentSlide,
		slideCount
	};
	var prevArrow;
	if (attrs.prevArrow) prevArrow = cloneElement(attrs.prevArrow(_objectSpread2(_objectSpread2({}, prevArrowProps), customProps)), {
		key: "0",
		class: prevClasses,
		style: { display: "block" },
		onClick: prevHandler
	}, false);
	else prevArrow = createVNode("button", _objectSpread2({
		"key": "0",
		"type": "button"
	}, prevArrowProps), [" ", createTextVNode("Previous")]);
	return prevArrow;
};
PrevArrow.inheritAttrs = false;
var NextArrow = function NextArrow$1(_, _ref2) {
	var attrs = _ref2.attrs;
	var clickHandler = attrs.clickHandler, currentSlide = attrs.currentSlide, slideCount = attrs.slideCount;
	var nextClasses = {
		"slick-arrow": true,
		"slick-next": true
	};
	var nextHandler = function nextHandler$1(e) {
		handler({ message: "next" }, clickHandler, e);
	};
	if (!canGoNext(attrs)) {
		nextClasses["slick-disabled"] = true;
		nextHandler = noop$1;
	}
	var nextArrowProps = {
		key: "1",
		"data-role": "none",
		class: classNames_default(nextClasses),
		style: { display: "block" },
		onClick: nextHandler
	};
	var customProps = {
		currentSlide,
		slideCount
	};
	var nextArrow;
	if (attrs.nextArrow) nextArrow = cloneElement(attrs.nextArrow(_objectSpread2(_objectSpread2({}, nextArrowProps), customProps)), {
		key: "1",
		class: classNames_default(nextClasses),
		style: { display: "block" },
		onClick: nextHandler
	}, false);
	else nextArrow = createVNode("button", _objectSpread2({
		"key": "1",
		"type": "button"
	}, nextArrowProps), [" ", createTextVNode("Next")]);
	return nextArrow;
};
NextArrow.inheritAttrs = false;

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/inner-slider.js
var _excluded$1 = ["animating"];
function noop() {}
var inner_slider_default = {
	name: "InnerSlider",
	mixins: [BaseMixin_default],
	inheritAttrs: false,
	props: _objectSpread2({}, default_props_default),
	data: function data() {
		this.preProps = _objectSpread2({}, this.$props);
		this.list = null;
		this.track = null;
		this.callbackTimers = [];
		this.clickable = true;
		this.debouncedResize = null;
		var ssrState = this.ssrInit();
		return _objectSpread2(_objectSpread2({}, initial_state_default), {}, {
			currentSlide: this.initialSlide,
			slideCount: this.children.length
		}, ssrState);
	},
	watch: { __propsSymbol__: function __propsSymbol__() {
		var _this = this;
		var nextProps = this.$props;
		var spec = _objectSpread2(_objectSpread2({
			listRef: this.list,
			trackRef: this.track
		}, nextProps), this.$data);
		var setTrackStyle = false;
		for (var _i = 0, _Object$keys = Object.keys(this.preProps); _i < _Object$keys.length; _i++) {
			var key = _Object$keys[_i];
			if (!nextProps.hasOwnProperty(key)) {
				setTrackStyle = true;
				break;
			}
			if (_typeof(nextProps[key]) === "object" || typeof nextProps[key] === "function" || _typeof(nextProps[key]) === "symbol") continue;
			if (nextProps[key] !== this.preProps[key]) {
				setTrackStyle = true;
				break;
			}
		}
		this.updateState(spec, setTrackStyle, function() {
			if (_this.currentSlide >= nextProps.children.length) _this.changeSlide({
				message: "index",
				index: nextProps.children.length - nextProps.slidesToShow,
				currentSlide: _this.currentSlide
			});
			if (!_this.preProps.autoplay && nextProps.autoplay) _this.handleAutoPlay("playing");
			else if (nextProps.autoplay) _this.handleAutoPlay("update");
			else _this.pause("paused");
		});
		this.preProps = _objectSpread2({}, nextProps);
	} },
	mounted: function mounted() {
		var _this2 = this;
		this.__emit("init");
		if (this.lazyLoad) {
			var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, this.$props), this.$data));
			if (slidesToLoad.length > 0) {
				this.setState(function(prevState) {
					return { lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad) };
				});
				this.__emit("lazyLoad", slidesToLoad);
			}
		}
		this.$nextTick(function() {
			var spec = _objectSpread2({
				listRef: _this2.list,
				trackRef: _this2.track,
				children: _this2.children
			}, _this2.$props);
			_this2.updateState(spec, true, function() {
				_this2.adaptHeight();
				_this2.autoplay && _this2.handleAutoPlay("playing");
			});
			if (_this2.lazyLoad === "progressive") _this2.lazyLoadTimer = setInterval(_this2.progressiveLazyLoad, 1e3);
			_this2.ro = new ResizeObserver_es_default(function() {
				if (_this2.animating) {
					_this2.onWindowResized(false);
					_this2.callbackTimers.push(setTimeout(function() {
						return _this2.onWindowResized();
					}, _this2.speed));
				} else _this2.onWindowResized();
			});
			_this2.ro.observe(_this2.list);
			document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
				slide.onfocus = _this2.$props.pauseOnFocus ? _this2.onSlideFocus : null;
				slide.onblur = _this2.$props.pauseOnFocus ? _this2.onSlideBlur : null;
			});
			if (window.addEventListener) window.addEventListener("resize", _this2.onWindowResized);
			else window.attachEvent("onresize", _this2.onWindowResized);
		});
	},
	beforeUnmount: function beforeUnmount() {
		var _this$ro;
		if (this.animationEndCallback) clearTimeout(this.animationEndCallback);
		if (this.lazyLoadTimer) clearInterval(this.lazyLoadTimer);
		if (this.callbackTimers.length) {
			this.callbackTimers.forEach(function(timer) {
				return clearTimeout(timer);
			});
			this.callbackTimers = [];
		}
		if (window.addEventListener) window.removeEventListener("resize", this.onWindowResized);
		else window.detachEvent("onresize", this.onWindowResized);
		if (this.autoplayTimer) clearInterval(this.autoplayTimer);
		(_this$ro = this.ro) === null || _this$ro === void 0 || _this$ro.disconnect();
	},
	updated: function updated() {
		this.checkImagesLoad();
		this.__emit("reInit");
		if (this.lazyLoad) {
			var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, this.$props), this.$data));
			if (slidesToLoad.length > 0) {
				this.setState(function(prevState) {
					return { lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad) };
				});
				this.__emit("lazyLoad");
			}
		}
		this.adaptHeight();
	},
	methods: {
		listRefHandler: function listRefHandler(ref$1) {
			this.list = ref$1;
		},
		trackRefHandler: function trackRefHandler(ref$1) {
			this.track = ref$1;
		},
		adaptHeight: function adaptHeight() {
			if (this.adaptiveHeight && this.list) {
				var elem = this.list.querySelector("[data-index=\"".concat(this.currentSlide, "\"]"));
				this.list.style.height = getHeight(elem) + "px";
			}
		},
		onWindowResized: function onWindowResized(setTrackStyle) {
			var _this3 = this;
			if (this.debouncedResize) this.debouncedResize.cancel();
			this.debouncedResize = debounce_default(function() {
				return _this3.resizeWindow(setTrackStyle);
			}, 50);
			this.debouncedResize();
		},
		resizeWindow: function resizeWindow() {
			var _this4 = this;
			var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
			if (!Boolean(this.track)) return;
			var spec = _objectSpread2(_objectSpread2({
				listRef: this.list,
				trackRef: this.track,
				children: this.children
			}, this.$props), this.$data);
			this.updateState(spec, setTrackStyle, function() {
				if (_this4.autoplay) _this4.handleAutoPlay("update");
				else _this4.pause("paused");
			});
			this.setState({ animating: false });
			clearTimeout(this.animationEndCallback);
			delete this.animationEndCallback;
		},
		updateState: function updateState(spec, setTrackStyle, callback) {
			var updatedState = initializedState(spec);
			spec = _objectSpread2(_objectSpread2(_objectSpread2({}, spec), updatedState), {}, { slideIndex: updatedState.currentSlide });
			var targetLeft = getTrackLeft(spec);
			spec = _objectSpread2(_objectSpread2({}, spec), {}, { left: targetLeft });
			var trackStyle = getTrackCSS(spec);
			if (setTrackStyle || this.children.length !== spec.children.length) updatedState["trackStyle"] = trackStyle;
			this.setState(updatedState, callback);
		},
		ssrInit: function ssrInit() {
			var children = this.children;
			if (this.variableWidth) {
				var _trackWidth = 0;
				var _trackLeft = 0;
				var childrenWidths = [];
				var preClones = getPreClones(_objectSpread2(_objectSpread2(_objectSpread2({}, this.$props), this.$data), {}, { slideCount: children.length }));
				var postClones = getPostClones(_objectSpread2(_objectSpread2(_objectSpread2({}, this.$props), this.$data), {}, { slideCount: children.length }));
				children.forEach(function(child) {
					var _child$props$style, _child$props$style$wi;
					var childWidth = ((_child$props$style = child.props.style) === null || _child$props$style === void 0 ? void 0 : (_child$props$style$wi = _child$props$style.width) === null || _child$props$style$wi === void 0 ? void 0 : _child$props$style$wi.split("px")[0]) || 0;
					childrenWidths.push(childWidth);
					_trackWidth += childWidth;
				});
				for (var i = 0; i < preClones; i++) {
					_trackLeft += childrenWidths[childrenWidths.length - 1 - i];
					_trackWidth += childrenWidths[childrenWidths.length - 1 - i];
				}
				for (var _i2 = 0; _i2 < postClones; _i2++) _trackWidth += childrenWidths[_i2];
				for (var _i3 = 0; _i3 < this.currentSlide; _i3++) _trackLeft += childrenWidths[_i3];
				var _trackStyle = {
					width: _trackWidth + "px",
					left: -_trackLeft + "px"
				};
				if (this.centerMode) {
					var currentWidth = "".concat(childrenWidths[this.currentSlide], "px");
					_trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
				}
				return { trackStyle: _trackStyle };
			}
			var childrenCount = children.length;
			var spec = _objectSpread2(_objectSpread2(_objectSpread2({}, this.$props), this.$data), {}, { slideCount: childrenCount });
			var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
			var trackWidth = 100 / this.slidesToShow * slideCount;
			var slideWidth = 100 / slideCount;
			var trackLeft = -slideWidth * (getPreClones(spec) + this.currentSlide) * trackWidth / 100;
			if (this.centerMode) trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
			var trackStyle = {
				width: trackWidth + "%",
				left: trackLeft + "%"
			};
			return {
				slideWidth: slideWidth + "%",
				trackStyle
			};
		},
		checkImagesLoad: function checkImagesLoad() {
			var _this5 = this;
			var images = this.list && this.list.querySelectorAll && this.list.querySelectorAll(".slick-slide img") || [];
			var imagesCount = images.length;
			var loadedCount = 0;
			Array.prototype.forEach.call(images, function(image) {
				var handler$1 = function handler$2() {
					return ++loadedCount && loadedCount >= imagesCount && _this5.onWindowResized();
				};
				if (!image.onclick) image.onclick = function() {
					return image.parentNode.focus();
				};
				else {
					var prevClickHandler = image.onclick;
					image.onclick = function() {
						prevClickHandler();
						image.parentNode.focus();
					};
				}
				if (!image.onload) if (_this5.$props.lazyLoad) image.onload = function() {
					_this5.adaptHeight();
					_this5.callbackTimers.push(setTimeout(_this5.onWindowResized, _this5.speed));
				};
				else {
					image.onload = handler$1;
					image.onerror = function() {
						handler$1();
						_this5.__emit("lazyLoadError");
					};
				}
			});
		},
		progressiveLazyLoad: function progressiveLazyLoad() {
			var slidesToLoad = [];
			var spec = _objectSpread2(_objectSpread2({}, this.$props), this.$data);
			for (var index = this.currentSlide; index < this.slideCount + getPostClones(spec); index++) if (this.lazyLoadedList.indexOf(index) < 0) {
				slidesToLoad.push(index);
				break;
			}
			for (var _index = this.currentSlide - 1; _index >= -getPreClones(spec); _index--) if (this.lazyLoadedList.indexOf(_index) < 0) {
				slidesToLoad.push(_index);
				break;
			}
			if (slidesToLoad.length > 0) {
				this.setState(function(state) {
					return { lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad) };
				});
				this.__emit("lazyLoad", slidesToLoad);
			} else if (this.lazyLoadTimer) {
				clearInterval(this.lazyLoadTimer);
				delete this.lazyLoadTimer;
			}
		},
		slideHandler: function slideHandler$1(index) {
			var _this6 = this;
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			var _this$$props = this.$props, asNavFor = _this$$props.asNavFor, currentSlide = _this$$props.currentSlide, beforeChange = _this$$props.beforeChange, speed = _this$$props.speed, afterChange = _this$$props.afterChange;
			var _slideHandler2 = slideHandler(_objectSpread2(_objectSpread2(_objectSpread2({ index }, this.$props), this.$data), {}, {
				trackRef: this.track,
				useCSS: this.useCSS && !dontAnimate
			})), state = _slideHandler2.state, nextState = _slideHandler2.nextState;
			if (!state) return;
			beforeChange && beforeChange(currentSlide, state.currentSlide);
			var slidesToLoad = state.lazyLoadedList.filter(function(value) {
				return _this6.lazyLoadedList.indexOf(value) < 0;
			});
			if (this.$attrs.onLazyLoad && slidesToLoad.length > 0) this.__emit("lazyLoad", slidesToLoad);
			if (!this.$props.waitForAnimate && this.animationEndCallback) {
				clearTimeout(this.animationEndCallback);
				afterChange && afterChange(currentSlide);
				delete this.animationEndCallback;
			}
			this.setState(state, function() {
				if (asNavFor && _this6.asNavForIndex !== index) {
					_this6.asNavForIndex = index;
					asNavFor.innerSlider.slideHandler(index);
				}
				if (!nextState) return;
				_this6.animationEndCallback = setTimeout(function() {
					var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, _excluded$1);
					_this6.setState(firstBatch, function() {
						_this6.callbackTimers.push(setTimeout(function() {
							return _this6.setState({ animating });
						}, 10));
						afterChange && afterChange(state.currentSlide);
						delete _this6.animationEndCallback;
					});
				}, speed);
			});
		},
		changeSlide: function changeSlide$1(options) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			var targetSlide = changeSlide(_objectSpread2(_objectSpread2({}, this.$props), this.$data), options);
			if (targetSlide !== 0 && !targetSlide) return;
			if (dontAnimate === true) this.slideHandler(targetSlide, dontAnimate);
			else this.slideHandler(targetSlide);
			this.$props.autoplay && this.handleAutoPlay("update");
			if (this.$props.focusOnSelect) {
				var nodes = this.list.querySelectorAll(".slick-current");
				nodes[0] && nodes[0].focus();
			}
		},
		clickHandler: function clickHandler(e) {
			if (this.clickable === false) {
				e.stopPropagation();
				e.preventDefault();
			}
			this.clickable = true;
		},
		keyHandler: function keyHandler$1(e) {
			var dir = keyHandler(e, this.accessibility, this.rtl);
			dir !== "" && this.changeSlide({ message: dir });
		},
		selectHandler: function selectHandler(options) {
			this.changeSlide(options);
		},
		disableBodyScroll: function disableBodyScroll() {
			var preventDefault = function preventDefault$1(e) {
				e = e || window.event;
				if (e.preventDefault) e.preventDefault();
				e.returnValue = false;
			};
			window.ontouchmove = preventDefault;
		},
		enableBodyScroll: function enableBodyScroll() {
			window.ontouchmove = null;
		},
		swipeStart: function swipeStart$1(e) {
			if (this.verticalSwiping) this.disableBodyScroll();
			var state = swipeStart(e, this.swipe, this.draggable);
			state !== "" && this.setState(state);
		},
		swipeMove: function swipeMove$1(e) {
			var state = swipeMove(e, _objectSpread2(_objectSpread2(_objectSpread2({}, this.$props), this.$data), {}, {
				trackRef: this.track,
				listRef: this.list,
				slideIndex: this.currentSlide
			}));
			if (!state) return;
			if (state["swiping"]) this.clickable = false;
			this.setState(state);
		},
		swipeEnd: function swipeEnd$1(e) {
			var state = swipeEnd(e, _objectSpread2(_objectSpread2(_objectSpread2({}, this.$props), this.$data), {}, {
				trackRef: this.track,
				listRef: this.list,
				slideIndex: this.currentSlide
			}));
			if (!state) return;
			var triggerSlideHandler = state["triggerSlideHandler"];
			delete state["triggerSlideHandler"];
			this.setState(state);
			if (triggerSlideHandler === void 0) return;
			this.slideHandler(triggerSlideHandler);
			if (this.$props.verticalSwiping) this.enableBodyScroll();
		},
		touchEnd: function touchEnd(e) {
			this.swipeEnd(e);
			this.clickable = true;
		},
		slickPrev: function slickPrev() {
			var _this7 = this;
			this.callbackTimers.push(setTimeout(function() {
				return _this7.changeSlide({ message: "previous" });
			}, 0));
		},
		slickNext: function slickNext() {
			var _this8 = this;
			this.callbackTimers.push(setTimeout(function() {
				return _this8.changeSlide({ message: "next" });
			}, 0));
		},
		slickGoTo: function slickGoTo(slide) {
			var _this9 = this;
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			slide = Number(slide);
			if (isNaN(slide)) return "";
			this.callbackTimers.push(setTimeout(function() {
				return _this9.changeSlide({
					message: "index",
					index: slide,
					currentSlide: _this9.currentSlide
				}, dontAnimate);
			}, 0));
		},
		play: function play() {
			var nextIndex;
			if (this.rtl) nextIndex = this.currentSlide - this.slidesToScroll;
			else if (canGoNext(_objectSpread2(_objectSpread2({}, this.$props), this.$data))) nextIndex = this.currentSlide + this.slidesToScroll;
			else return false;
			this.slideHandler(nextIndex);
		},
		handleAutoPlay: function handleAutoPlay(playType) {
			if (this.autoplayTimer) clearInterval(this.autoplayTimer);
			var autoplaying = this.autoplaying;
			if (playType === "update") {
				if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") return;
			} else if (playType === "leave") {
				if (autoplaying === "paused" || autoplaying === "focused") return;
			} else if (playType === "blur") {
				if (autoplaying === "paused" || autoplaying === "hovered") return;
			}
			this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50);
			this.setState({ autoplaying: "playing" });
		},
		pause: function pause(pauseType) {
			if (this.autoplayTimer) {
				clearInterval(this.autoplayTimer);
				this.autoplayTimer = null;
			}
			var autoplaying = this.autoplaying;
			if (pauseType === "paused") this.setState({ autoplaying: "paused" });
			else if (pauseType === "focused") {
				if (autoplaying === "hovered" || autoplaying === "playing") this.setState({ autoplaying: "focused" });
			} else if (autoplaying === "playing") this.setState({ autoplaying: "hovered" });
		},
		onDotsOver: function onDotsOver() {
			this.autoplay && this.pause("hovered");
		},
		onDotsLeave: function onDotsLeave() {
			this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
		},
		onTrackOver: function onTrackOver() {
			this.autoplay && this.pause("hovered");
		},
		onTrackLeave: function onTrackLeave() {
			this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
		},
		onSlideFocus: function onSlideFocus() {
			this.autoplay && this.pause("focused");
		},
		onSlideBlur: function onSlideBlur() {
			this.autoplay && this.autoplaying === "focused" && this.handleAutoPlay("blur");
		},
		customPaging: function customPaging(_ref) {
			var i = _ref.i;
			return createVNode("button", null, [i + 1]);
		},
		appendDots: function appendDots(_ref2) {
			var dots = _ref2.dots;
			return createVNode("ul", { "style": { display: "block" } }, [dots]);
		}
	},
	render: function render() {
		var _listProps, _this10 = this;
		var className = classNames_default("slick-slider", this.$attrs.class, {
			"slick-vertical": this.vertical,
			"slick-initialized": true
		});
		var spec = _objectSpread2(_objectSpread2({}, this.$props), this.$data);
		var trackProps = extractObject(spec, [
			"fade",
			"cssEase",
			"speed",
			"infinite",
			"centerMode",
			"focusOnSelect",
			"currentSlide",
			"lazyLoad",
			"lazyLoadedList",
			"rtl",
			"slideWidth",
			"slideHeight",
			"listHeight",
			"vertical",
			"slidesToShow",
			"slidesToScroll",
			"slideCount",
			"trackStyle",
			"variableWidth",
			"unslick",
			"centerPadding",
			"targetSlide",
			"useCSS"
		]);
		var pauseOnHover = this.$props.pauseOnHover;
		trackProps = _objectSpread2(_objectSpread2({}, trackProps), {}, {
			focusOnSelect: this.focusOnSelect && this.clickable ? this.selectHandler : null,
			ref: this.trackRefHandler,
			onMouseleave: pauseOnHover ? this.onTrackLeave : noop,
			onMouseover: pauseOnHover ? this.onTrackOver : noop
		});
		var dots;
		if (this.dots === true && this.slideCount >= this.slidesToShow) {
			var dotProps = extractObject(spec, [
				"dotsClass",
				"slideCount",
				"slidesToShow",
				"currentSlide",
				"slidesToScroll",
				"clickHandler",
				"children",
				"infinite",
				"appendDots"
			]);
			dotProps.customPaging = this.customPaging;
			dotProps.appendDots = this.appendDots;
			var _this$$slots = this.$slots, customPaging = _this$$slots.customPaging, appendDots = _this$$slots.appendDots;
			if (customPaging) dotProps.customPaging = customPaging;
			if (appendDots) dotProps.appendDots = appendDots;
			var pauseOnDotsHover = this.$props.pauseOnDotsHover;
			dotProps = _objectSpread2(_objectSpread2({}, dotProps), {}, {
				clickHandler: this.changeSlide,
				onMouseover: pauseOnDotsHover ? this.onDotsOver : noop,
				onMouseleave: pauseOnDotsHover ? this.onDotsLeave : noop
			});
			dots = createVNode(dots_default, dotProps, null);
		}
		var prevArrow, nextArrow;
		var arrowProps = extractObject(spec, [
			"infinite",
			"centerMode",
			"currentSlide",
			"slideCount",
			"slidesToShow"
		]);
		arrowProps.clickHandler = this.changeSlide;
		var _this$$slots2 = this.$slots, prevArrowCustom = _this$$slots2.prevArrow, nextArrowCustom = _this$$slots2.nextArrow;
		if (prevArrowCustom) arrowProps.prevArrow = prevArrowCustom;
		if (nextArrowCustom) arrowProps.nextArrow = nextArrowCustom;
		if (this.arrows) {
			prevArrow = createVNode(PrevArrow, arrowProps, null);
			nextArrow = createVNode(NextArrow, arrowProps, null);
		}
		var verticalHeightStyle = null;
		if (this.vertical) verticalHeightStyle = { height: typeof this.listHeight === "number" ? "".concat(this.listHeight, "px") : this.listHeight };
		var centerPaddingStyle = null;
		if (this.vertical === false) {
			if (this.centerMode === true) centerPaddingStyle = { padding: "0px " + this.centerPadding };
		} else if (this.centerMode === true) centerPaddingStyle = { padding: this.centerPadding + " 0px" };
		var listStyle = _objectSpread2(_objectSpread2({}, verticalHeightStyle), centerPaddingStyle);
		var touchMove = this.touchMove;
		var listProps = (_listProps = {
			ref: this.listRefHandler,
			class: "slick-list",
			style: listStyle,
			onClick: this.clickHandler,
			onMousedown: touchMove ? this.swipeStart : noop,
			onMousemove: this.dragging && touchMove ? this.swipeMove : noop,
			onMouseup: touchMove ? this.swipeEnd : noop,
			onMouseleave: this.dragging && touchMove ? this.swipeEnd : noop
		}, _defineProperty(_listProps, supportsPassive_default ? "onTouchstartPassive" : "onTouchstart", touchMove ? this.swipeStart : noop), _defineProperty(_listProps, supportsPassive_default ? "onTouchmovePassive" : "onTouchmove", this.dragging && touchMove ? this.swipeMove : noop), _defineProperty(_listProps, "onTouchend", touchMove ? this.touchEnd : noop), _defineProperty(_listProps, "onTouchcancel", this.dragging && touchMove ? this.swipeEnd : noop), _defineProperty(_listProps, "onKeydown", this.accessibility ? this.keyHandler : noop), _listProps);
		var innerSliderProps = {
			class: className,
			dir: "ltr",
			style: this.$attrs.style
		};
		if (this.unslick) {
			listProps = {
				class: "slick-list",
				ref: this.listRefHandler
			};
			innerSliderProps = { class: className };
		}
		return createVNode("div", innerSliderProps, [
			!this.unslick ? prevArrow : "",
			createVNode("div", listProps, [createVNode(track_default, trackProps, { default: function _default() {
				return [_this10.children];
			} })]),
			!this.unslick ? nextArrow : "",
			!this.unslick ? dots : ""
		]);
	}
};

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/slider.js
var slider_default = defineComponent({
	name: "Slider",
	mixins: [BaseMixin_default],
	inheritAttrs: false,
	props: _objectSpread2({}, default_props_default),
	data: function data() {
		this._responsiveMediaHandlers = [];
		return { breakpoint: null };
	},
	mounted: function mounted() {
		var _this = this;
		if (this.responsive) {
			var breakpoints = this.responsive.map(function(breakpt) {
				return breakpt.breakpoint;
			});
			breakpoints.sort(function(x, y) {
				return x - y;
			});
			breakpoints.forEach(function(breakpoint, index) {
				var bQuery;
				if (index === 0) bQuery = json2mq_default({
					minWidth: 0,
					maxWidth: breakpoint
				});
				else bQuery = json2mq_default({
					minWidth: breakpoints[index - 1] + 1,
					maxWidth: breakpoint
				});
				canUseDOM() && _this.media(bQuery, function() {
					_this.setState({ breakpoint });
				});
			});
			var query = json2mq_default({ minWidth: breakpoints.slice(-1)[0] });
			canUseDOM() && this.media(query, function() {
				_this.setState({ breakpoint: null });
			});
		}
	},
	beforeUnmount: function beforeUnmount() {
		this._responsiveMediaHandlers.forEach(function(obj) {
			obj.mql.removeListener(obj.listener);
		});
	},
	methods: {
		innerSliderRefHandler: function innerSliderRefHandler(ref$1) {
			this.innerSlider = ref$1;
		},
		media: function media(query, handler$1) {
			var mql = window.matchMedia(query);
			var listener = function listener$1(_ref) {
				if (_ref.matches) handler$1();
			};
			mql.addListener(listener);
			listener(mql);
			this._responsiveMediaHandlers.push({
				mql,
				query,
				listener
			});
		},
		slickPrev: function slickPrev() {
			var _this$innerSlider;
			(_this$innerSlider = this.innerSlider) === null || _this$innerSlider === void 0 || _this$innerSlider.slickPrev();
		},
		slickNext: function slickNext() {
			var _this$innerSlider2;
			(_this$innerSlider2 = this.innerSlider) === null || _this$innerSlider2 === void 0 || _this$innerSlider2.slickNext();
		},
		slickGoTo: function slickGoTo(slide) {
			var _this$innerSlider3;
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			(_this$innerSlider3 = this.innerSlider) === null || _this$innerSlider3 === void 0 || _this$innerSlider3.slickGoTo(slide, dontAnimate);
		},
		slickPause: function slickPause() {
			var _this$innerSlider4;
			(_this$innerSlider4 = this.innerSlider) === null || _this$innerSlider4 === void 0 || _this$innerSlider4.pause("paused");
		},
		slickPlay: function slickPlay() {
			var _this$innerSlider5;
			(_this$innerSlider5 = this.innerSlider) === null || _this$innerSlider5 === void 0 || _this$innerSlider5.handleAutoPlay("play");
		}
	},
	render: function render() {
		var _this2 = this;
		var settings;
		var newProps;
		if (this.breakpoint) {
			newProps = this.responsive.filter(function(resp) {
				return resp.breakpoint === _this2.breakpoint;
			});
			settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2(_objectSpread2({}, this.$props), newProps[0].settings);
		} else settings = _objectSpread2({}, this.$props);
		if (settings.centerMode) {
			if (settings.slidesToScroll > 1 && true) console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
			settings.slidesToScroll = 1;
		}
		if (settings.fade) {
			if (settings.slidesToShow > 1 && true) console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
			if (settings.slidesToScroll > 1 && true) console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
			settings.slidesToShow = 1;
			settings.slidesToScroll = 1;
		}
		var children = getSlot(this) || [];
		children = children.filter(function(child) {
			if (typeof child === "string") return !!child.trim();
			return !!child;
		});
		if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
			console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
			settings.variableWidth = false;
		}
		var newChildren = [];
		var currentWidth = null;
		for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
			var newSlide = [];
			for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
				var row = [];
				for (var k = j; k < j + settings.slidesPerRow; k += 1) {
					var _children$k$props;
					if (settings.variableWidth && (_children$k$props = children[k].props) !== null && _children$k$props !== void 0 && _children$k$props.style) currentWidth = children[k].props.style.width;
					if (k >= children.length) break;
					row.push(cloneElement(children[k], {
						key: 100 * i + 10 * j + k,
						tabindex: -1,
						style: {
							width: "".concat(100 / settings.slidesPerRow, "%"),
							display: "inline-block"
						}
					}));
				}
				newSlide.push(createVNode("div", { "key": 10 * i + j }, [row]));
			}
			if (settings.variableWidth) newChildren.push(createVNode("div", {
				"key": i,
				"style": { width: currentWidth }
			}, [newSlide]));
			else newChildren.push(createVNode("div", { "key": i }, [newSlide]));
		}
		if (settings === "unslick") {
			var className = "regular slider " + (this.className || "");
			return createVNode("div", { "class": className }, [children]);
		} else if (newChildren.length <= settings.slidesToShow) settings.unslick = true;
		return createVNode(inner_slider_default, _objectSpread2(_objectSpread2({}, _objectSpread2(_objectSpread2(_objectSpread2({}, this.$attrs), settings), {}, {
			children: newChildren,
			ref: this.innerSliderRefHandler
		})), {}, { "__propsSymbol__": [] }), this.$slots);
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-slick/index.js
var vc_slick_default = slider_default;

//#endregion
//#region node_modules/ant-design-vue/es/carousel/index.js
var _excluded = ["class", "style"];
var carouselProps = function carouselProps$1() {
	return {
		effect: String,
		dots: {
			type: Boolean,
			default: true
		},
		vertical: {
			type: Boolean,
			default: void 0
		},
		autoplay: {
			type: Boolean,
			default: void 0
		},
		easing: String,
		beforeChange: Function,
		afterChange: Function,
		prefixCls: String,
		accessibility: {
			type: Boolean,
			default: void 0
		},
		nextArrow: vue_types_default.any,
		prevArrow: vue_types_default.any,
		pauseOnHover: {
			type: Boolean,
			default: void 0
		},
		adaptiveHeight: {
			type: Boolean,
			default: void 0
		},
		arrows: {
			type: Boolean,
			default: false
		},
		autoplaySpeed: Number,
		centerMode: {
			type: Boolean,
			default: void 0
		},
		centerPadding: String,
		cssEase: String,
		dotsClass: String,
		draggable: {
			type: Boolean,
			default: false
		},
		fade: {
			type: Boolean,
			default: void 0
		},
		focusOnSelect: {
			type: Boolean,
			default: void 0
		},
		infinite: {
			type: Boolean,
			default: void 0
		},
		initialSlide: Number,
		lazyLoad: String,
		rtl: {
			type: Boolean,
			default: void 0
		},
		slide: String,
		slidesToShow: Number,
		slidesToScroll: Number,
		speed: Number,
		swipe: {
			type: Boolean,
			default: void 0
		},
		swipeToSlide: {
			type: Boolean,
			default: void 0
		},
		swipeEvent: Function,
		touchMove: {
			type: Boolean,
			default: void 0
		},
		touchThreshold: Number,
		variableWidth: {
			type: Boolean,
			default: void 0
		},
		useCSS: {
			type: Boolean,
			default: void 0
		},
		slickGoTo: Number,
		responsive: Array,
		dotPosition: {
			type: String,
			default: void 0
		},
		verticalSwiping: {
			type: Boolean,
			default: false
		}
	};
};
var Carousel = defineComponent({
	compatConfig: { MODE: 3 },
	name: "ACarousel",
	inheritAttrs: false,
	props: carouselProps(),
	setup: function setup(props, _ref) {
		var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
		var slickRef = ref();
		expose({
			goTo: function goTo(slide) {
				var _slickRef$value;
				var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
				(_slickRef$value = slickRef.value) === null || _slickRef$value === void 0 || _slickRef$value.slickGoTo(slide, dontAnimate);
			},
			autoplay: function autoplay(palyType) {
				var _slickRef$value2, _slickRef$value2$inne;
				(_slickRef$value2 = slickRef.value) === null || _slickRef$value2 === void 0 || (_slickRef$value2$inne = _slickRef$value2.innerSlider) == null || _slickRef$value2$inne.handleAutoPlay(palyType);
			},
			prev: function prev() {
				var _slickRef$value3;
				(_slickRef$value3 = slickRef.value) === null || _slickRef$value3 === void 0 || _slickRef$value3.slickPrev();
			},
			next: function next() {
				var _slickRef$value4;
				(_slickRef$value4 = slickRef.value) === null || _slickRef$value4 === void 0 || _slickRef$value4.slickNext();
			},
			innerSlider: computed(function() {
				var _slickRef$value5;
				return (_slickRef$value5 = slickRef.value) === null || _slickRef$value5 === void 0 ? void 0 : _slickRef$value5.innerSlider;
			})
		});
		watchEffect(function() {
			warning_default(props.vertical === void 0, "Carousel", "`vertical` is deprecated, please use `dotPosition` instead.");
		});
		var _useConfigInject = useConfigInject_default("carousel", props), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
		var dotPosition = computed(function() {
			if (props.dotPosition) return props.dotPosition;
			if (props.vertical !== void 0) return props.vertical ? "right" : "bottom";
			return "bottom";
		});
		var vertical = computed(function() {
			return dotPosition.value === "left" || dotPosition.value === "right";
		});
		var dsClass = computed(function() {
			var _classNames;
			var dotsClass = "slick-dots";
			return classNames_default((_classNames = {}, _defineProperty(_classNames, dotsClass, true), _defineProperty(_classNames, "".concat(dotsClass, "-").concat(dotPosition.value), true), _defineProperty(_classNames, "".concat(props.dotsClass), !!props.dotsClass), _classNames));
		});
		return function() {
			var _classNames2;
			var dots = props.dots, arrows = props.arrows, draggable = props.draggable, effect = props.effect;
			var cls = attrs.class, style = attrs.style, restAttrs = _objectWithoutProperties(attrs, _excluded);
			var fade = effect === "fade" ? true : props.fade;
			var className = classNames_default(prefixCls.value, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty(_classNames2, "".concat(prefixCls.value, "-vertical"), vertical.value), _defineProperty(_classNames2, "".concat(cls), !!cls), _classNames2));
			return createVNode("div", {
				"class": className,
				"style": style
			}, [createVNode(vc_slick_default, _objectSpread2(_objectSpread2(_objectSpread2({ "ref": slickRef }, props), restAttrs), {}, {
				"dots": !!dots,
				"dotsClass": dsClass.value,
				"arrows": arrows,
				"draggable": draggable,
				"fade": fade,
				"vertical": vertical.value
			}), slots)]);
		};
	}
});
var carousel_default = withInstall(Carousel);

//#endregion
export { isSymbol_default as a, toNumber_default as i, carousel_default as n, debounce_default as r, carouselProps as t };
//# sourceMappingURL=carousel-DWT7tKOd.js.map