import { B as flattenChildren, Ct as toPropertyKey, St as _defineProperty, g as transition_default, o as devWarning_default, t as useConfigInject_default, tt as initDefaultProps_default, w as vue_types_default, wt as _typeof, xt as _objectSpread2, z as findDOMNode } from "./useConfigInject-B_ZZSFXy.js";
import { Bt as onUpdated, Ft as onMounted, Kn as ref, L as Text, Ot as nextTick, U as computed, _n as watchEffect, et as createVNode, gn as watch, jt as onBeforeUnmount, nt as defineComponent, ut as getCurrentInstance } from "./vue.runtime.esm-bundler-D9ZX2hko.js";
import { t as LoadingOutlined_default } from "./LoadingOutlined-bNk5AUPk.js";
import { t as wrapperRaf } from "./raf-DGOxPce_.js";

//#region node_modules/ant-design-vue/es/_util/css-animation/Event.js
var START_EVENT_NAME_MAP = {
	transitionstart: {
		transition: "transitionstart",
		WebkitTransition: "webkitTransitionStart",
		MozTransition: "mozTransitionStart",
		OTransition: "oTransitionStart",
		msTransition: "MSTransitionStart"
	},
	animationstart: {
		animation: "animationstart",
		WebkitAnimation: "webkitAnimationStart",
		MozAnimation: "mozAnimationStart",
		OAnimation: "oAnimationStart",
		msAnimation: "MSAnimationStart"
	}
};
var END_EVENT_NAME_MAP = {
	transitionend: {
		transition: "transitionend",
		WebkitTransition: "webkitTransitionEnd",
		MozTransition: "mozTransitionEnd",
		OTransition: "oTransitionEnd",
		msTransition: "MSTransitionEnd"
	},
	animationend: {
		animation: "animationend",
		WebkitAnimation: "webkitAnimationEnd",
		MozAnimation: "mozAnimationEnd",
		OAnimation: "oAnimationEnd",
		msAnimation: "MSAnimationEnd"
	}
};
var startEvents = [];
var endEvents = [];
function detectEvents() {
	var style = document.createElement("div").style;
	if (!("AnimationEvent" in window)) {
		delete START_EVENT_NAME_MAP.animationstart.animation;
		delete END_EVENT_NAME_MAP.animationend.animation;
	}
	if (!("TransitionEvent" in window)) {
		delete START_EVENT_NAME_MAP.transitionstart.transition;
		delete END_EVENT_NAME_MAP.transitionend.transition;
	}
	function process(EVENT_NAME_MAP, events) {
		for (var baseEventName in EVENT_NAME_MAP) if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
			var baseEvents = EVENT_NAME_MAP[baseEventName];
			for (var styleName in baseEvents) if (styleName in style) {
				events.push(baseEvents[styleName]);
				break;
			}
		}
	}
	process(START_EVENT_NAME_MAP, startEvents);
	process(END_EVENT_NAME_MAP, endEvents);
}
if (typeof window !== "undefined" && typeof document !== "undefined") detectEvents();
function addEventListener(node, eventName, eventListener) {
	node.addEventListener(eventName, eventListener, false);
}
function removeEventListener(node, eventName, eventListener) {
	node.removeEventListener(eventName, eventListener, false);
}
var TransitionEvents = {
	startEvents,
	addStartEventListener: function addStartEventListener(node, eventListener) {
		if (startEvents.length === 0) {
			setTimeout(eventListener, 0);
			return;
		}
		startEvents.forEach(function(startEvent) {
			addEventListener(node, startEvent, eventListener);
		});
	},
	removeStartEventListener: function removeStartEventListener(node, eventListener) {
		if (startEvents.length === 0) return;
		startEvents.forEach(function(startEvent) {
			removeEventListener(node, startEvent, eventListener);
		});
	},
	endEvents,
	addEndEventListener: function addEndEventListener(node, eventListener) {
		if (endEvents.length === 0) {
			setTimeout(eventListener, 0);
			return;
		}
		endEvents.forEach(function(endEvent) {
			addEventListener(node, endEvent, eventListener);
		});
	},
	removeEndEventListener: function removeEndEventListener(node, eventListener) {
		if (endEvents.length === 0) return;
		endEvents.forEach(function(endEvent) {
			removeEventListener(node, endEvent, eventListener);
		});
	}
};
var Event_default = TransitionEvents;

//#endregion
//#region node_modules/ant-design-vue/es/_util/wave.js
var styleForPesudo;
function isHidden(element) {
	return !element || element.offsetParent === null;
}
function isNotGrey(color) {
	var match = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);
	if (match && match[1] && match[2] && match[3]) return !(match[1] === match[2] && match[2] === match[3]);
	return true;
}
var wave_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Wave",
	props: {
		insertExtraNode: Boolean,
		disabled: Boolean
	},
	setup: function setup(props, _ref) {
		var slots = _ref.slots, expose = _ref.expose;
		var instance = getCurrentInstance();
		var _useConfigInject = useConfigInject_default("", props), csp = _useConfigInject.csp, prefixCls = _useConfigInject.prefixCls;
		expose({ csp });
		var eventIns = null;
		var clickWaveTimeoutId = null;
		var animationStartId = null;
		var animationStart = false;
		var extraNode = null;
		var isUnmounted = false;
		var onTransitionStart = function onTransitionStart$1(e) {
			if (isUnmounted) return;
			var node = findDOMNode(instance);
			if (!e || e.target !== node) return;
			if (!animationStart) resetEffect(node);
		};
		var onTransitionEnd = function onTransitionEnd$1(e) {
			if (!e || e.animationName !== "fadeEffect") return;
			resetEffect(e.target);
		};
		var getAttributeName = function getAttributeName$1() {
			return props.insertExtraNode ? "".concat(prefixCls.value, "-click-animating") : "".concat(prefixCls.value, "-click-animating-without-extra-node");
		};
		var onClick = function onClick$1(node, waveColor) {
			var insertExtraNode = props.insertExtraNode;
			if (props.disabled || !node || isHidden(node) || node.className.indexOf("-leave") >= 0) return;
			extraNode = document.createElement("div");
			extraNode.className = "".concat(prefixCls.value, "-click-animating-node");
			var attributeName = getAttributeName();
			node.removeAttribute(attributeName);
			node.setAttribute(attributeName, "true");
			styleForPesudo = styleForPesudo || document.createElement("style");
			if (waveColor && waveColor !== "#ffffff" && waveColor !== "rgb(255, 255, 255)" && isNotGrey(waveColor) && !/rgba\(\d*, \d*, \d*, 0\)/.test(waveColor) && waveColor !== "transparent") {
				var _csp$value;
				if ((_csp$value = csp.value) !== null && _csp$value !== void 0 && _csp$value.nonce) styleForPesudo.nonce = csp.value.nonce;
				extraNode.style.borderColor = waveColor;
				styleForPesudo.innerHTML = "\n        [".concat(prefixCls.value, "-click-animating-without-extra-node='true']::after, .").concat(prefixCls.value, "-click-animating-node {\n          --antd-wave-shadow-color: ").concat(waveColor, ";\n        }");
				if (!document.body.contains(styleForPesudo)) document.body.appendChild(styleForPesudo);
			}
			if (insertExtraNode) node.appendChild(extraNode);
			Event_default.addStartEventListener(node, onTransitionStart);
			Event_default.addEndEventListener(node, onTransitionEnd);
		};
		var resetEffect = function resetEffect$1(node) {
			if (!node || node === extraNode || !(node instanceof Element)) return;
			var insertExtraNode = props.insertExtraNode;
			var attributeName = getAttributeName();
			node.setAttribute(attributeName, "false");
			if (styleForPesudo) styleForPesudo.innerHTML = "";
			if (insertExtraNode && extraNode && node.contains(extraNode)) node.removeChild(extraNode);
			Event_default.removeStartEventListener(node, onTransitionStart);
			Event_default.removeEndEventListener(node, onTransitionEnd);
		};
		var bindAnimationEvent = function bindAnimationEvent$1(node) {
			if (!node || !node.getAttribute || node.getAttribute("disabled") || node.className.indexOf("disabled") >= 0) return;
			var newClick = function newClick$1(e) {
				if (e.target.tagName === "INPUT" || isHidden(e.target)) return;
				resetEffect(node);
				var waveColor = getComputedStyle(node).getPropertyValue("border-top-color") || getComputedStyle(node).getPropertyValue("border-color") || getComputedStyle(node).getPropertyValue("background-color");
				clickWaveTimeoutId = setTimeout(function() {
					return onClick(node, waveColor);
				}, 0);
				wrapperRaf.cancel(animationStartId);
				animationStart = true;
				animationStartId = wrapperRaf(function() {
					animationStart = false;
				}, 10);
			};
			node.addEventListener("click", newClick, true);
			return { cancel: function cancel() {
				node.removeEventListener("click", newClick, true);
			} };
		};
		onMounted(function() {
			nextTick(function() {
				var node = findDOMNode(instance);
				if (node.nodeType !== 1) return;
				eventIns = bindAnimationEvent(node);
			});
		});
		onBeforeUnmount(function() {
			if (eventIns) eventIns.cancel();
			clearTimeout(clickWaveTimeoutId);
			isUnmounted = true;
		});
		return function() {
			var _slots$default;
			return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)[0];
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/button/buttonTypes.js
function convertLegacyProps(type) {
	if (type === "danger") return { danger: true };
	return { type };
}
var buttonProps = function buttonProps$1() {
	return {
		prefixCls: String,
		type: String,
		htmlType: {
			type: String,
			default: "button"
		},
		shape: { type: String },
		size: { type: String },
		loading: {
			type: [Boolean, Object],
			default: function _default() {
				return false;
			}
		},
		disabled: {
			type: Boolean,
			default: void 0
		},
		ghost: {
			type: Boolean,
			default: void 0
		},
		block: {
			type: Boolean,
			default: void 0
		},
		danger: {
			type: Boolean,
			default: void 0
		},
		icon: vue_types_default.any,
		href: String,
		target: String,
		title: String,
		onClick: { type: Function },
		onMousedown: { type: Function }
	};
};
var buttonTypes_default = buttonProps;

//#endregion
//#region node_modules/ant-design-vue/es/button/LoadingIcon.js
var getCollapsedWidth = function getCollapsedWidth$1(node) {
	if (node) {
		node.style.width = "0px";
		node.style.opacity = "0";
		node.style.transform = "scale(0)";
	}
};
var getRealWidth = function getRealWidth$1(node) {
	nextTick(function() {
		if (node) {
			node.style.width = "".concat(node.scrollWidth, "px");
			node.style.opacity = "1";
			node.style.transform = "scale(1)";
		}
	});
};
var resetStyle = function resetStyle$1(node) {
	if (node && node.style) {
		node.style.width = null;
		node.style.opacity = null;
		node.style.transform = null;
	}
};
var LoadingIcon_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "LoadingIcon",
	props: {
		prefixCls: String,
		loading: [Boolean, Object],
		existIcon: Boolean
	},
	setup: function setup(props) {
		return function() {
			var existIcon = props.existIcon, prefixCls = props.prefixCls, loading = props.loading;
			if (existIcon) return createVNode("span", { "class": "".concat(prefixCls, "-loading-icon") }, [createVNode(LoadingOutlined_default, null, null)]);
			var visible = !!loading;
			return createVNode(transition_default, {
				"name": "".concat(prefixCls, "-loading-icon-motion"),
				"onBeforeEnter": getCollapsedWidth,
				"onEnter": getRealWidth,
				"onAfterEnter": resetStyle,
				"onBeforeLeave": getRealWidth,
				"onLeave": function onLeave(node) {
					setTimeout(function() {
						getCollapsedWidth(node);
					});
				},
				"onAfterLeave": resetStyle
			}, { default: function _default() {
				return [visible ? createVNode("span", { "class": "".concat(prefixCls, "-loading-icon") }, [createVNode(LoadingOutlined_default, null, null)]) : null];
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/button/button.js
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isUnborderedButtonType(type) {
	return type === "text" || type === "link";
}
var button_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "AButton",
	inheritAttrs: false,
	__ANT_BUTTON: true,
	props: initDefaultProps_default(buttonTypes_default(), { type: "default" }),
	slots: ["icon"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
		var _useConfigInject = useConfigInject_default("btn", props), prefixCls = _useConfigInject.prefixCls, autoInsertSpaceInButton = _useConfigInject.autoInsertSpaceInButton, direction = _useConfigInject.direction, size = _useConfigInject.size;
		var buttonNodeRef = ref(null);
		var delayTimeoutRef = ref(void 0);
		var isNeedInserted = false;
		var innerLoading = ref(false);
		var hasTwoCNChar = ref(false);
		var autoInsertSpace = computed(function() {
			return autoInsertSpaceInButton.value !== false;
		});
		var loadingOrDelay = computed(function() {
			return _typeof(props.loading) === "object" && props.loading.delay ? props.loading.delay || true : !!props.loading;
		});
		watch(loadingOrDelay, function(val) {
			clearTimeout(delayTimeoutRef.value);
			if (typeof loadingOrDelay.value === "number") delayTimeoutRef.value = setTimeout(function() {
				innerLoading.value = val;
			}, loadingOrDelay.value);
			else innerLoading.value = val;
		}, { immediate: true });
		var classes = computed(function() {
			var _ref2;
			var type = props.type, _props$shape = props.shape, shape = _props$shape === void 0 ? "default" : _props$shape, ghost = props.ghost, block = props.block, danger = props.danger;
			var pre = prefixCls.value;
			var sizeClassNameMap = {
				large: "lg",
				small: "sm",
				middle: void 0
			};
			var sizeFullname = size.value;
			var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
			return _ref2 = {}, _defineProperty(_ref2, "".concat(pre), true), _defineProperty(_ref2, "".concat(pre, "-").concat(type), type), _defineProperty(_ref2, "".concat(pre, "-").concat(shape), shape !== "default" && shape), _defineProperty(_ref2, "".concat(pre, "-").concat(sizeCls), sizeCls), _defineProperty(_ref2, "".concat(pre, "-loading"), innerLoading.value), _defineProperty(_ref2, "".concat(pre, "-background-ghost"), ghost && !isUnborderedButtonType(type)), _defineProperty(_ref2, "".concat(pre, "-two-chinese-chars"), hasTwoCNChar.value && autoInsertSpace.value), _defineProperty(_ref2, "".concat(pre, "-block"), block), _defineProperty(_ref2, "".concat(pre, "-dangerous"), !!danger), _defineProperty(_ref2, "".concat(pre, "-rtl"), direction.value === "rtl"), _ref2;
		});
		var fixTwoCNChar = function fixTwoCNChar$1() {
			var node = buttonNodeRef.value;
			if (!node || autoInsertSpaceInButton.value === false) return;
			var buttonText = node.textContent;
			if (isNeedInserted && isTwoCNChar(buttonText)) {
				if (!hasTwoCNChar.value) hasTwoCNChar.value = true;
			} else if (hasTwoCNChar.value) hasTwoCNChar.value = false;
		};
		var handleClick = function handleClick$1(event) {
			if (innerLoading.value || props.disabled) {
				event.preventDefault();
				return;
			}
			emit("click", event);
		};
		var insertSpace = function insertSpace$1(child, needInserted) {
			var SPACE = needInserted ? " " : "";
			if (child.type === Text) {
				var text = child.children.trim();
				if (isTwoCNChar(text)) text = text.split("").join(SPACE);
				return createVNode("span", null, [text]);
			}
			return child;
		};
		watchEffect(function() {
			devWarning_default(!(props.ghost && isUnborderedButtonType(props.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
		});
		onMounted(fixTwoCNChar);
		onUpdated(fixTwoCNChar);
		onBeforeUnmount(function() {
			delayTimeoutRef.value && clearTimeout(delayTimeoutRef.value);
		});
		return function() {
			var _slots$icon, _slots$default;
			var _props$icon = props.icon, icon = _props$icon === void 0 ? (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots) : _props$icon;
			var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
			isNeedInserted = children.length === 1 && !icon && !isUnborderedButtonType(props.type);
			var type = props.type, htmlType = props.htmlType, disabled = props.disabled, href = props.href, title = props.title, target = props.target, onMousedown = props.onMousedown;
			var iconType = innerLoading.value ? "loading" : icon;
			var buttonProps$1 = _objectSpread2(_objectSpread2({}, attrs), {}, {
				title,
				disabled,
				class: [
					classes.value,
					attrs.class,
					_defineProperty({}, "".concat(prefixCls.value, "-icon-only"), children.length === 0 && !!iconType)
				],
				onClick: handleClick,
				onMousedown
			});
			if (!disabled) delete buttonProps$1.disabled;
			var iconNode = icon && !innerLoading.value ? icon : createVNode(LoadingIcon_default, {
				"existIcon": !!icon,
				"prefixCls": prefixCls.value,
				"loading": !!innerLoading.value
			}, null);
			var kids = children.map(function(child) {
				return insertSpace(child, isNeedInserted && autoInsertSpace.value);
			});
			if (href !== void 0) return createVNode("a", _objectSpread2(_objectSpread2({}, buttonProps$1), {}, {
				"href": href,
				"target": target,
				"ref": buttonNodeRef
			}), [iconNode, kids]);
			var buttonNode = createVNode("button", _objectSpread2(_objectSpread2({}, buttonProps$1), {}, {
				"ref": buttonNodeRef,
				"type": htmlType
			}), [iconNode, kids]);
			if (isUnborderedButtonType(type)) return buttonNode;
			return createVNode(wave_default, {
				"ref": "wave",
				"disabled": !!innerLoading.value
			}, { default: function _default() {
				return [buttonNode];
			} });
		};
	}
});

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
	for (var t = 0; t < r.length; t++) {
		var o = r[t];
		o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
	}
}
function _createClass(e, r, t) {
	return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
	if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

//#endregion
//#region node_modules/ant-design-vue/es/_util/unreachableException.js
var UnreachableException = /* @__PURE__ */ _createClass(function UnreachableException$1(value) {
	_classCallCheck(this, UnreachableException$1);
	this.error = new Error("unreachable case: ".concat(JSON.stringify(value)));
});

//#endregion
//#region node_modules/ant-design-vue/es/button/button-group.js
var buttonGroupProps = function buttonGroupProps$1() {
	return {
		prefixCls: String,
		size: { type: String }
	};
};
var button_group_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "AButtonGroup",
	props: buttonGroupProps(),
	setup: function setup(props, _ref) {
		var slots = _ref.slots;
		var _useConfigInject = useConfigInject_default("btn-group", props), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
		var classes = computed(function() {
			var _ref2;
			var size = props.size;
			var sizeCls = "";
			switch (size) {
				case "large":
					sizeCls = "lg";
					break;
				case "small":
					sizeCls = "sm";
					break;
				case "middle":
				case void 0: break;
				default: console.warn(new UnreachableException(size).error);
			}
			return _ref2 = {}, _defineProperty(_ref2, "".concat(prefixCls.value), true), _defineProperty(_ref2, "".concat(prefixCls.value, "-").concat(sizeCls), sizeCls), _defineProperty(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref2;
		});
		return function() {
			var _slots$default;
			return createVNode("div", { "class": classes.value }, [flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))]);
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/button/index.js
button_default.Group = button_group_default;
/* istanbul ignore next */
button_default.install = function(app) {
	app.component(button_default.name, button_default);
	app.component(button_group_default.name, button_group_default);
	return app;
};
var button_default$1 = button_default;

//#endregion
export { buttonTypes_default as a, _createClass as i, button_group_default as n, convertLegacyProps as o, _classCallCheck as r, wave_default as s, button_default$1 as t };
//# sourceMappingURL=button-CBBEog5d.js.map