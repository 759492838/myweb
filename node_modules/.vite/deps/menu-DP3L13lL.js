import { B as flattenChildren, Dt as __toESM, G as getPropsSlot, H as getComponent, I as withInstall, J as hasProp, K as getSlot, L as filterEmpty, N as _objectWithoutProperties, P as tuple, Q as isValidElement, St as _defineProperty, U as getEvents, _t as classNames_default, bt as _extends, ct as _Symbol_default, dt as _toConsumableArray, g as transition_default, h as getTransitionProps, it as isObjectLike_default, l as require_regenerator, lt as _root_default, nt as isValid_default, o as devWarning_default, ot as _overArg_default, pt as _slicedToArray, q as getStyle, st as _baseGetTag_default, t as useConfigInject_default, tt as initDefaultProps_default, u as _asyncToGenerator, ut as _freeGlobal_default, v as warning_default, w as vue_types_default, wt as _typeof, xt as _objectSpread2, z as findDOMNode } from "./useConfigInject-B_ZZSFXy.js";
import { At as onBeforeMount, Bt as onUpdated, C as vShow, Cn as withDirectives, Ft as onMounted, I as Teleport, Kn as ref, M as Fragment, Ot as nextTick, Qn as toRef, T as withModifiers, U as computed, Ut as provide, Wn as reactive, Xt as resolveDirective, Zn as toRaw, _n as watchEffect, et as createVNode, gn as watch, jt as onBeforeUnmount, n as Transition, nr as unref, nt as defineComponent, ut as getCurrentInstance, xt as inject, zt as onUnmounted } from "./vue.runtime.esm-bundler-D9ZX2hko.js";
import { t as EllipsisOutlined_default } from "./EllipsisOutlined-IwOYB21z.js";
import { a as supportsPassive_default, n as isObject_default, o as ResizeObserver_es_default, r as cloneElement, t as BaseMixin_default } from "./BaseMixin-CrhV1mbx.js";
import { t as wrapperRaf } from "./raf-DGOxPce_.js";

//#region node_modules/ant-design-vue/es/vc-resize-observer/index.js
var vc_resize_observer_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "ResizeObserver",
	props: {
		disabled: Boolean,
		onResize: Function
	},
	emits: ["resize"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots;
		var state = reactive({
			width: 0,
			height: 0,
			offsetHeight: 0,
			offsetWidth: 0
		});
		var currentElement = null;
		var resizeObserver = null;
		var destroyObserver = function destroyObserver$1() {
			if (resizeObserver) {
				resizeObserver.disconnect();
				resizeObserver = null;
			}
		};
		var onResize = function onResize$1(entries) {
			var onResize$2 = props.onResize;
			var target = entries[0].target;
			var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
			var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
			/**
			* Resize observer trigger when content size changed.
			* In most case we just care about element size,
			* let's use `boundary` instead of `contentRect` here to avoid shaking.
			*/
			var fixedWidth = Math.floor(width);
			var fixedHeight = Math.floor(height);
			if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
				var size = {
					width: fixedWidth,
					height: fixedHeight,
					offsetWidth,
					offsetHeight
				};
				_extends(state, size);
				if (onResize$2) Promise.resolve().then(function() {
					onResize$2(_objectSpread2(_objectSpread2({}, size), {}, {
						offsetWidth,
						offsetHeight
					}), target);
				});
			}
		};
		var instance = getCurrentInstance();
		var registerObserver = function registerObserver$1() {
			if (props.disabled) {
				destroyObserver();
				return;
			}
			var element = findDOMNode(instance);
			if (element !== currentElement) {
				destroyObserver();
				currentElement = element;
			}
			if (!resizeObserver && element) {
				resizeObserver = new ResizeObserver_es_default(onResize);
				resizeObserver.observe(element);
			}
		};
		onMounted(function() {
			registerObserver();
		});
		onUpdated(function() {
			registerObserver();
		});
		onUnmounted(function() {
			destroyObserver();
		});
		watch(function() {
			return props.disabled;
		}, function() {
			registerObserver();
		}, { flush: "post" });
		return function() {
			var _slots$default;
			return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)[0];
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-util/Dom/addEventListener.js
function addEventListenerWrap(target, eventType, cb, option) {
	if (target && target.addEventListener) {
		var opt = option;
		if (opt === void 0 && supportsPassive_default && (eventType === "touchstart" || eventType === "touchmove" || eventType === "wheel")) opt = { passive: false };
		target.addEventListener(eventType, cb, opt);
	}
	return { remove: function remove() {
		if (target && target.removeEventListener) target.removeEventListener(eventType, cb);
	} };
}

//#endregion
//#region node_modules/ant-design-vue/es/vc-util/Dom/contains.js
function contains(root, n) {
	if (!root) return false;
	return root.contains(n);
}

//#endregion
//#region node_modules/ant-design-vue/es/_util/getRequestAnimationFrame.js
var availablePrefixs = [
	"moz",
	"ms",
	"webkit"
];
function requestAnimationFramePolyfill() {
	var lastTime = 0;
	return function(callback) {
		var currTime = (/* @__PURE__ */ new Date()).getTime();
		var timeToCall = Math.max(0, 16 - (currTime - lastTime));
		var id = window.setTimeout(function() {
			callback(currTime + timeToCall);
		}, timeToCall);
		lastTime = currTime + timeToCall;
		return id;
	};
}
function getRequestAnimationFrame() {
	if (typeof window === "undefined") return function() {};
	if (window.requestAnimationFrame) return window.requestAnimationFrame.bind(window);
	var prefix = availablePrefixs.filter(function(key) {
		return "".concat(key, "RequestAnimationFrame") in window;
	})[0];
	return prefix ? window["".concat(prefix, "RequestAnimationFrame")] : requestAnimationFramePolyfill();
}
function cancelRequestAnimationFrame(id) {
	if (typeof window === "undefined") return null;
	if (window.cancelAnimationFrame) return window.cancelAnimationFrame(id);
	var prefix = availablePrefixs.filter(function(key) {
		return "".concat(key, "CancelAnimationFrame") in window || "".concat(key, "CancelRequestAnimationFrame") in window;
	})[0];
	return prefix ? (window["".concat(prefix, "CancelAnimationFrame")] || window["".concat(prefix, "CancelRequestAnimationFrame")]).call(this, id) : clearTimeout(id);
}

//#endregion
//#region node_modules/ant-design-vue/es/_util/requestAnimationTimeout.js
var raf = getRequestAnimationFrame();
var cancelAnimationTimeout = function cancelAnimationTimeout$1(frame) {
	return cancelRequestAnimationFrame(frame.id);
};
var requestAnimationTimeout = function requestAnimationTimeout$1(callback) {
	var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var start = Date.now();
	function timeout() {
		if (Date.now() - start >= delay) callback.call();
		else frame.id = raf(timeout);
	}
	var frame = { id: raf(timeout) };
	return frame;
};

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Popup/interface.js
var innerProps = {
	visible: Boolean,
	prefixCls: String,
	zIndex: Number,
	destroyPopupOnHide: Boolean,
	forceRender: Boolean,
	animation: [String, Object],
	transitionName: String,
	stretch: { type: String },
	align: { type: Object },
	point: { type: Object },
	getRootDomNode: { type: Function },
	getClassNameFromAlign: { type: Function },
	onMouseenter: { type: Function },
	onMouseleave: { type: Function },
	onMousedown: { type: Function },
	onTouchstart: { type: Function }
};
var mobileProps = _objectSpread2(_objectSpread2({}, innerProps), {}, { mobile: { type: Object } });
var popupProps = _objectSpread2(_objectSpread2({}, innerProps), {}, {
	mask: Boolean,
	mobile: { type: Object },
	maskAnimation: String,
	maskTransitionName: String
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/utils/motionUtil.js
function getMotion(_ref) {
	var prefixCls = _ref.prefixCls, animation = _ref.animation, transitionName = _ref.transitionName;
	if (animation) return { name: "".concat(prefixCls, "-").concat(animation) };
	if (transitionName) return { name: transitionName };
	return {};
}

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Popup/Mask.js
function Mask(props) {
	var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;
	if (!mask) return null;
	var motion = {};
	if (maskTransitionName || maskAnimation) motion = getMotion({
		prefixCls,
		transitionName: maskTransitionName,
		animation: maskAnimation
	});
	return createVNode(Transition, _objectSpread2({ "appear": true }, motion), { default: function _default() {
		return [withDirectives(createVNode("div", {
			"style": { zIndex },
			"class": "".concat(prefixCls, "-mask")
		}, null), [[resolveDirective("if"), visible]])];
	} });
}
Mask.displayName = "Mask";

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Popup/MobilePopupInner.js
var MobilePopupInner_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "MobilePopupInner",
	inheritAttrs: false,
	props: mobileProps,
	emits: [
		"mouseenter",
		"mouseleave",
		"mousedown",
		"touchstart",
		"align"
	],
	setup: function setup(props, _ref) {
		var expose = _ref.expose, slots = _ref.slots;
		var elementRef = ref();
		expose({
			forceAlign: function forceAlign() {},
			getElement: function getElement$1() {
				return elementRef.value;
			}
		});
		return function() {
			var _slots$default;
			var zIndex = props.zIndex, visible = props.visible, prefixCls = props.prefixCls, _props$mobile = props.mobile;
			_props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
			var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender;
			var mergedStyle = _objectSpread2({ zIndex }, popupStyle);
			var childNode = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
			if (childNode.length > 1) {
				(function() {
					return childNode;
				})();
				childNode = createVNode("div", { "class": "".concat(prefixCls, "-content") }, [childNode]);
			}
			if (popupRender) childNode = popupRender(childNode);
			var mergedClassName = classNames_default(prefixCls, popupClassName);
			return createVNode(Transition, _objectSpread2({ "ref": elementRef }, popupMotion), { default: function _default() {
				return [visible ? createVNode("div", {
					"class": mergedClassName,
					"style": mergedStyle
				}, [childNode]) : null];
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Popup/useVisibleStatus.js
var import_regenerator = /* @__PURE__ */ __toESM(require_regenerator());
var StatusQueue = [
	"measure",
	"align",
	null,
	"motion"
];
var useVisibleStatus_default = (function(visible, doMeasure) {
	var status = ref(null);
	var rafRef = ref();
	var destroyRef = ref(false);
	function setStatus(nextStatus) {
		if (!destroyRef.value) status.value = nextStatus;
	}
	function cancelRaf() {
		wrapperRaf.cancel(rafRef.value);
	}
	function goNextStatus(callback) {
		cancelRaf();
		rafRef.value = wrapperRaf(function() {
			var newStatus = status.value;
			switch (status.value) {
				case "align":
					newStatus = "motion";
					break;
				case "motion":
					newStatus = "stable";
					break;
				default:
			}
			setStatus(newStatus);
			callback === null || callback === void 0 || callback();
		});
	}
	watch(visible, function() {
		setStatus("measure");
	}, {
		immediate: true,
		flush: "post"
	});
	onMounted(function() {
		watch(status, function() {
			switch (status.value) {
				case "measure":
					doMeasure();
					break;
				default:
			}
			if (status.value) rafRef.value = wrapperRaf(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ import_regenerator.default.mark(function _callee() {
				var index, nextStatus;
				return import_regenerator.default.wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							index = StatusQueue.indexOf(status.value);
							nextStatus = StatusQueue[index + 1];
							if (nextStatus && index !== -1) setStatus(nextStatus);
						case 3:
						case "end": return _context.stop();
					}
				}, _callee);
			})));
		}, {
			immediate: true,
			flush: "post"
		});
	});
	onBeforeUnmount(function() {
		destroyRef.value = true;
		cancelRaf();
	});
	return [status, goNextStatus];
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Popup/useStretchStyle.js
var useStretchStyle_default = (function(stretch) {
	var targetSize = ref({
		width: 0,
		height: 0
	});
	function measureStretch(element) {
		targetSize.value = {
			width: element.offsetWidth,
			height: element.offsetHeight
		};
	}
	return [computed(function() {
		var sizeStyle = {};
		if (stretch.value) {
			var _targetSize$value = targetSize.value, width = _targetSize$value.width, height = _targetSize$value.height;
			if (stretch.value.indexOf("height") !== -1 && height) sizeStyle.height = "".concat(height, "px");
			else if (stretch.value.indexOf("minHeight") !== -1 && height) sizeStyle.minHeight = "".concat(height, "px");
			if (stretch.value.indexOf("width") !== -1 && width) sizeStyle.width = "".concat(width, "px");
			else if (stretch.value.indexOf("minWidth") !== -1 && width) sizeStyle.minWidth = "".concat(width, "px");
		}
		return sizeStyle;
	}), measureStretch];
});

//#endregion
//#region node_modules/dom-align/dist-web/index.js
function ownKeys(object, enumerableOnly) {
	var keys$1 = Object.keys(object);
	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object);
		enumerableOnly && (symbols = symbols.filter(function(sym) {
			return Object.getOwnPropertyDescriptor(object, sym).enumerable;
		})), keys$1.push.apply(keys$1, symbols);
	}
	return keys$1;
}
function _objectSpread2$1(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = null != arguments[i] ? arguments[i] : {};
		i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
			_defineProperty$1(target, key, source[key]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
			Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
		});
	}
	return target;
}
function _typeof$1(obj) {
	"@babel/helpers - typeof";
	return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj$1) {
		return typeof obj$1;
	} : function(obj$1) {
		return obj$1 && "function" == typeof Symbol && obj$1.constructor === Symbol && obj$1 !== Symbol.prototype ? "symbol" : typeof obj$1;
	}, _typeof$1(obj);
}
function _defineProperty$1(obj, key, value) {
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
var vendorPrefix;
var jsCssMap = {
	Webkit: "-webkit-",
	Moz: "-moz-",
	ms: "-ms-",
	O: "-o-"
};
function getVendorPrefix() {
	if (vendorPrefix !== void 0) return vendorPrefix;
	vendorPrefix = "";
	var style = document.createElement("p").style;
	var testProp = "Transform";
	for (var key in jsCssMap) if (key + testProp in style) vendorPrefix = key;
	return vendorPrefix;
}
function getTransitionName() {
	return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
	return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node, value) {
	var name = getTransitionName();
	if (name) {
		node.style[name] = value;
		if (name !== "transitionProperty") node.style.transitionProperty = value;
	}
}
function setTransform(node, value) {
	var name = getTransformName();
	if (name) {
		node.style[name] = value;
		if (name !== "transform") node.style.transform = value;
	}
}
function getTransitionProperty(node) {
	return node.style.transitionProperty || node.style[getTransitionName()];
}
function getTransformXY(node) {
	var style = window.getComputedStyle(node, null);
	var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
	if (transform && transform !== "none") {
		var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
		return {
			x: parseFloat(matrix[12] || matrix[4], 0),
			y: parseFloat(matrix[13] || matrix[5], 0)
		};
	}
	return {
		x: 0,
		y: 0
	};
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
	var style = window.getComputedStyle(node, null);
	var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
	if (transform && transform !== "none") {
		var arr;
		var match2d = transform.match(matrix2d);
		if (match2d) {
			match2d = match2d[1];
			arr = match2d.split(",").map(function(item) {
				return parseFloat(item, 10);
			});
			arr[4] = xy.x;
			arr[5] = xy.y;
			setTransform(node, "matrix(".concat(arr.join(","), ")"));
		} else {
			arr = transform.match(matrix3d)[1].split(",").map(function(item) {
				return parseFloat(item, 10);
			});
			arr[12] = xy.x;
			arr[13] = xy.y;
			setTransform(node, "matrix3d(".concat(arr.join(","), ")"));
		}
	} else setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
	var originalStyle = elem.style.display;
	elem.style.display = "none";
	elem.offsetHeight;
	elem.style.display = originalStyle;
}
function css(el, name, v) {
	var value = v;
	if (_typeof$1(name) === "object") {
		for (var i in name) if (name.hasOwnProperty(i)) css(el, i, name[i]);
		return;
	}
	if (typeof value !== "undefined") {
		if (typeof value === "number") value = "".concat(value, "px");
		el.style[name] = value;
		return;
	}
	return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
	var box;
	var x;
	var y;
	var doc = elem.ownerDocument;
	var body = doc.body;
	var docElem = doc && doc.documentElement;
	box = elem.getBoundingClientRect();
	x = Math.floor(box.left);
	y = Math.floor(box.top);
	x -= docElem.clientLeft || body.clientLeft || 0;
	y -= docElem.clientTop || body.clientTop || 0;
	return {
		left: x,
		top: y
	};
}
function getScroll(w, top) {
	var ret = w["page".concat(top ? "Y" : "X", "Offset")];
	var method = "scroll".concat(top ? "Top" : "Left");
	if (typeof ret !== "number") {
		var d = w.document;
		ret = d.documentElement[method];
		if (typeof ret !== "number") ret = d.body[method];
	}
	return ret;
}
function getScrollLeft(w) {
	return getScroll(w);
}
function getScrollTop(w) {
	return getScroll(w, true);
}
function getOffset(el) {
	var pos = getClientPosition(el);
	var doc = el.ownerDocument;
	var w = doc.defaultView || doc.parentWindow;
	pos.left += getScrollLeft(w);
	pos.top += getScrollTop(w);
	return pos;
}
/**
* A crude way of determining if an object is a window
* @member util
*/
function isWindow(obj) {
	return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node) {
	if (isWindow(node)) return node.document;
	if (node.nodeType === 9) return node;
	return node.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
	var computedStyle = cs;
	var val = "";
	var d = getDocument(elem);
	computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);
	if (computedStyle) val = computedStyle.getPropertyValue(name) || computedStyle[name];
	return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT = "left";
var PX = "px";
function _getComputedStyleIE(elem, name) {
	var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
	if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
		var style = elem.style;
		var left = style[LEFT];
		var rsLeft = elem[RUNTIME_STYLE][LEFT];
		elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
		style[LEFT] = name === "fontSize" ? "1em" : ret || 0;
		ret = style.pixelLeft + PX;
		style[LEFT] = left;
		elem[RUNTIME_STYLE][LEFT] = rsLeft;
	}
	return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
function getOffsetDirection(dir, option) {
	if (dir === "left") return option.useCssRight ? "right" : dir;
	return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
	if (dir === "left") return "right";
	else if (dir === "right") return "left";
	else if (dir === "top") return "bottom";
	else if (dir === "bottom") return "top";
}
function setLeftTop(elem, offset, option) {
	if (css(elem, "position") === "static") elem.style.position = "relative";
	var presetH = -999;
	var presetV = -999;
	var horizontalProperty = getOffsetDirection("left", option);
	var verticalProperty = getOffsetDirection("top", option);
	var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
	var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
	if (horizontalProperty !== "left") presetH = 999;
	if (verticalProperty !== "top") presetV = 999;
	var originalTransition = "";
	var originalOffset = getOffset(elem);
	if ("left" in offset || "top" in offset) {
		originalTransition = getTransitionProperty(elem) || "";
		setTransitionProperty(elem, "none");
	}
	if ("left" in offset) {
		elem.style[oppositeHorizontalProperty] = "";
		elem.style[horizontalProperty] = "".concat(presetH, "px");
	}
	if ("top" in offset) {
		elem.style[oppositeVerticalProperty] = "";
		elem.style[verticalProperty] = "".concat(presetV, "px");
	}
	forceRelayout(elem);
	var old = getOffset(elem);
	var originalStyle = {};
	for (var key in offset) if (offset.hasOwnProperty(key)) {
		var dir = getOffsetDirection(key, option);
		var preset = key === "left" ? presetH : presetV;
		var off = originalOffset[key] - old[key];
		if (dir === key) originalStyle[dir] = preset + off;
		else originalStyle[dir] = preset - off;
	}
	css(elem, originalStyle);
	forceRelayout(elem);
	if ("left" in offset || "top" in offset) setTransitionProperty(elem, originalTransition);
	var ret = {};
	for (var _key in offset) if (offset.hasOwnProperty(_key)) {
		var _dir = getOffsetDirection(_key, option);
		var _off = offset[_key] - originalOffset[_key];
		if (_key === _dir) ret[_dir] = originalStyle[_dir] + _off;
		else ret[_dir] = originalStyle[_dir] - _off;
	}
	css(elem, ret);
}
function setTransform$1(elem, offset) {
	var originalOffset = getOffset(elem);
	var originalXY = getTransformXY(elem);
	var resultXY = {
		x: originalXY.x,
		y: originalXY.y
	};
	if ("left" in offset) resultXY.x = originalXY.x + offset.left - originalOffset.left;
	if ("top" in offset) resultXY.y = originalXY.y + offset.top - originalOffset.top;
	setTransformXY(elem, resultXY);
}
function setOffset(elem, offset, option) {
	if (option.ignoreShake) {
		var oriOffset = getOffset(elem);
		var oLeft = oriOffset.left.toFixed(0);
		var oTop = oriOffset.top.toFixed(0);
		var tLeft = offset.left.toFixed(0);
		var tTop = offset.top.toFixed(0);
		if (oLeft === tLeft && oTop === tTop) return;
	}
	if (option.useCssRight || option.useCssBottom) setLeftTop(elem, offset, option);
	else if (option.useCssTransform && getTransformName() in document.body.style) setTransform$1(elem, offset);
	else setLeftTop(elem, offset, option);
}
function each(arr, fn) {
	for (var i = 0; i < arr.length; i++) fn(arr[i]);
}
function isBorderBoxFn(elem) {
	return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = [
	"margin",
	"border",
	"padding"
];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
	var old = {};
	var style = elem.style;
	var name;
	for (name in options) if (options.hasOwnProperty(name)) {
		old[name] = style[name];
		style[name] = options[name];
	}
	callback.call(elem);
	for (name in options) if (options.hasOwnProperty(name)) style[name] = old[name];
}
function getPBMWidth(elem, props, which) {
	var value = 0;
	var prop;
	var j;
	var i;
	for (j = 0; j < props.length; j++) {
		prop = props[j];
		if (prop) for (i = 0; i < which.length; i++) {
			var cssProp = void 0;
			if (prop === "border") cssProp = "".concat(prop).concat(which[i], "Width");
			else cssProp = prop + which[i];
			value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
		}
	}
	return value;
}
var domUtils = { getParent: function getParent$2(element) {
	var parent = element;
	do
		if (parent.nodeType === 11 && parent.host) parent = parent.host;
		else parent = parent.parentNode;
	while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
	return parent;
} };
each(["Width", "Height"], function(name) {
	domUtils["doc".concat(name)] = function(refWin) {
		var d = refWin.document;
		return Math.max(d.documentElement["scroll".concat(name)], d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
	};
	domUtils["viewport".concat(name)] = function(win) {
		var prop = "client".concat(name);
		var doc = win.document;
		var body = doc.body;
		var documentElementProp = doc.documentElement[prop];
		return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
	};
});
function getWH(elem, name, ex) {
	var extra = ex;
	if (isWindow(elem)) return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
	else if (elem.nodeType === 9) return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
	var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
	var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
	var isBorderBox = isBorderBoxFn(elem);
	var cssBoxValue = 0;
	if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
		borderBoxValue = void 0;
		cssBoxValue = getComputedStyleX(elem, name);
		if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) cssBoxValue = elem.style[name] || 0;
		cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
	}
	if (extra === void 0) extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
	var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
	var val = borderBoxValue || cssBoxValue;
	if (extra === CONTENT_INDEX) {
		if (borderBoxValueOrIsBorderBox) return val - getPBMWidth(elem, ["border", "padding"], which);
		return cssBoxValue;
	} else if (borderBoxValueOrIsBorderBox) {
		if (extra === BORDER_INDEX) return val;
		return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
	}
	return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
	position: "absolute",
	visibility: "hidden",
	display: "block"
};
function getWHIgnoreDisplay() {
	for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) args[_key2] = arguments[_key2];
	var val;
	var elem = args[0];
	if (elem.offsetWidth !== 0) val = getWH.apply(void 0, args);
	else swap(elem, cssShow, function() {
		val = getWH.apply(void 0, args);
	});
	return val;
}
each(["width", "height"], function(name) {
	var first = name.charAt(0).toUpperCase() + name.slice(1);
	domUtils["outer".concat(first)] = function(el, includeMargin) {
		return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
	};
	var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
	domUtils[name] = function(elem, v) {
		var val = v;
		if (val !== void 0) {
			if (elem) {
				if (isBorderBoxFn(elem)) val += getPBMWidth(elem, ["padding", "border"], which);
				return css(elem, name, val);
			}
			return;
		}
		return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
	};
});
function mix(to, from) {
	for (var i in from) if (from.hasOwnProperty(i)) to[i] = from[i];
	return to;
}
var utils = {
	getWindow: function getWindow(node) {
		if (node && node.document && node.setTimeout) return node;
		var doc = node.ownerDocument || node;
		return doc.defaultView || doc.parentWindow;
	},
	getDocument,
	offset: function offset(el, value, option) {
		if (typeof value !== "undefined") setOffset(el, value, option || {});
		else return getOffset(el);
	},
	isWindow,
	each,
	css,
	clone: function clone(obj) {
		var i;
		var ret = {};
		for (i in obj) if (obj.hasOwnProperty(i)) ret[i] = obj[i];
		if (obj.overflow) {
			for (i in obj) if (obj.hasOwnProperty(i)) ret.overflow[i] = obj.overflow[i];
		}
		return ret;
	},
	mix,
	getWindowScrollLeft: function getWindowScrollLeft(w) {
		return getScrollLeft(w);
	},
	getWindowScrollTop: function getWindowScrollTop(w) {
		return getScrollTop(w);
	},
	merge: function merge() {
		var ret = {};
		for (var i = 0; i < arguments.length; i++) utils.mix(ret, i < 0 || arguments.length <= i ? void 0 : arguments[i]);
		return ret;
	},
	viewportWidth: 0,
	viewportHeight: 0
};
mix(utils, domUtils);
/**
* 得到会导致元素显示不全的祖先元素
*/
var getParent = utils.getParent;
function getOffsetParent(element) {
	if (utils.isWindow(element) || element.nodeType === 9) return null;
	var body = utils.getDocument(element).body;
	var parent;
	var positionStyle = utils.css(element, "position");
	if (!(positionStyle === "fixed" || positionStyle === "absolute")) return element.nodeName.toLowerCase() === "html" ? null : getParent(element);
	for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
		positionStyle = utils.css(parent, "position");
		if (positionStyle !== "static") return parent;
	}
	return null;
}
var getParent$1 = utils.getParent;
function isAncestorFixed(element) {
	if (utils.isWindow(element) || element.nodeType === 9) return false;
	var doc = utils.getDocument(element);
	var body = doc.body;
	var parent = null;
	for (parent = getParent$1(element); parent && parent !== body && parent !== doc; parent = getParent$1(parent)) if (utils.css(parent, "position") === "fixed") return true;
	return false;
}
/**
* 获得元素的显示部分的区域
*/
function getVisibleRectForElement(element, alwaysByViewport) {
	var visibleRect = {
		left: 0,
		right: Infinity,
		top: 0,
		bottom: Infinity
	};
	var el = getOffsetParent(element);
	var doc = utils.getDocument(element);
	var win = doc.defaultView || doc.parentWindow;
	var body = doc.body;
	var documentElement = doc.documentElement;
	while (el) {
		if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && el !== body && el !== documentElement && utils.css(el, "overflow") !== "visible") {
			var pos = utils.offset(el);
			pos.left += el.clientLeft;
			pos.top += el.clientTop;
			visibleRect.top = Math.max(visibleRect.top, pos.top);
			visibleRect.right = Math.min(visibleRect.right, pos.left + el.clientWidth);
			visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
			visibleRect.left = Math.max(visibleRect.left, pos.left);
		} else if (el === body || el === documentElement) break;
		el = getOffsetParent(el);
	}
	var originalPosition = null;
	if (!utils.isWindow(element) && element.nodeType !== 9) {
		originalPosition = element.style.position;
		if (utils.css(element, "position") === "absolute") element.style.position = "fixed";
	}
	var scrollX = utils.getWindowScrollLeft(win);
	var scrollY = utils.getWindowScrollTop(win);
	var viewportWidth = utils.viewportWidth(win);
	var viewportHeight = utils.viewportHeight(win);
	var documentWidth = documentElement.scrollWidth;
	var documentHeight = documentElement.scrollHeight;
	var bodyStyle = window.getComputedStyle(body);
	if (bodyStyle.overflowX === "hidden") documentWidth = win.innerWidth;
	if (bodyStyle.overflowY === "hidden") documentHeight = win.innerHeight;
	if (element.style) element.style.position = originalPosition;
	if (alwaysByViewport || isAncestorFixed(element)) {
		visibleRect.left = Math.max(visibleRect.left, scrollX);
		visibleRect.top = Math.max(visibleRect.top, scrollY);
		visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
		visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
	} else {
		var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
		visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
		var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
		visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
	}
	return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
	var pos = utils.clone(elFuturePos);
	var size = {
		width: elRegion.width,
		height: elRegion.height
	};
	if (overflow.adjustX && pos.left < visibleRect.left) pos.left = visibleRect.left;
	if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) size.width -= pos.left + size.width - visibleRect.right;
	if (overflow.adjustX && pos.left + size.width > visibleRect.right) pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
	if (overflow.adjustY && pos.top < visibleRect.top) pos.top = visibleRect.top;
	if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) size.height -= pos.top + size.height - visibleRect.bottom;
	if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
	return utils.mix(pos, size);
}
function getRegion(node) {
	var offset;
	var w;
	var h;
	if (!utils.isWindow(node) && node.nodeType !== 9) {
		offset = utils.offset(node);
		w = utils.outerWidth(node);
		h = utils.outerHeight(node);
	} else {
		var win = utils.getWindow(node);
		offset = {
			left: utils.getWindowScrollLeft(win),
			top: utils.getWindowScrollTop(win)
		};
		w = utils.viewportWidth(win);
		h = utils.viewportHeight(win);
	}
	offset.width = w;
	offset.height = h;
	return offset;
}
/**
* 获取 node 上的 align 对齐点 相对于页面的坐标
*/
function getAlignOffset(region, align) {
	var V = align.charAt(0);
	var H = align.charAt(1);
	var w = region.width;
	var h = region.height;
	var x = region.left;
	var y = region.top;
	if (V === "c") y += h / 2;
	else if (V === "b") y += h;
	if (H === "c") x += w / 2;
	else if (H === "r") x += w;
	return {
		left: x,
		top: y
	};
}
function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset$2) {
	var p1 = getAlignOffset(refNodeRegion, points[1]);
	var p2 = getAlignOffset(elRegion, points[0]);
	var diff = [p2.left - p1.left, p2.top - p1.top];
	return {
		left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset$2[0]),
		top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset$2[1])
	};
}
/**
* align dom node flexibly
* @author yiminghe@gmail.com
*/
function isFailX(elFuturePos, elRegion, visibleRect) {
	return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
	return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
	return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
	return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
	var ret = [];
	utils.each(points, function(p) {
		ret.push(p.replace(reg, function(m) {
			return map[m];
		}));
	});
	return ret;
}
function flipOffset(offset, index) {
	offset[index] = -offset[index];
	return offset;
}
function convertOffset(str, offsetLen) {
	var n;
	if (/%$/.test(str)) n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
	else n = parseInt(str, 10);
	return n || 0;
}
function normalizeOffset(offset, el) {
	offset[0] = convertOffset(offset[0], el.width);
	offset[1] = convertOffset(offset[1], el.height);
}
/**
* @param el
* @param tgtRegion 参照节点所占的区域: { left, top, width, height }
* @param align
*/
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
	var points = align.points;
	var offset = align.offset || [0, 0];
	var targetOffset$2 = align.targetOffset || [0, 0];
	var overflow = align.overflow;
	var source = align.source || el;
	offset = [].concat(offset);
	targetOffset$2 = [].concat(targetOffset$2);
	overflow = overflow || {};
	var newOverflowCfg = {};
	var fail = 0;
	var visibleRect = getVisibleRectForElement(source, !!(overflow && overflow.alwaysByViewport));
	var elRegion = getRegion(source);
	normalizeOffset(offset, elRegion);
	normalizeOffset(targetOffset$2, tgtRegion);
	var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset$2);
	var newElRegion = utils.merge(elRegion, elFuturePos);
	if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
		if (overflow.adjustX) {
			if (isFailX(elFuturePos, elRegion, visibleRect)) {
				var newPoints = flip(points, /[lr]/gi, {
					l: "r",
					r: "l"
				});
				var newOffset = flipOffset(offset, 0);
				var newTargetOffset = flipOffset(targetOffset$2, 0);
				if (!isCompleteFailX(getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset), elRegion, visibleRect)) {
					fail = 1;
					points = newPoints;
					offset = newOffset;
					targetOffset$2 = newTargetOffset;
				}
			}
		}
		if (overflow.adjustY) {
			if (isFailY(elFuturePos, elRegion, visibleRect)) {
				var _newPoints = flip(points, /[tb]/gi, {
					t: "b",
					b: "t"
				});
				var _newOffset = flipOffset(offset, 1);
				var _newTargetOffset = flipOffset(targetOffset$2, 1);
				if (!isCompleteFailY(getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset), elRegion, visibleRect)) {
					fail = 1;
					points = _newPoints;
					offset = _newOffset;
					targetOffset$2 = _newTargetOffset;
				}
			}
		}
		if (fail) {
			elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset$2);
			utils.mix(newElRegion, elFuturePos);
		}
		var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
		var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
		if (isStillFailX || isStillFailY) {
			var _newPoints2 = points;
			if (isStillFailX) _newPoints2 = flip(points, /[lr]/gi, {
				l: "r",
				r: "l"
			});
			if (isStillFailY) _newPoints2 = flip(points, /[tb]/gi, {
				t: "b",
				b: "t"
			});
			points = _newPoints2;
			offset = align.offset || [0, 0];
			targetOffset$2 = align.targetOffset || [0, 0];
		}
		newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
		newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
		if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
	}
	if (newElRegion.width !== elRegion.width) utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width);
	if (newElRegion.height !== elRegion.height) utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height);
	utils.offset(source, {
		left: newElRegion.left,
		top: newElRegion.top
	}, {
		useCssRight: align.useCssRight,
		useCssBottom: align.useCssBottom,
		useCssTransform: align.useCssTransform,
		ignoreShake: align.ignoreShake
	});
	return {
		points,
		offset,
		targetOffset: targetOffset$2,
		overflow: newOverflowCfg
	};
}
/**
*  2012-04-26 yiminghe@gmail.com
*   - 优化智能对齐算法
*   - 慎用 resizeXX
*
*  2011-07-13 yiminghe@gmail.com note:
*   - 增加智能对齐，以及大小调整选项
**/
function isOutOfVisibleRect(target, alwaysByViewport) {
	var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
	var targetRegion = getRegion(target);
	return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
	var target = align.target || refNode;
	return doAlign(el, getRegion(target), align, !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport));
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
/**
* `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
* If client position provided, will internal convert to page position.
*/
function alignPoint(el, tgtPoint, align) {
	var pageX;
	var pageY;
	var doc = utils.getDocument(el);
	var win = doc.defaultView || doc.parentWindow;
	var scrollX = utils.getWindowScrollLeft(win);
	var scrollY = utils.getWindowScrollTop(win);
	var viewportWidth = utils.viewportWidth(win);
	var viewportHeight = utils.viewportHeight(win);
	if ("pageX" in tgtPoint) pageX = tgtPoint.pageX;
	else pageX = scrollX + tgtPoint.clientX;
	if ("pageY" in tgtPoint) pageY = tgtPoint.pageY;
	else pageY = scrollY + tgtPoint.clientY;
	var tgtRegion = {
		left: pageX,
		top: pageY,
		width: 0,
		height: 0
	};
	var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
	var points = [align.points[0], "cc"];
	return doAlign(el, tgtRegion, _objectSpread2$1(_objectSpread2$1({}, align), {}, { points }), pointInView);
}

//#endregion
//#region node_modules/ant-design-vue/es/vc-util/Dom/isVisible.js
var isVisible_default = (function(element) {
	if (!element) return false;
	if (element.offsetParent) return true;
	if (element.getBBox) {
		var box = element.getBBox();
		if (box.width || box.height) return true;
	}
	if (element.getBoundingClientRect) {
		var _box = element.getBoundingClientRect();
		if (_box.width || _box.height) return true;
	}
	return false;
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-align/util.js
function isSamePoint(prev, next) {
	if (prev === next) return true;
	if (!prev || !next) return false;
	if ("pageX" in next && "pageY" in next) return prev.pageX === next.pageX && prev.pageY === next.pageY;
	if ("clientX" in next && "clientY" in next) return prev.clientX === next.clientX && prev.clientY === next.clientY;
	return false;
}
function restoreFocus(activeElement, container) {
	if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === "function") activeElement.focus();
}
function monitorResize(element, callback) {
	var prevWidth = null;
	var prevHeight = null;
	function onResize(_ref) {
		var target = _slicedToArray(_ref, 1)[0].target;
		if (!document.documentElement.contains(target)) return;
		var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
		var fixedWidth = Math.floor(width);
		var fixedHeight = Math.floor(height);
		if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) Promise.resolve().then(function() {
			callback({
				width: fixedWidth,
				height: fixedHeight
			});
		});
		prevWidth = fixedWidth;
		prevHeight = fixedHeight;
	}
	var resizeObserver = new ResizeObserver_es_default(onResize);
	if (element) resizeObserver.observe(element);
	return function() {
		resizeObserver.disconnect();
	};
}

//#endregion
//#region node_modules/ant-design-vue/es/vc-align/hooks/useBuffer.js
var useBuffer_default = (function(callback, buffer) {
	var called = false;
	var timeout = null;
	function cancelTrigger() {
		clearTimeout(timeout);
	}
	function trigger(force) {
		if (!called || force === true) {
			if (callback() === false) return;
			called = true;
			cancelTrigger();
			timeout = setTimeout(function() {
				called = false;
			}, buffer.value);
		} else {
			cancelTrigger();
			timeout = setTimeout(function() {
				called = false;
				trigger();
			}, buffer.value);
		}
	}
	return [trigger, function() {
		called = false;
		cancelTrigger();
	}];
});

//#endregion
//#region node_modules/lodash-es/_listCacheClear.js
/**
* Removes all key-value entries from the list cache.
*
* @private
* @name clear
* @memberOf ListCache
*/
function listCacheClear() {
	this.__data__ = [];
	this.size = 0;
}
var _listCacheClear_default = listCacheClear;

//#endregion
//#region node_modules/lodash-es/eq.js
/**
* Performs a
* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
* comparison between two values to determine if they are equivalent.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to compare.
* @param {*} other The other value to compare.
* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
* @example
*
* var object = { 'a': 1 };
* var other = { 'a': 1 };
*
* _.eq(object, object);
* // => true
*
* _.eq(object, other);
* // => false
*
* _.eq('a', 'a');
* // => true
*
* _.eq('a', Object('a'));
* // => false
*
* _.eq(NaN, NaN);
* // => true
*/
function eq(value, other) {
	return value === other || value !== value && other !== other;
}
var eq_default = eq;

//#endregion
//#region node_modules/lodash-es/_assocIndexOf.js
/**
* Gets the index at which the `key` is found in `array` of key-value pairs.
*
* @private
* @param {Array} array The array to inspect.
* @param {*} key The key to search for.
* @returns {number} Returns the index of the matched value, else `-1`.
*/
function assocIndexOf(array, key) {
	var length = array.length;
	while (length--) if (eq_default(array[length][0], key)) return length;
	return -1;
}
var _assocIndexOf_default = assocIndexOf;

//#endregion
//#region node_modules/lodash-es/_listCacheDelete.js
/** Built-in value references. */
var splice = Array.prototype.splice;
/**
* Removes `key` and its value from the list cache.
*
* @private
* @name delete
* @memberOf ListCache
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function listCacheDelete(key) {
	var data = this.__data__, index = _assocIndexOf_default(data, key);
	if (index < 0) return false;
	if (index == data.length - 1) data.pop();
	else splice.call(data, index, 1);
	--this.size;
	return true;
}
var _listCacheDelete_default = listCacheDelete;

//#endregion
//#region node_modules/lodash-es/_listCacheGet.js
/**
* Gets the list cache value for `key`.
*
* @private
* @name get
* @memberOf ListCache
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function listCacheGet(key) {
	var data = this.__data__, index = _assocIndexOf_default(data, key);
	return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet_default = listCacheGet;

//#endregion
//#region node_modules/lodash-es/_listCacheHas.js
/**
* Checks if a list cache value for `key` exists.
*
* @private
* @name has
* @memberOf ListCache
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function listCacheHas(key) {
	return _assocIndexOf_default(this.__data__, key) > -1;
}
var _listCacheHas_default = listCacheHas;

//#endregion
//#region node_modules/lodash-es/_listCacheSet.js
/**
* Sets the list cache `key` to `value`.
*
* @private
* @name set
* @memberOf ListCache
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the list cache instance.
*/
function listCacheSet(key, value) {
	var data = this.__data__, index = _assocIndexOf_default(data, key);
	if (index < 0) {
		++this.size;
		data.push([key, value]);
	} else data[index][1] = value;
	return this;
}
var _listCacheSet_default = listCacheSet;

//#endregion
//#region node_modules/lodash-es/_ListCache.js
/**
* Creates an list cache object.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function ListCache(entries) {
	var index = -1, length = entries == null ? 0 : entries.length;
	this.clear();
	while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
	}
}
ListCache.prototype.clear = _listCacheClear_default;
ListCache.prototype["delete"] = _listCacheDelete_default;
ListCache.prototype.get = _listCacheGet_default;
ListCache.prototype.has = _listCacheHas_default;
ListCache.prototype.set = _listCacheSet_default;
var _ListCache_default = ListCache;

//#endregion
//#region node_modules/lodash-es/_stackClear.js
/**
* Removes all key-value entries from the stack.
*
* @private
* @name clear
* @memberOf Stack
*/
function stackClear() {
	this.__data__ = new _ListCache_default();
	this.size = 0;
}
var _stackClear_default = stackClear;

//#endregion
//#region node_modules/lodash-es/_stackDelete.js
/**
* Removes `key` and its value from the stack.
*
* @private
* @name delete
* @memberOf Stack
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function stackDelete(key) {
	var data = this.__data__, result = data["delete"](key);
	this.size = data.size;
	return result;
}
var _stackDelete_default = stackDelete;

//#endregion
//#region node_modules/lodash-es/_stackGet.js
/**
* Gets the stack value for `key`.
*
* @private
* @name get
* @memberOf Stack
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function stackGet(key) {
	return this.__data__.get(key);
}
var _stackGet_default = stackGet;

//#endregion
//#region node_modules/lodash-es/_stackHas.js
/**
* Checks if a stack value for `key` exists.
*
* @private
* @name has
* @memberOf Stack
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function stackHas(key) {
	return this.__data__.has(key);
}
var _stackHas_default = stackHas;

//#endregion
//#region node_modules/lodash-es/isFunction.js
/** `Object#toString` result references. */
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
/**
* Checks if `value` is classified as a `Function` object.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a function, else `false`.
* @example
*
* _.isFunction(_);
* // => true
*
* _.isFunction(/abc/);
* // => false
*/
function isFunction(value) {
	if (!isObject_default(value)) return false;
	var tag = _baseGetTag_default(value);
	return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

//#endregion
//#region node_modules/lodash-es/_coreJsData.js
/** Used to detect overreaching core-js shims. */
var coreJsData = _root_default["__core-js_shared__"];
var _coreJsData_default = coreJsData;

//#endregion
//#region node_modules/lodash-es/_isMasked.js
/** Used to detect methods masquerading as native. */
var maskSrcKey = function() {
	var uid = /[^.]+$/.exec(_coreJsData_default && _coreJsData_default.keys && _coreJsData_default.keys.IE_PROTO || "");
	return uid ? "Symbol(src)_1." + uid : "";
}();
/**
* Checks if `func` has its source masked.
*
* @private
* @param {Function} func The function to check.
* @returns {boolean} Returns `true` if `func` is masked, else `false`.
*/
function isMasked(func) {
	return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked_default = isMasked;

//#endregion
//#region node_modules/lodash-es/_toSource.js
/** Used to resolve the decompiled source of functions. */
var funcToString$1 = Function.prototype.toString;
/**
* Converts `func` to its source code.
*
* @private
* @param {Function} func The function to convert.
* @returns {string} Returns the source code.
*/
function toSource(func) {
	if (func != null) {
		try {
			return funcToString$1.call(func);
		} catch (e) {}
		try {
			return func + "";
		} catch (e) {}
	}
	return "";
}
var _toSource_default = toSource;

//#endregion
//#region node_modules/lodash-es/_baseIsNative.js
/**
* Used to match `RegExp`
* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
*/
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */
var funcProto = Function.prototype, objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;
/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/**
* The base implementation of `_.isNative` without bad shim checks.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a native function,
*  else `false`.
*/
function baseIsNative(value) {
	if (!isObject_default(value) || _isMasked_default(value)) return false;
	return (isFunction_default(value) ? reIsNative : reIsHostCtor).test(_toSource_default(value));
}
var _baseIsNative_default = baseIsNative;

//#endregion
//#region node_modules/lodash-es/_getValue.js
/**
* Gets the value at `key` of `object`.
*
* @private
* @param {Object} [object] The object to query.
* @param {string} key The key of the property to get.
* @returns {*} Returns the property value.
*/
function getValue(object, key) {
	return object == null ? void 0 : object[key];
}
var _getValue_default = getValue;

//#endregion
//#region node_modules/lodash-es/_getNative.js
/**
* Gets the native function at `key` of `object`.
*
* @private
* @param {Object} object The object to query.
* @param {string} key The key of the method to get.
* @returns {*} Returns the function if it's native, else `undefined`.
*/
function getNative(object, key) {
	var value = _getValue_default(object, key);
	return _baseIsNative_default(value) ? value : void 0;
}
var _getNative_default = getNative;

//#endregion
//#region node_modules/lodash-es/_Map.js
var Map$1 = _getNative_default(_root_default, "Map");
var _Map_default = Map$1;

//#endregion
//#region node_modules/lodash-es/_nativeCreate.js
var nativeCreate = _getNative_default(Object, "create");
var _nativeCreate_default = nativeCreate;

//#endregion
//#region node_modules/lodash-es/_hashClear.js
/**
* Removes all key-value entries from the hash.
*
* @private
* @name clear
* @memberOf Hash
*/
function hashClear() {
	this.__data__ = _nativeCreate_default ? _nativeCreate_default(null) : {};
	this.size = 0;
}
var _hashClear_default = hashClear;

//#endregion
//#region node_modules/lodash-es/_hashDelete.js
/**
* Removes `key` and its value from the hash.
*
* @private
* @name delete
* @memberOf Hash
* @param {Object} hash The hash to modify.
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function hashDelete(key) {
	var result = this.has(key) && delete this.__data__[key];
	this.size -= result ? 1 : 0;
	return result;
}
var _hashDelete_default = hashDelete;

//#endregion
//#region node_modules/lodash-es/_hashGet.js
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
/** Used to check objects for own properties. */
var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
/**
* Gets the hash value for `key`.
*
* @private
* @name get
* @memberOf Hash
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function hashGet(key) {
	var data = this.__data__;
	if (_nativeCreate_default) {
		var result = data[key];
		return result === HASH_UNDEFINED$2 ? void 0 : result;
	}
	return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
}
var _hashGet_default = hashGet;

//#endregion
//#region node_modules/lodash-es/_hashHas.js
/** Used to check objects for own properties. */
var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
/**
* Checks if a hash value for `key` exists.
*
* @private
* @name has
* @memberOf Hash
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function hashHas(key) {
	var data = this.__data__;
	return _nativeCreate_default ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
var _hashHas_default = hashHas;

//#endregion
//#region node_modules/lodash-es/_hashSet.js
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
/**
* Sets the hash `key` to `value`.
*
* @private
* @name set
* @memberOf Hash
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the hash instance.
*/
function hashSet(key, value) {
	var data = this.__data__;
	this.size += this.has(key) ? 0 : 1;
	data[key] = _nativeCreate_default && value === void 0 ? HASH_UNDEFINED$1 : value;
	return this;
}
var _hashSet_default = hashSet;

//#endregion
//#region node_modules/lodash-es/_Hash.js
/**
* Creates a hash object.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function Hash(entries) {
	var index = -1, length = entries == null ? 0 : entries.length;
	this.clear();
	while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
	}
}
Hash.prototype.clear = _hashClear_default;
Hash.prototype["delete"] = _hashDelete_default;
Hash.prototype.get = _hashGet_default;
Hash.prototype.has = _hashHas_default;
Hash.prototype.set = _hashSet_default;
var _Hash_default = Hash;

//#endregion
//#region node_modules/lodash-es/_mapCacheClear.js
/**
* Removes all key-value entries from the map.
*
* @private
* @name clear
* @memberOf MapCache
*/
function mapCacheClear() {
	this.size = 0;
	this.__data__ = {
		"hash": new _Hash_default(),
		"map": new (_Map_default || _ListCache_default)(),
		"string": new _Hash_default()
	};
}
var _mapCacheClear_default = mapCacheClear;

//#endregion
//#region node_modules/lodash-es/_isKeyable.js
/**
* Checks if `value` is suitable for use as unique object key.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is suitable, else `false`.
*/
function isKeyable(value) {
	var type = typeof value;
	return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable_default = isKeyable;

//#endregion
//#region node_modules/lodash-es/_getMapData.js
/**
* Gets the data for `map`.
*
* @private
* @param {Object} map The map to query.
* @param {string} key The reference key.
* @returns {*} Returns the map data.
*/
function getMapData(map, key) {
	var data = map.__data__;
	return _isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData_default = getMapData;

//#endregion
//#region node_modules/lodash-es/_mapCacheDelete.js
/**
* Removes `key` and its value from the map.
*
* @private
* @name delete
* @memberOf MapCache
* @param {string} key The key of the value to remove.
* @returns {boolean} Returns `true` if the entry was removed, else `false`.
*/
function mapCacheDelete(key) {
	var result = _getMapData_default(this, key)["delete"](key);
	this.size -= result ? 1 : 0;
	return result;
}
var _mapCacheDelete_default = mapCacheDelete;

//#endregion
//#region node_modules/lodash-es/_mapCacheGet.js
/**
* Gets the map value for `key`.
*
* @private
* @name get
* @memberOf MapCache
* @param {string} key The key of the value to get.
* @returns {*} Returns the entry value.
*/
function mapCacheGet(key) {
	return _getMapData_default(this, key).get(key);
}
var _mapCacheGet_default = mapCacheGet;

//#endregion
//#region node_modules/lodash-es/_mapCacheHas.js
/**
* Checks if a map value for `key` exists.
*
* @private
* @name has
* @memberOf MapCache
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function mapCacheHas(key) {
	return _getMapData_default(this, key).has(key);
}
var _mapCacheHas_default = mapCacheHas;

//#endregion
//#region node_modules/lodash-es/_mapCacheSet.js
/**
* Sets the map `key` to `value`.
*
* @private
* @name set
* @memberOf MapCache
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the map cache instance.
*/
function mapCacheSet(key, value) {
	var data = _getMapData_default(this, key), size = data.size;
	data.set(key, value);
	this.size += data.size == size ? 0 : 1;
	return this;
}
var _mapCacheSet_default = mapCacheSet;

//#endregion
//#region node_modules/lodash-es/_MapCache.js
/**
* Creates a map cache object to store key-value pairs.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function MapCache(entries) {
	var index = -1, length = entries == null ? 0 : entries.length;
	this.clear();
	while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
	}
}
MapCache.prototype.clear = _mapCacheClear_default;
MapCache.prototype["delete"] = _mapCacheDelete_default;
MapCache.prototype.get = _mapCacheGet_default;
MapCache.prototype.has = _mapCacheHas_default;
MapCache.prototype.set = _mapCacheSet_default;
var _MapCache_default = MapCache;

//#endregion
//#region node_modules/lodash-es/_stackSet.js
/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;
/**
* Sets the stack `key` to `value`.
*
* @private
* @name set
* @memberOf Stack
* @param {string} key The key of the value to set.
* @param {*} value The value to set.
* @returns {Object} Returns the stack cache instance.
*/
function stackSet(key, value) {
	var data = this.__data__;
	if (data instanceof _ListCache_default) {
		var pairs = data.__data__;
		if (!_Map_default || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
			pairs.push([key, value]);
			this.size = ++data.size;
			return this;
		}
		data = this.__data__ = new _MapCache_default(pairs);
	}
	data.set(key, value);
	this.size = data.size;
	return this;
}
var _stackSet_default = stackSet;

//#endregion
//#region node_modules/lodash-es/_Stack.js
/**
* Creates a stack cache object to store key-value pairs.
*
* @private
* @constructor
* @param {Array} [entries] The key-value pairs to cache.
*/
function Stack(entries) {
	this.size = (this.__data__ = new _ListCache_default(entries)).size;
}
Stack.prototype.clear = _stackClear_default;
Stack.prototype["delete"] = _stackDelete_default;
Stack.prototype.get = _stackGet_default;
Stack.prototype.has = _stackHas_default;
Stack.prototype.set = _stackSet_default;
var _Stack_default = Stack;

//#endregion
//#region node_modules/lodash-es/_setCacheAdd.js
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = "__lodash_hash_undefined__";
/**
* Adds `value` to the array cache.
*
* @private
* @name add
* @memberOf SetCache
* @alias push
* @param {*} value The value to cache.
* @returns {Object} Returns the cache instance.
*/
function setCacheAdd(value) {
	this.__data__.set(value, HASH_UNDEFINED);
	return this;
}
var _setCacheAdd_default = setCacheAdd;

//#endregion
//#region node_modules/lodash-es/_setCacheHas.js
/**
* Checks if `value` is in the array cache.
*
* @private
* @name has
* @memberOf SetCache
* @param {*} value The value to search for.
* @returns {number} Returns `true` if `value` is found, else `false`.
*/
function setCacheHas(value) {
	return this.__data__.has(value);
}
var _setCacheHas_default = setCacheHas;

//#endregion
//#region node_modules/lodash-es/_SetCache.js
/**
*
* Creates an array cache object to store unique values.
*
* @private
* @constructor
* @param {Array} [values] The values to cache.
*/
function SetCache(values) {
	var index = -1, length = values == null ? 0 : values.length;
	this.__data__ = new _MapCache_default();
	while (++index < length) this.add(values[index]);
}
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd_default;
SetCache.prototype.has = _setCacheHas_default;
var _SetCache_default = SetCache;

//#endregion
//#region node_modules/lodash-es/_arraySome.js
/**
* A specialized version of `_.some` for arrays without support for iteratee
* shorthands.
*
* @private
* @param {Array} [array] The array to iterate over.
* @param {Function} predicate The function invoked per iteration.
* @returns {boolean} Returns `true` if any element passes the predicate check,
*  else `false`.
*/
function arraySome(array, predicate) {
	var index = -1, length = array == null ? 0 : array.length;
	while (++index < length) if (predicate(array[index], index, array)) return true;
	return false;
}
var _arraySome_default = arraySome;

//#endregion
//#region node_modules/lodash-es/_cacheHas.js
/**
* Checks if a `cache` value for `key` exists.
*
* @private
* @param {Object} cache The cache to query.
* @param {string} key The key of the entry to check.
* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
*/
function cacheHas(cache, key) {
	return cache.has(key);
}
var _cacheHas_default = cacheHas;

//#endregion
//#region node_modules/lodash-es/_equalArrays.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
/**
* A specialized version of `baseIsEqualDeep` for arrays with support for
* partial deep comparisons.
*
* @private
* @param {Array} array The array to compare.
* @param {Array} other The other array to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} stack Tracks traversed `array` and `other` objects.
* @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
*/
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
	if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
	var arrStacked = stack.get(array);
	var othStacked = stack.get(other);
	if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
	var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new _SetCache_default() : void 0;
	stack.set(array, other);
	stack.set(other, array);
	while (++index < arrLength) {
		var arrValue = array[index], othValue = other[index];
		if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
		if (compared !== void 0) {
			if (compared) continue;
			result = false;
			break;
		}
		if (seen) {
			if (!_arraySome_default(other, function(othValue$1, othIndex) {
				if (!_cacheHas_default(seen, othIndex) && (arrValue === othValue$1 || equalFunc(arrValue, othValue$1, bitmask, customizer, stack))) return seen.push(othIndex);
			})) {
				result = false;
				break;
			}
		} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
			result = false;
			break;
		}
	}
	stack["delete"](array);
	stack["delete"](other);
	return result;
}
var _equalArrays_default = equalArrays;

//#endregion
//#region node_modules/lodash-es/_Uint8Array.js
/** Built-in value references. */
var Uint8Array = _root_default.Uint8Array;
var _Uint8Array_default = Uint8Array;

//#endregion
//#region node_modules/lodash-es/_mapToArray.js
/**
* Converts `map` to its key-value pairs.
*
* @private
* @param {Object} map The map to convert.
* @returns {Array} Returns the key-value pairs.
*/
function mapToArray(map) {
	var index = -1, result = Array(map.size);
	map.forEach(function(value, key) {
		result[++index] = [key, value];
	});
	return result;
}
var _mapToArray_default = mapToArray;

//#endregion
//#region node_modules/lodash-es/_setToArray.js
/**
* Converts `set` to an array of its values.
*
* @private
* @param {Object} set The set to convert.
* @returns {Array} Returns the values.
*/
function setToArray(set) {
	var index = -1, result = Array(set.size);
	set.forEach(function(value) {
		result[++index] = value;
	});
	return result;
}
var _setToArray_default = setToArray;

//#endregion
//#region node_modules/lodash-es/_equalByTag.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol_default ? _Symbol_default.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
/**
* A specialized version of `baseIsEqualDeep` for comparing objects of
* the same `toStringTag`.
*
* **Note:** This function only supports comparing values with tags of
* `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
*
* @private
* @param {Object} object The object to compare.
* @param {Object} other The other object to compare.
* @param {string} tag The `toStringTag` of the objects to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} stack Tracks traversed `object` and `other` objects.
* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
*/
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	switch (tag) {
		case dataViewTag$2:
			if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
			object = object.buffer;
			other = other.buffer;
		case arrayBufferTag$1:
			if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array_default(object), new _Uint8Array_default(other))) return false;
			return true;
		case boolTag$1:
		case dateTag$1:
		case numberTag$1: return eq_default(+object, +other);
		case errorTag$1: return object.name == other.name && object.message == other.message;
		case regexpTag$1:
		case stringTag$1: return object == other + "";
		case mapTag$2: var convert = _mapToArray_default;
		case setTag$2:
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
			convert || (convert = _setToArray_default);
			if (object.size != other.size && !isPartial) return false;
			var stacked = stack.get(object);
			if (stacked) return stacked == other;
			bitmask |= COMPARE_UNORDERED_FLAG;
			stack.set(object, other);
			var result = _equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
			stack["delete"](object);
			return result;
		case symbolTag: if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
	}
	return false;
}
var _equalByTag_default = equalByTag;

//#endregion
//#region node_modules/lodash-es/_arrayPush.js
/**
* Appends the elements of `values` to `array`.
*
* @private
* @param {Array} array The array to modify.
* @param {Array} values The values to append.
* @returns {Array} Returns `array`.
*/
function arrayPush(array, values) {
	var index = -1, length = values.length, offset = array.length;
	while (++index < length) array[offset + index] = values[index];
	return array;
}
var _arrayPush_default = arrayPush;

//#endregion
//#region node_modules/lodash-es/isArray.js
/**
* Checks if `value` is classified as an `Array` object.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an array, else `false`.
* @example
*
* _.isArray([1, 2, 3]);
* // => true
*
* _.isArray(document.body.children);
* // => false
*
* _.isArray('abc');
* // => false
*
* _.isArray(_.noop);
* // => false
*/
var isArray = Array.isArray;
var isArray_default = isArray;

//#endregion
//#region node_modules/lodash-es/_baseGetAllKeys.js
/**
* The base implementation of `getAllKeys` and `getAllKeysIn` which uses
* `keysFunc` and `symbolsFunc` to get the enumerable property names and
* symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @param {Function} keysFunc The function to get the keys of `object`.
* @param {Function} symbolsFunc The function to get the symbols of `object`.
* @returns {Array} Returns the array of property names and symbols.
*/
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	var result = keysFunc(object);
	return isArray_default(object) ? result : _arrayPush_default(result, symbolsFunc(object));
}
var _baseGetAllKeys_default = baseGetAllKeys;

//#endregion
//#region node_modules/lodash-es/_arrayFilter.js
/**
* A specialized version of `_.filter` for arrays without support for
* iteratee shorthands.
*
* @private
* @param {Array} [array] The array to iterate over.
* @param {Function} predicate The function invoked per iteration.
* @returns {Array} Returns the new filtered array.
*/
function arrayFilter(array, predicate) {
	var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
	while (++index < length) {
		var value = array[index];
		if (predicate(value, index, array)) result[resIndex++] = value;
	}
	return result;
}
var _arrayFilter_default = arrayFilter;

//#endregion
//#region node_modules/lodash-es/stubArray.js
/**
* This method returns a new empty array.
*
* @static
* @memberOf _
* @since 4.13.0
* @category Util
* @returns {Array} Returns the new empty array.
* @example
*
* var arrays = _.times(2, _.stubArray);
*
* console.log(arrays);
* // => [[], []]
*
* console.log(arrays[0] === arrays[1]);
* // => false
*/
function stubArray() {
	return [];
}
var stubArray_default = stubArray;

//#endregion
//#region node_modules/lodash-es/_getSymbols.js
/** Built-in value references. */
var propertyIsEnumerable$1 = Object.prototype.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
* Creates an array of the own enumerable symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of symbols.
*/
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
	if (object == null) return [];
	object = Object(object);
	return _arrayFilter_default(nativeGetSymbols(object), function(symbol) {
		return propertyIsEnumerable$1.call(object, symbol);
	});
};
var _getSymbols_default = getSymbols;

//#endregion
//#region node_modules/lodash-es/_baseTimes.js
/**
* The base implementation of `_.times` without support for iteratee shorthands
* or max array length checks.
*
* @private
* @param {number} n The number of times to invoke `iteratee`.
* @param {Function} iteratee The function invoked per iteration.
* @returns {Array} Returns the array of results.
*/
function baseTimes(n, iteratee) {
	var index = -1, result = Array(n);
	while (++index < n) result[index] = iteratee(index);
	return result;
}
var _baseTimes_default = baseTimes;

//#endregion
//#region node_modules/lodash-es/_baseIsArguments.js
/** `Object#toString` result references. */
var argsTag$2 = "[object Arguments]";
/**
* The base implementation of `_.isArguments`.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an `arguments` object,
*/
function baseIsArguments(value) {
	return isObjectLike_default(value) && _baseGetTag_default(value) == argsTag$2;
}
var _baseIsArguments_default = baseIsArguments;

//#endregion
//#region node_modules/lodash-es/isArguments.js
/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$1.hasOwnProperty;
/** Built-in value references. */
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
/**
* Checks if `value` is likely an `arguments` object.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an `arguments` object,
*  else `false`.
* @example
*
* _.isArguments(function() { return arguments; }());
* // => true
*
* _.isArguments([1, 2, 3]);
* // => false
*/
var isArguments = _baseIsArguments_default(function() {
	return arguments;
}()) ? _baseIsArguments_default : function(value) {
	return isObjectLike_default(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

//#endregion
//#region node_modules/lodash-es/stubFalse.js
/**
* This method returns `false`.
*
* @static
* @memberOf _
* @since 4.13.0
* @category Util
* @returns {boolean} Returns `false`.
* @example
*
* _.times(2, _.stubFalse);
* // => [false, false]
*/
function stubFalse() {
	return false;
}
var stubFalse_default = stubFalse;

//#endregion
//#region node_modules/lodash-es/isBuffer.js
/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
/** Built-in value references. */
var Buffer = freeModule$1 && freeModule$1.exports === freeExports$1 ? _root_default.Buffer : void 0;
/**
* Checks if `value` is a buffer.
*
* @static
* @memberOf _
* @since 4.3.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
* @example
*
* _.isBuffer(new Buffer(2));
* // => true
*
* _.isBuffer(new Uint8Array(2));
* // => false
*/
var isBuffer = (Buffer ? Buffer.isBuffer : void 0) || stubFalse_default;
var isBuffer_default = isBuffer;

//#endregion
//#region node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
* Checks if `value` is a valid array-like index.
*
* @private
* @param {*} value The value to check.
* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
*/
function isIndex(value, length) {
	var type = typeof value;
	length = length == null ? MAX_SAFE_INTEGER$1 : length;
	return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var _isIndex_default = isIndex;

//#endregion
//#region node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
* Checks if `value` is a valid array-like length.
*
* **Note:** This method is loosely based on
* [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
* @example
*
* _.isLength(3);
* // => true
*
* _.isLength(Number.MIN_VALUE);
* // => false
*
* _.isLength(Infinity);
* // => false
*
* _.isLength('3');
* // => false
*/
function isLength(value) {
	return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_default = isLength;

//#endregion
//#region node_modules/lodash-es/_baseIsTypedArray.js
/** `Object#toString` result references. */
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
/**
* The base implementation of `_.isTypedArray` without Node.js optimizations.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
*/
function baseIsTypedArray(value) {
	return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[_baseGetTag_default(value)];
}
var _baseIsTypedArray_default = baseIsTypedArray;

//#endregion
//#region node_modules/lodash-es/_baseUnary.js
/**
* The base implementation of `_.unary` without support for storing metadata.
*
* @private
* @param {Function} func The function to cap arguments for.
* @returns {Function} Returns the new capped function.
*/
function baseUnary(func) {
	return function(value) {
		return func(value);
	};
}
var _baseUnary_default = baseUnary;

//#endregion
//#region node_modules/lodash-es/_nodeUtil.js
/** Detect free variable `exports`. */
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
/** Detect free variable `process` from Node.js. */
var freeProcess = freeModule && freeModule.exports === freeExports && _freeGlobal_default.process;
/** Used to access faster Node.js helpers. */
var nodeUtil = function() {
	try {
		var types = freeModule && freeModule.require && freeModule.require("util").types;
		if (types) return types;
		return freeProcess && freeProcess.binding && freeProcess.binding("util");
	} catch (e) {}
}();
var _nodeUtil_default = nodeUtil;

//#endregion
//#region node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = _nodeUtil_default && _nodeUtil_default.isTypedArray;
/**
* Checks if `value` is classified as a typed array.
*
* @static
* @memberOf _
* @since 3.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
* @example
*
* _.isTypedArray(new Uint8Array);
* // => true
*
* _.isTypedArray([]);
* // => false
*/
var isTypedArray = nodeIsTypedArray ? _baseUnary_default(nodeIsTypedArray) : _baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

//#endregion
//#region node_modules/lodash-es/_arrayLikeKeys.js
/** Used to check objects for own properties. */
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
/**
* Creates an array of the enumerable property names of the array-like `value`.
*
* @private
* @param {*} value The value to query.
* @param {boolean} inherited Specify returning inherited property names.
* @returns {Array} Returns the array of property names.
*/
function arrayLikeKeys(value, inherited) {
	var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes_default(value.length, String) : [], length = result.length;
	for (var key in value) if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || _isIndex_default(key, length)))) result.push(key);
	return result;
}
var _arrayLikeKeys_default = arrayLikeKeys;

//#endregion
//#region node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
* Checks if `value` is likely a prototype object.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
*/
function isPrototype(value) {
	var Ctor = value && value.constructor;
	return value === (typeof Ctor == "function" && Ctor.prototype || objectProto);
}
var _isPrototype_default = isPrototype;

//#endregion
//#region node_modules/lodash-es/_nativeKeys.js
var nativeKeys = _overArg_default(Object.keys, Object);
var _nativeKeys_default = nativeKeys;

//#endregion
//#region node_modules/lodash-es/_baseKeys.js
/** Used to check objects for own properties. */
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
/**
* The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names.
*/
function baseKeys(object) {
	if (!_isPrototype_default(object)) return _nativeKeys_default(object);
	var result = [];
	for (var key in Object(object)) if (hasOwnProperty$2.call(object, key) && key != "constructor") result.push(key);
	return result;
}
var _baseKeys_default = baseKeys;

//#endregion
//#region node_modules/lodash-es/isArrayLike.js
/**
* Checks if `value` is array-like. A value is considered array-like if it's
* not a function and has a `value.length` that's an integer greater than or
* equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is array-like, else `false`.
* @example
*
* _.isArrayLike([1, 2, 3]);
* // => true
*
* _.isArrayLike(document.body.children);
* // => true
*
* _.isArrayLike('abc');
* // => true
*
* _.isArrayLike(_.noop);
* // => false
*/
function isArrayLike(value) {
	return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

//#endregion
//#region node_modules/lodash-es/keys.js
/**
* Creates an array of the own enumerable property names of `object`.
*
* **Note:** Non-object values are coerced to objects. See the
* [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
* for more details.
*
* @static
* @since 0.1.0
* @memberOf _
* @category Object
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names.
* @example
*
* function Foo() {
*   this.a = 1;
*   this.b = 2;
* }
*
* Foo.prototype.c = 3;
*
* _.keys(new Foo);
* // => ['a', 'b'] (iteration order is not guaranteed)
*
* _.keys('hi');
* // => ['0', '1']
*/
function keys(object) {
	return isArrayLike_default(object) ? _arrayLikeKeys_default(object) : _baseKeys_default(object);
}
var keys_default = keys;

//#endregion
//#region node_modules/lodash-es/_getAllKeys.js
/**
* Creates an array of own enumerable property names and symbols of `object`.
*
* @private
* @param {Object} object The object to query.
* @returns {Array} Returns the array of property names and symbols.
*/
function getAllKeys(object) {
	return _baseGetAllKeys_default(object, keys_default, _getSymbols_default);
}
var _getAllKeys_default = getAllKeys;

//#endregion
//#region node_modules/lodash-es/_equalObjects.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1;
/** Used to check objects for own properties. */
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
/**
* A specialized version of `baseIsEqualDeep` for objects with support for
* partial deep comparisons.
*
* @private
* @param {Object} object The object to compare.
* @param {Object} other The other object to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} stack Tracks traversed `object` and `other` objects.
* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
*/
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = _getAllKeys_default(object), objLength = objProps.length;
	if (objLength != _getAllKeys_default(other).length && !isPartial) return false;
	var index = objLength;
	while (index--) {
		var key = objProps[index];
		if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) return false;
	}
	var objStacked = stack.get(object);
	var othStacked = stack.get(other);
	if (objStacked && othStacked) return objStacked == other && othStacked == object;
	var result = true;
	stack.set(object, other);
	stack.set(other, object);
	var skipCtor = isPartial;
	while (++index < objLength) {
		key = objProps[index];
		var objValue = object[key], othValue = other[key];
		if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
		if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
			result = false;
			break;
		}
		skipCtor || (skipCtor = key == "constructor");
	}
	if (result && !skipCtor) {
		var objCtor = object.constructor, othCtor = other.constructor;
		if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
	}
	stack["delete"](object);
	stack["delete"](other);
	return result;
}
var _equalObjects_default = equalObjects;

//#endregion
//#region node_modules/lodash-es/_DataView.js
var DataView = _getNative_default(_root_default, "DataView");
var _DataView_default = DataView;

//#endregion
//#region node_modules/lodash-es/_Promise.js
var Promise$1 = _getNative_default(_root_default, "Promise");
var _Promise_default = Promise$1;

//#endregion
//#region node_modules/lodash-es/_Set.js
var Set = _getNative_default(_root_default, "Set");
var _Set_default = Set;

//#endregion
//#region node_modules/lodash-es/_WeakMap.js
var WeakMap = _getNative_default(_root_default, "WeakMap");
var _WeakMap_default = WeakMap;

//#endregion
//#region node_modules/lodash-es/_getTag.js
/** `Object#toString` result references. */
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource_default(_DataView_default), mapCtorString = _toSource_default(_Map_default), promiseCtorString = _toSource_default(_Promise_default), setCtorString = _toSource_default(_Set_default), weakMapCtorString = _toSource_default(_WeakMap_default);
/**
* Gets the `toStringTag` of `value`.
*
* @private
* @param {*} value The value to query.
* @returns {string} Returns the `toStringTag`.
*/
var getTag = _baseGetTag_default;
if (_DataView_default && getTag(new _DataView_default(/* @__PURE__ */ new ArrayBuffer(1))) != dataViewTag || _Map_default && getTag(new _Map_default()) != mapTag || _Promise_default && getTag(_Promise_default.resolve()) != promiseTag || _Set_default && getTag(new _Set_default()) != setTag || _WeakMap_default && getTag(new _WeakMap_default()) != weakMapTag) getTag = function(value) {
	var result = _baseGetTag_default(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? _toSource_default(Ctor) : "";
	if (ctorString) switch (ctorString) {
		case dataViewCtorString: return dataViewTag;
		case mapCtorString: return mapTag;
		case promiseCtorString: return promiseTag;
		case setCtorString: return setTag;
		case weakMapCtorString: return weakMapTag;
	}
	return result;
};
var _getTag_default = getTag;

//#endregion
//#region node_modules/lodash-es/_baseIsEqualDeep.js
/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
/** Used to check objects for own properties. */
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
* A specialized version of `baseIsEqual` for arrays and objects which performs
* deep comparisons and tracks traversed objects enabling objects with circular
* references to be compared.
*
* @private
* @param {Object} object The object to compare.
* @param {Object} other The other object to compare.
* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
* @param {Function} customizer The function to customize comparisons.
* @param {Function} equalFunc The function to determine equivalents of values.
* @param {Object} [stack] Tracks traversed `object` and `other` objects.
* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
*/
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag : _getTag_default(object), othTag = othIsArr ? arrayTag : _getTag_default(other);
	objTag = objTag == argsTag ? objectTag : objTag;
	othTag = othTag == argsTag ? objectTag : othTag;
	var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
	if (isSameTag && isBuffer_default(object)) {
		if (!isBuffer_default(other)) return false;
		objIsArr = true;
		objIsObj = false;
	}
	if (isSameTag && !objIsObj) {
		stack || (stack = new _Stack_default());
		return objIsArr || isTypedArray_default(object) ? _equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
	}
	if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
		if (objIsWrapped || othIsWrapped) {
			var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
			stack || (stack = new _Stack_default());
			return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		}
	}
	if (!isSameTag) return false;
	stack || (stack = new _Stack_default());
	return _equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep_default = baseIsEqualDeep;

//#endregion
//#region node_modules/lodash-es/_baseIsEqual.js
/**
* The base implementation of `_.isEqual` which supports partial comparisons
* and tracks traversed objects.
*
* @private
* @param {*} value The value to compare.
* @param {*} other The other value to compare.
* @param {boolean} bitmask The bitmask flags.
*  1 - Unordered comparison
*  2 - Partial comparison
* @param {Function} [customizer] The function to customize comparisons.
* @param {Object} [stack] Tracks traversed `value` and `other` objects.
* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
*/
function baseIsEqual(value, other, bitmask, customizer, stack) {
	if (value === other) return true;
	if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) return value !== value && other !== other;
	return _baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var _baseIsEqual_default = baseIsEqual;

//#endregion
//#region node_modules/lodash-es/isEqual.js
/**
* Performs a deep comparison between two values to determine if they are
* equivalent.
*
* **Note:** This method supports comparing arrays, array buffers, booleans,
* date objects, error objects, maps, numbers, `Object` objects, regexes,
* sets, strings, symbols, and typed arrays. `Object` objects are compared
* by their own, not inherited, enumerable properties. Functions and DOM
* nodes are compared by strict equality, i.e. `===`.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to compare.
* @param {*} other The other value to compare.
* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
* @example
*
* var object = { 'a': 1 };
* var other = { 'a': 1 };
*
* _.isEqual(object, other);
* // => true
*
* object === other;
* // => false
*/
function isEqual(value, other) {
	return _baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

//#endregion
//#region node_modules/ant-design-vue/es/vc-align/Align.js
var alignProps = {
	align: Object,
	target: [Object, Function],
	onAlign: Function,
	monitorBufferTime: Number,
	monitorWindowResize: Boolean,
	disabled: Boolean
};
function getElement(func) {
	if (typeof func !== "function") return null;
	return func();
}
function getPoint(point) {
	if (_typeof(point) !== "object" || !point) return null;
	return point;
}
var Align_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Align",
	props: alignProps,
	emits: ["align"],
	setup: function setup(props, _ref) {
		var expose = _ref.expose, slots = _ref.slots;
		var cacheRef = ref({});
		var nodeRef = ref();
		var _useBuffer2 = _slicedToArray(useBuffer_default(function() {
			var latestDisabled = props.disabled, latestTarget = props.target, latestAlign = props.align, latestOnAlign = props.onAlign;
			if (!latestDisabled && latestTarget && nodeRef.value) {
				var source = nodeRef.value;
				var result;
				var element = getElement(latestTarget);
				var point = getPoint(latestTarget);
				cacheRef.value.element = element;
				cacheRef.value.point = point;
				cacheRef.value.align = latestAlign;
				var activeElement = document.activeElement;
				if (element && isVisible_default(element)) result = alignElement(source, element, latestAlign);
				else if (point) result = alignPoint(source, point, latestAlign);
				restoreFocus(activeElement, source);
				if (latestOnAlign && result) latestOnAlign(source, result);
				return true;
			}
			return false;
		}, computed(function() {
			return props.monitorBufferTime;
		})), 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
		var resizeMonitor = ref({ cancel: function cancel() {} });
		var sourceResizeMonitor = ref({ cancel: function cancel() {} });
		var goAlign = function goAlign$1() {
			var target = props.target;
			var element = getElement(target);
			var point = getPoint(target);
			if (nodeRef.value !== sourceResizeMonitor.value.element) {
				sourceResizeMonitor.value.cancel();
				sourceResizeMonitor.value.element = nodeRef.value;
				sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, _forceAlign);
			}
			if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual_default(cacheRef.value.align, props.align)) {
				_forceAlign();
				if (resizeMonitor.value.element !== element) {
					resizeMonitor.value.cancel();
					resizeMonitor.value.element = element;
					resizeMonitor.value.cancel = monitorResize(element, _forceAlign);
				}
			}
		};
		onMounted(function() {
			nextTick(function() {
				goAlign();
			});
		});
		onUpdated(function() {
			nextTick(function() {
				goAlign();
			});
		});
		watch(function() {
			return props.disabled;
		}, function(disabled) {
			if (!disabled) _forceAlign();
			else cancelForceAlign();
		}, {
			immediate: true,
			flush: "post"
		});
		var winResizeRef = ref(null);
		watch(function() {
			return props.monitorWindowResize;
		}, function(monitorWindowResize) {
			if (monitorWindowResize) {
				if (!winResizeRef.value) winResizeRef.value = addEventListenerWrap(window, "resize", _forceAlign);
			} else if (winResizeRef.value) {
				winResizeRef.value.remove();
				winResizeRef.value = null;
			}
		}, { flush: "post" });
		onUnmounted(function() {
			resizeMonitor.value.cancel();
			sourceResizeMonitor.value.cancel();
			if (winResizeRef.value) winResizeRef.value.remove();
			cancelForceAlign();
		});
		expose({ forceAlign: function forceAlign() {
			return _forceAlign(true);
		} });
		return function() {
			var child = slots === null || slots === void 0 ? void 0 : slots.default();
			if (child) return cloneElement(child[0], { ref: nodeRef }, true, true);
			return null;
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Popup/PopupInner.js
var PopupInner_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "PopupInner",
	inheritAttrs: false,
	props: innerProps,
	emits: [
		"mouseenter",
		"mouseleave",
		"mousedown",
		"touchstart",
		"align"
	],
	setup: function setup(props, _ref) {
		var expose = _ref.expose, attrs = _ref.attrs, slots = _ref.slots;
		var alignRef = ref();
		var elementRef = ref();
		var alignedClassName = ref();
		var _useStretchStyle2 = _slicedToArray(useStretchStyle_default(toRef(props, "stretch")), 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
		var doMeasure = function doMeasure$1() {
			if (props.stretch) measureStretchStyle(props.getRootDomNode());
		};
		var visible = ref(false);
		var timeoutId;
		watch(function() {
			return props.visible;
		}, function(val) {
			clearTimeout(timeoutId);
			if (val) timeoutId = setTimeout(function() {
				visible.value = props.visible;
			});
			else visible.value = false;
		}, { immediate: true });
		var _useVisibleStatus2 = _slicedToArray(useVisibleStatus_default(visible, doMeasure), 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
		var prepareResolveRef = ref();
		var getAlignTarget = function getAlignTarget$1() {
			if (props.point) return props.point;
			return props.getRootDomNode;
		};
		var forceAlign = function forceAlign$1() {
			var _alignRef$value;
			(_alignRef$value = alignRef.value) === null || _alignRef$value === void 0 || _alignRef$value.forceAlign();
		};
		var onInternalAlign = function onInternalAlign$1(popupDomNode, matchAlign) {
			var nextAlignedClassName = props.getClassNameFromAlign(matchAlign);
			var preAlignedClassName = alignedClassName.value;
			if (alignedClassName.value !== nextAlignedClassName) alignedClassName.value = nextAlignedClassName;
			if (status.value === "align") {
				var _props$onAlign;
				if (preAlignedClassName !== nextAlignedClassName) Promise.resolve().then(function() {
					forceAlign();
				});
				else goNextStatus(function() {
					var _prepareResolveRef$va;
					(_prepareResolveRef$va = prepareResolveRef.value) === null || _prepareResolveRef$va === void 0 || _prepareResolveRef$va.call(prepareResolveRef);
				});
				(_props$onAlign = props.onAlign) === null || _props$onAlign === void 0 || _props$onAlign.call(props, popupDomNode, matchAlign);
			}
		};
		var motion = computed(function() {
			var m = _typeof(props.animation) === "object" ? props.animation : getMotion(props);
			["onAfterEnter", "onAfterLeave"].forEach(function(eventName) {
				var originFn = m[eventName];
				m[eventName] = function(node) {
					goNextStatus();
					status.value = "stable";
					originFn === null || originFn === void 0 || originFn(node);
				};
			});
			return m;
		});
		var onShowPrepare = function onShowPrepare$1() {
			return new Promise(function(resolve) {
				prepareResolveRef.value = resolve;
			});
		};
		watch([motion, status], function() {
			if (!motion.value && status.value === "motion") goNextStatus();
		}, { immediate: true });
		expose({
			forceAlign,
			getElement: function getElement$1() {
				return elementRef.value.$el || elementRef.value;
			}
		});
		var alignDisabled = computed(function() {
			var _props$align;
			if ((_props$align = props.align) !== null && _props$align !== void 0 && _props$align.points && (status.value === "align" || status.value === "stable")) return false;
			return true;
		});
		return function() {
			var _slots$default;
			var zIndex = props.zIndex, align = props.align, prefixCls = props.prefixCls, destroyPopupOnHide = props.destroyPopupOnHide, onMouseenter = props.onMouseenter, onMouseleave = props.onMouseleave, _props$onTouchstart = props.onTouchstart, onTouchstart = _props$onTouchstart === void 0 ? function() {} : _props$onTouchstart, onMousedown = props.onMousedown;
			var statusValue = status.value;
			var mergedStyle = [_objectSpread2(_objectSpread2({}, stretchStyle.value), {}, {
				zIndex,
				opacity: statusValue === "motion" || statusValue === "stable" || !visible.value ? null : 0,
				pointerEvents: !visible.value && statusValue !== "stable" ? "none" : null
			}), attrs.style];
			var childNode = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots, { visible: props.visible }));
			if (childNode.length > 1) {
				(function() {
					return childNode;
				})();
				childNode = createVNode("div", { "class": "".concat(prefixCls, "-content") }, [childNode]);
			}
			var mergedClassName = classNames_default(prefixCls, attrs.class, alignedClassName.value);
			var transitionProps = visible.value || !props.visible ? getTransitionProps(motion.value.name, motion.value) : {};
			return createVNode(Transition, _objectSpread2(_objectSpread2({ "ref": elementRef }, transitionProps), {}, { "onBeforeEnter": onShowPrepare }), { default: function _default() {
				return !destroyPopupOnHide || props.visible ? withDirectives(createVNode(Align_default, {
					"target": getAlignTarget(),
					"key": "popup",
					"ref": alignRef,
					"monitorWindowResize": true,
					"disabled": alignDisabled.value,
					"align": align,
					"onAlign": onInternalAlign
				}, { default: function _default$1() {
					return createVNode("div", _objectSpread2(_objectSpread2({
						"class": mergedClassName,
						"onMouseenter": onMouseenter,
						"onMouseleave": onMouseleave,
						"onMousedown": withModifiers(onMousedown, ["capture"])
					}, _defineProperty({}, supportsPassive_default ? "onTouchstartPassive" : "onTouchstart", withModifiers(onTouchstart, ["capture"]))), {}, { "style": mergedStyle }), [childNode]);
				} }), [[vShow, visible.value]]) : null;
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Popup/index.js
var Popup_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Popup",
	inheritAttrs: false,
	props: popupProps,
	setup: function setup(props, _ref) {
		var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
		var innerVisible = ref(false);
		var inMobile = ref(false);
		var popupRef = ref();
		watch([function() {
			return props.visible;
		}, function() {
			return props.mobile;
		}], function() {
			innerVisible.value = props.visible;
			if (props.visible && props.mobile) inMobile.value = true;
		}, {
			immediate: true,
			flush: "post"
		});
		expose({
			forceAlign: function forceAlign() {
				var _popupRef$value;
				(_popupRef$value = popupRef.value) === null || _popupRef$value === void 0 || _popupRef$value.forceAlign();
			},
			getElement: function getElement$1() {
				var _popupRef$value2;
				return (_popupRef$value2 = popupRef.value) === null || _popupRef$value2 === void 0 ? void 0 : _popupRef$value2.getElement();
			}
		});
		return function() {
			var cloneProps = _objectSpread2(_objectSpread2(_objectSpread2({}, props), attrs), {}, { visible: innerVisible.value });
			var popupNode = inMobile.value ? createVNode(MobilePopupInner_default, _objectSpread2(_objectSpread2({}, cloneProps), {}, {
				"mobile": props.mobile,
				"ref": popupRef
			}), { default: slots.default }) : createVNode(PopupInner_default, _objectSpread2(_objectSpread2({}, cloneProps), {}, { "ref": popupRef }), { default: slots.default });
			return createVNode("div", null, [createVNode(Mask, cloneProps, null), popupNode]);
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/utils/alignUtil.js
function isPointsEq(a1, a2, isAlignPoint) {
	if (isAlignPoint) return a1[0] === a2[0];
	return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
	return _objectSpread2(_objectSpread2({}, builtinPlacements[placementStr] || {}), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
	var points = align.points;
	var placements$2 = Object.keys(builtinPlacements);
	for (var i = 0; i < placements$2.length; i += 1) {
		var placement = placements$2[i];
		if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) return "".concat(prefixCls, "-placement-").concat(placement);
	}
	return "";
}

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/context.js
var TriggerContextKey = Symbol("TriggerContextKey");
var useProviderTrigger = function useProviderTrigger$1() {
	var portal = null;
	provide(TriggerContextKey, {
		setPortal: function setPortal(val) {
			portal = val;
		},
		popPortal: true
	});
	return function() {
		return portal;
	};
};
var useInjectTrigger = function useInjectTrigger$1(tryPopPortal) {
	return tryPopPortal ? inject(TriggerContextKey, {
		setPortal: function setPortal() {},
		popPortal: false
	}) : {
		setPortal: function setPortal() {},
		popPortal: false
	};
};
var PortalContextKey = Symbol("PortalContextKey");
var useProvidePortal = function useProvidePortal$1(instance) {
	provide(PortalContextKey, {
		inTriggerContext: (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { inTriggerContext: true }).inTriggerContext,
		shouldRender: computed(function() {
			var _ref = instance || {}, sPopupVisible = _ref.sPopupVisible, popupRef = _ref.popupRef, forceRender = _ref.forceRender, autoDestroy = _ref.autoDestroy;
			var shouldRender = false;
			if (sPopupVisible || popupRef || forceRender) shouldRender = true;
			if (!sPopupVisible && autoDestroy) shouldRender = false;
			return shouldRender;
		})
	});
};
var useInjectPortal = function useInjectPortal$1() {
	useProvidePortal({}, { inTriggerContext: false });
	var portalContext = inject(PortalContextKey, {
		shouldRender: computed(function() {
			return false;
		}),
		inTriggerContext: false
	});
	return { shouldRender: computed(function() {
		return portalContext.shouldRender.value || portalContext.inTriggerContext === false;
	}) };
};

//#endregion
//#region node_modules/ant-design-vue/es/_util/Portal.js
var Portal_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Portal",
	inheritAttrs: false,
	props: {
		getContainer: vue_types_default.func.isRequired,
		didUpdate: Function
	},
	setup: function setup(props, _ref) {
		var slots = _ref.slots;
		var isSSR = true;
		var container;
		var shouldRender = useInjectPortal().shouldRender;
		onBeforeMount(function() {
			isSSR = false;
			if (shouldRender.value) container = props.getContainer();
		});
		var stopWatch = watch(shouldRender, function() {
			if (shouldRender.value && !container) container = props.getContainer();
			if (container) stopWatch();
		});
		onUpdated(function() {
			nextTick(function() {
				if (shouldRender.value) {
					var _props$didUpdate;
					(_props$didUpdate = props.didUpdate) === null || _props$didUpdate === void 0 || _props$didUpdate.call(props, props);
				}
			});
		});
		onBeforeUnmount(function() {
			if (container && container.parentNode) container.parentNode.removeChild(container);
		});
		return function() {
			if (!shouldRender.value) return null;
			if (isSSR) {
				var _slots$default;
				return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
			}
			return container ? createVNode(Teleport, { "to": container }, slots) : null;
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/Trigger.js
function noop$2() {}
function returnEmptyString() {
	return "";
}
function returnDocument(element) {
	if (element) return element.ownerDocument;
	return window.document;
}
var ALL_HANDLERS = [
	"onClick",
	"onMousedown",
	"onTouchstart",
	"onMouseenter",
	"onMouseleave",
	"onFocus",
	"onBlur",
	"onContextmenu"
];
var Trigger_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Trigger",
	mixins: [BaseMixin_default],
	inheritAttrs: false,
	props: {
		action: vue_types_default.oneOfType([vue_types_default.string, vue_types_default.arrayOf(vue_types_default.string)]).def([]),
		showAction: vue_types_default.any.def([]),
		hideAction: vue_types_default.any.def([]),
		getPopupClassNameFromAlign: vue_types_default.any.def(returnEmptyString),
		onPopupVisibleChange: Function,
		afterPopupVisibleChange: vue_types_default.func.def(noop$2),
		popup: vue_types_default.any,
		popupStyle: {
			type: Object,
			default: void 0
		},
		prefixCls: vue_types_default.string.def("rc-trigger-popup"),
		popupClassName: vue_types_default.string.def(""),
		popupPlacement: String,
		builtinPlacements: vue_types_default.object,
		popupTransitionName: String,
		popupAnimation: vue_types_default.any,
		mouseEnterDelay: vue_types_default.number.def(0),
		mouseLeaveDelay: vue_types_default.number.def(.1),
		zIndex: Number,
		focusDelay: vue_types_default.number.def(0),
		blurDelay: vue_types_default.number.def(.15),
		getPopupContainer: Function,
		getDocument: vue_types_default.func.def(returnDocument),
		forceRender: {
			type: Boolean,
			default: void 0
		},
		destroyPopupOnHide: {
			type: Boolean,
			default: false
		},
		mask: {
			type: Boolean,
			default: false
		},
		maskClosable: {
			type: Boolean,
			default: true
		},
		popupAlign: vue_types_default.object.def(function() {
			return {};
		}),
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean,
			default: false
		},
		maskTransitionName: String,
		maskAnimation: String,
		stretch: String,
		alignPoint: {
			type: Boolean,
			default: void 0
		},
		autoDestroy: {
			type: Boolean,
			default: false
		},
		mobile: Object,
		getTriggerDOMNode: Function,
		tryPopPortal: Boolean
	},
	setup: function setup(props) {
		var align = computed(function() {
			var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
			if (popupPlacement && builtinPlacements) return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
			return popupAlign;
		});
		var _useInjectTrigger = useInjectTrigger(props.tryPopPortal), setPortal = _useInjectTrigger.setPortal, popPortal = _useInjectTrigger.popPortal;
		var popupRef = ref(null);
		return {
			popPortal,
			setPortal,
			vcTriggerContext: inject("vcTriggerContext", {}),
			popupRef,
			setPopupRef: function setPopupRef(val) {
				popupRef.value = val;
			},
			triggerRef: ref(null),
			align,
			focusTime: null,
			clickOutsideHandler: null,
			contextmenuOutsideHandler1: null,
			contextmenuOutsideHandler2: null,
			touchOutsideHandler: null,
			attachId: null,
			delayTimer: null,
			hasPopupMouseDown: false,
			preClickTime: null,
			preTouchTime: null,
			mouseDownTimeout: null,
			childOriginEvents: {}
		};
	},
	data: function data() {
		var _this = this, _this$setPortal;
		var props = this.$props;
		var popupVisible;
		if (this.popupVisible !== void 0) popupVisible = !!props.popupVisible;
		else popupVisible = !!props.defaultPopupVisible;
		ALL_HANDLERS.forEach(function(h) {
			_this["fire".concat(h)] = function(e) {
				_this.fireEvents(h, e);
			};
		});
		(_this$setPortal = this.setPortal) === null || _this$setPortal === void 0 || _this$setPortal.call(this, createVNode(Portal_default, {
			"key": "portal",
			"getContainer": this.getContainer,
			"didUpdate": this.handlePortalUpdate
		}, { default: this.getComponent }));
		return {
			prevPopupVisible: popupVisible,
			sPopupVisible: popupVisible,
			point: null
		};
	},
	watch: { popupVisible: function popupVisible(val) {
		if (val !== void 0) {
			this.prevPopupVisible = this.sPopupVisible;
			this.sPopupVisible = val;
		}
	} },
	created: function created() {
		provide("vcTriggerContext", { onPopupMouseDown: this.onPopupMouseDown });
		useProvidePortal(this);
	},
	deactivated: function deactivated() {
		this.setPopupVisible(false);
	},
	mounted: function mounted() {
		var _this2 = this;
		this.$nextTick(function() {
			_this2.updatedCal();
		});
	},
	updated: function updated() {
		var _this3 = this;
		this.$nextTick(function() {
			_this3.updatedCal();
		});
	},
	beforeUnmount: function beforeUnmount() {
		this.clearDelayTimer();
		this.clearOutsideHandler();
		clearTimeout(this.mouseDownTimeout);
		wrapperRaf.cancel(this.attachId);
	},
	methods: {
		updatedCal: function updatedCal() {
			var props = this.$props;
			if (this.$data.sPopupVisible) {
				var currentDocument;
				if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
					currentDocument = props.getDocument(this.getRootDomNode());
					this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
				}
				if (!this.touchOutsideHandler) {
					currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
					this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, supportsPassive_default ? { passive: false } : false);
				}
				if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
					currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
					this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose);
				}
				if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose);
			} else this.clearOutsideHandler();
		},
		onMouseenter: function onMouseenter(e) {
			var mouseEnterDelay = this.$props.mouseEnterDelay;
			this.fireEvents("onMouseenter", e);
			this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
		},
		onMouseMove: function onMouseMove(e) {
			this.fireEvents("onMousemove", e);
			this.setPoint(e);
		},
		onMouseleave: function onMouseleave(e) {
			this.fireEvents("onMouseleave", e);
			this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
		},
		onPopupMouseenter: function onPopupMouseenter() {
			this.clearDelayTimer();
		},
		onPopupMouseleave: function onPopupMouseleave(e) {
			var _this$popupRef;
			if (e && e.relatedTarget && !e.relatedTarget.setTimeout && contains((_this$popupRef = this.popupRef) === null || _this$popupRef === void 0 ? void 0 : _this$popupRef.getElement(), e.relatedTarget)) return;
			this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
		},
		onFocus: function onFocus(e) {
			this.fireEvents("onFocus", e);
			this.clearDelayTimer();
			if (this.isFocusToShow()) {
				this.focusTime = Date.now();
				this.delaySetPopupVisible(true, this.$props.focusDelay);
			}
		},
		onMousedown: function onMousedown(e) {
			this.fireEvents("onMousedown", e);
			this.preClickTime = Date.now();
		},
		onTouchstart: function onTouchstart(e) {
			this.fireEvents("onTouchstart", e);
			this.preTouchTime = Date.now();
		},
		onBlur: function onBlur(e) {
			if (!contains(e.target, e.relatedTarget || document.activeElement)) {
				this.fireEvents("onBlur", e);
				this.clearDelayTimer();
				if (this.isBlurToHide()) this.delaySetPopupVisible(false, this.$props.blurDelay);
			}
		},
		onContextmenu: function onContextmenu(e) {
			e.preventDefault();
			this.fireEvents("onContextmenu", e);
			this.setPopupVisible(true, e);
		},
		onContextmenuClose: function onContextmenuClose() {
			if (this.isContextmenuToShow()) this.close();
		},
		onClick: function onClick(event) {
			this.fireEvents("onClick", event);
			if (this.focusTime) {
				var preTime;
				if (this.preClickTime && this.preTouchTime) preTime = Math.min(this.preClickTime, this.preTouchTime);
				else if (this.preClickTime) preTime = this.preClickTime;
				else if (this.preTouchTime) preTime = this.preTouchTime;
				if (Math.abs(preTime - this.focusTime) < 20) return;
				this.focusTime = 0;
			}
			this.preClickTime = 0;
			this.preTouchTime = 0;
			if (this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event && event.preventDefault) event.preventDefault();
			if (event && event.domEvent) event.domEvent.preventDefault();
			var nextVisible = !this.$data.sPopupVisible;
			if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) this.setPopupVisible(!this.$data.sPopupVisible, event);
		},
		onPopupMouseDown: function onPopupMouseDown() {
			var _this4 = this;
			var _this$vcTriggerContex = this.vcTriggerContext, vcTriggerContext = _this$vcTriggerContex === void 0 ? {} : _this$vcTriggerContex;
			this.hasPopupMouseDown = true;
			clearTimeout(this.mouseDownTimeout);
			this.mouseDownTimeout = setTimeout(function() {
				_this4.hasPopupMouseDown = false;
			}, 0);
			if (vcTriggerContext.onPopupMouseDown) vcTriggerContext.onPopupMouseDown.apply(vcTriggerContext, arguments);
		},
		onDocumentClick: function onDocumentClick(event) {
			if (this.$props.mask && !this.$props.maskClosable) return;
			var target = event.target;
			var root = this.getRootDomNode();
			var popupNode = this.getPopupDomNode();
			if ((!contains(root, target) || this.isContextMenuOnly()) && !contains(popupNode, target) && !this.hasPopupMouseDown) this.delaySetPopupVisible(false, .1);
		},
		getPopupDomNode: function getPopupDomNode() {
			var _this$popupRef2;
			return ((_this$popupRef2 = this.popupRef) === null || _this$popupRef2 === void 0 ? void 0 : _this$popupRef2.getElement()) || null;
		},
		getRootDomNode: function getRootDomNode() {
			var getTriggerDOMNode = this.$props.getTriggerDOMNode;
			if (getTriggerDOMNode) return findDOMNode(getTriggerDOMNode(findDOMNode(this.triggerRef)));
			try {
				var _domNode = findDOMNode(this.triggerRef);
				if (_domNode) return _domNode;
			} catch (err) {}
			return findDOMNode(this);
		},
		handleGetPopupClassFromAlign: function handleGetPopupClassFromAlign(align) {
			var className = [];
			var props = this.$props;
			var popupPlacement = props.popupPlacement, builtinPlacements = props.builtinPlacements, prefixCls = props.prefixCls, alignPoint$1 = props.alignPoint, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign;
			if (popupPlacement && builtinPlacements) className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint$1));
			if (getPopupClassNameFromAlign) className.push(getPopupClassNameFromAlign(align));
			return className.join(" ");
		},
		getPopupAlign: function getPopupAlign() {
			var props = this.$props;
			var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
			if (popupPlacement && builtinPlacements) return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
			return popupAlign;
		},
		getComponent: function getComponent$1() {
			var _this5 = this;
			var mouseProps = {};
			if (this.isMouseEnterToShow()) mouseProps.onMouseenter = this.onPopupMouseenter;
			if (this.isMouseLeaveToHide()) mouseProps.onMouseleave = this.onPopupMouseleave;
			mouseProps.onMousedown = this.onPopupMouseDown;
			mouseProps[supportsPassive_default ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
			var handleGetPopupClassFromAlign = this.handleGetPopupClassFromAlign, getRootDomNode = this.getRootDomNode, getContainer = this.getContainer, $attrs = this.$attrs;
			var _this$$props = this.$props, prefixCls = _this$$props.prefixCls, destroyPopupOnHide = _this$$props.destroyPopupOnHide, popupClassName = _this$$props.popupClassName, popupAnimation = _this$$props.popupAnimation, popupTransitionName = _this$$props.popupTransitionName, popupStyle = _this$$props.popupStyle, mask = _this$$props.mask, maskAnimation = _this$$props.maskAnimation, maskTransitionName = _this$$props.maskTransitionName, zIndex = _this$$props.zIndex, stretch = _this$$props.stretch, alignPoint$1 = _this$$props.alignPoint, mobile = _this$$props.mobile, forceRender = _this$$props.forceRender;
			var _this$$data = this.$data, sPopupVisible = _this$$data.sPopupVisible, point = _this$$data.point;
			return createVNode(Popup_default, _objectSpread2(_objectSpread2({
				prefixCls,
				destroyPopupOnHide,
				visible: sPopupVisible,
				point: alignPoint$1 ? point : null,
				align: this.align,
				animation: popupAnimation,
				getClassNameFromAlign: handleGetPopupClassFromAlign,
				stretch,
				getRootDomNode,
				mask,
				zIndex,
				transitionName: popupTransitionName,
				maskAnimation,
				maskTransitionName,
				getContainer,
				class: popupClassName,
				style: popupStyle,
				onAlign: $attrs.onPopupAlign || noop$2
			}, mouseProps), {}, {
				ref: this.setPopupRef,
				mobile,
				forceRender
			}), { default: this.$slots.popup || function() {
				return getComponent(_this5, "popup");
			} });
		},
		attachParent: function attachParent(popupContainer) {
			var _this6 = this;
			wrapperRaf.cancel(this.attachId);
			var _this$$props2 = this.$props, getPopupContainer = _this$$props2.getPopupContainer, getDocument$1 = _this$$props2.getDocument;
			var domNode = this.getRootDomNode();
			var mountNode;
			if (!getPopupContainer) mountNode = getDocument$1(this.getRootDomNode()).body;
			else if (domNode || getPopupContainer.length === 0) mountNode = getPopupContainer(domNode);
			if (mountNode) mountNode.appendChild(popupContainer);
			else this.attachId = wrapperRaf(function() {
				_this6.attachParent(popupContainer);
			});
		},
		getContainer: function getContainer() {
			var getDocument$1 = this.$props.getDocument;
			var popupContainer = getDocument$1(this.getRootDomNode()).createElement("div");
			popupContainer.style.position = "absolute";
			popupContainer.style.top = "0";
			popupContainer.style.left = "0";
			popupContainer.style.width = "100%";
			this.attachParent(popupContainer);
			return popupContainer;
		},
		setPopupVisible: function setPopupVisible(sPopupVisible, event) {
			var alignPoint$1 = this.alignPoint, prevPopupVisible = this.sPopupVisible, onPopupVisibleChange = this.onPopupVisibleChange;
			this.clearDelayTimer();
			if (prevPopupVisible !== sPopupVisible) {
				if (!hasProp(this, "popupVisible")) this.setState({
					sPopupVisible,
					prevPopupVisible
				});
				onPopupVisibleChange && onPopupVisibleChange(sPopupVisible);
			}
			if (alignPoint$1 && event && sPopupVisible) this.setPoint(event);
		},
		setPoint: function setPoint(point) {
			if (!this.$props.alignPoint || !point) return;
			this.setState({ point: {
				pageX: point.pageX,
				pageY: point.pageY
			} });
		},
		handlePortalUpdate: function handlePortalUpdate() {
			if (this.prevPopupVisible !== this.sPopupVisible) this.afterPopupVisibleChange(this.sPopupVisible);
		},
		delaySetPopupVisible: function delaySetPopupVisible(visible, delayS, event) {
			var _this7 = this;
			var delay = delayS * 1e3;
			this.clearDelayTimer();
			if (delay) {
				var point = event ? {
					pageX: event.pageX,
					pageY: event.pageY
				} : null;
				this.delayTimer = requestAnimationTimeout(function() {
					_this7.setPopupVisible(visible, point);
					_this7.clearDelayTimer();
				}, delay);
			} else this.setPopupVisible(visible, event);
		},
		clearDelayTimer: function clearDelayTimer() {
			if (this.delayTimer) {
				cancelAnimationTimeout(this.delayTimer);
				this.delayTimer = null;
			}
		},
		clearOutsideHandler: function clearOutsideHandler() {
			if (this.clickOutsideHandler) {
				this.clickOutsideHandler.remove();
				this.clickOutsideHandler = null;
			}
			if (this.contextmenuOutsideHandler1) {
				this.contextmenuOutsideHandler1.remove();
				this.contextmenuOutsideHandler1 = null;
			}
			if (this.contextmenuOutsideHandler2) {
				this.contextmenuOutsideHandler2.remove();
				this.contextmenuOutsideHandler2 = null;
			}
			if (this.touchOutsideHandler) {
				this.touchOutsideHandler.remove();
				this.touchOutsideHandler = null;
			}
		},
		createTwoChains: function createTwoChains(event) {
			var fn = function fn$1() {};
			var events = getEvents(this);
			if (this.childOriginEvents[event] && events[event]) return this["fire".concat(event)];
			fn = this.childOriginEvents[event] || events[event] || fn;
			return fn;
		},
		isClickToShow: function isClickToShow() {
			var _this$$props3 = this.$props, action = _this$$props3.action, showAction = _this$$props3.showAction;
			return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
		},
		isContextMenuOnly: function isContextMenuOnly() {
			var action = this.$props.action;
			return action === "contextmenu" || action.length === 1 && action[0] === "contextmenu";
		},
		isContextmenuToShow: function isContextmenuToShow() {
			var _this$$props4 = this.$props, action = _this$$props4.action, showAction = _this$$props4.showAction;
			return action.indexOf("contextmenu") !== -1 || showAction.indexOf("contextmenu") !== -1;
		},
		isClickToHide: function isClickToHide() {
			var _this$$props5 = this.$props, action = _this$$props5.action, hideAction = _this$$props5.hideAction;
			return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
		},
		isMouseEnterToShow: function isMouseEnterToShow() {
			var _this$$props6 = this.$props, action = _this$$props6.action, showAction = _this$$props6.showAction;
			return action.indexOf("hover") !== -1 || showAction.indexOf("mouseenter") !== -1;
		},
		isMouseLeaveToHide: function isMouseLeaveToHide() {
			var _this$$props7 = this.$props, action = _this$$props7.action, hideAction = _this$$props7.hideAction;
			return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseleave") !== -1;
		},
		isFocusToShow: function isFocusToShow() {
			var _this$$props8 = this.$props, action = _this$$props8.action, showAction = _this$$props8.showAction;
			return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
		},
		isBlurToHide: function isBlurToHide() {
			var _this$$props9 = this.$props, action = _this$$props9.action, hideAction = _this$$props9.hideAction;
			return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
		},
		forcePopupAlign: function forcePopupAlign() {
			if (this.$data.sPopupVisible) {
				var _this$popupRef3;
				(_this$popupRef3 = this.popupRef) === null || _this$popupRef3 === void 0 || _this$popupRef3.forceAlign();
			}
		},
		fireEvents: function fireEvents(type, e) {
			if (this.childOriginEvents[type]) this.childOriginEvents[type](e);
			var event = this.$props[type] || this.$attrs[type];
			if (event) event(e);
		},
		close: function close() {
			this.setPopupVisible(false);
		}
	},
	render: function render() {
		var _this8 = this;
		var $attrs = this.$attrs;
		var children = filterEmpty(getSlot(this));
		var alignPoint$1 = this.$props.alignPoint;
		var child = children[0];
		this.childOriginEvents = getEvents(child);
		var newChildProps = { key: "trigger" };
		if (this.isContextmenuToShow()) newChildProps.onContextmenu = this.onContextmenu;
		else newChildProps.onContextmenu = this.createTwoChains("onContextmenu");
		if (this.isClickToHide() || this.isClickToShow()) {
			newChildProps.onClick = this.onClick;
			newChildProps.onMousedown = this.onMousedown;
			newChildProps[supportsPassive_default ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart;
		} else {
			newChildProps.onClick = this.createTwoChains("onClick");
			newChildProps.onMousedown = this.createTwoChains("onMousedown");
			newChildProps[supportsPassive_default ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart");
		}
		if (this.isMouseEnterToShow()) {
			newChildProps.onMouseenter = this.onMouseenter;
			if (alignPoint$1) newChildProps.onMousemove = this.onMouseMove;
		} else newChildProps.onMouseenter = this.createTwoChains("onMouseenter");
		if (this.isMouseLeaveToHide()) newChildProps.onMouseleave = this.onMouseleave;
		else newChildProps.onMouseleave = this.createTwoChains("onMouseleave");
		if (this.isFocusToShow() || this.isBlurToHide()) {
			newChildProps.onFocus = this.onFocus;
			newChildProps.onBlur = this.onBlur;
		} else {
			newChildProps.onFocus = this.createTwoChains("onFocus");
			newChildProps.onBlur = function(e) {
				if (e && (!e.relatedTarget || !contains(e.target, e.relatedTarget))) _this8.createTwoChains("onBlur")(e);
			};
		}
		var childrenClassName = classNames_default(child && child.props && child.props.class, $attrs.class);
		if (childrenClassName) newChildProps.class = childrenClassName;
		var trigger = cloneElement(child, _objectSpread2(_objectSpread2({}, newChildProps), {}, { ref: "triggerRef" }), true, true);
		if (this.popPortal) return trigger;
		else return createVNode(Fragment, null, [createVNode(Portal_default, {
			"key": "portal",
			"getContainer": this.getContainer,
			"didUpdate": this.handlePortalUpdate
		}, { default: this.getComponent }), trigger]);
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-trigger/index.js
var vc_trigger_default = Trigger_default;

//#endregion
//#region node_modules/ant-design-vue/es/_util/KeyCode.js
/**
* @ignore
* some key-codes definition and utils from closure-library
* @author yiminghe@gmail.com
*/
var KeyCode = {
	MAC_ENTER: 3,
	BACKSPACE: 8,
	TAB: 9,
	NUM_CENTER: 12,
	ENTER: 13,
	SHIFT: 16,
	CTRL: 17,
	ALT: 18,
	PAUSE: 19,
	CAPS_LOCK: 20,
	ESC: 27,
	SPACE: 32,
	PAGE_UP: 33,
	PAGE_DOWN: 34,
	END: 35,
	HOME: 36,
	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	PRINT_SCREEN: 44,
	INSERT: 45,
	DELETE: 46,
	ZERO: 48,
	ONE: 49,
	TWO: 50,
	THREE: 51,
	FOUR: 52,
	FIVE: 53,
	SIX: 54,
	SEVEN: 55,
	EIGHT: 56,
	NINE: 57,
	QUESTION_MARK: 63,
	A: 65,
	B: 66,
	C: 67,
	D: 68,
	E: 69,
	F: 70,
	G: 71,
	H: 72,
	I: 73,
	J: 74,
	K: 75,
	L: 76,
	M: 77,
	N: 78,
	O: 79,
	P: 80,
	Q: 81,
	R: 82,
	S: 83,
	T: 84,
	U: 85,
	V: 86,
	W: 87,
	X: 88,
	Y: 89,
	Z: 90,
	META: 91,
	WIN_KEY_RIGHT: 92,
	CONTEXT_MENU: 93,
	NUM_ZERO: 96,
	NUM_ONE: 97,
	NUM_TWO: 98,
	NUM_THREE: 99,
	NUM_FOUR: 100,
	NUM_FIVE: 101,
	NUM_SIX: 102,
	NUM_SEVEN: 103,
	NUM_EIGHT: 104,
	NUM_NINE: 105,
	NUM_MULTIPLY: 106,
	NUM_PLUS: 107,
	NUM_MINUS: 109,
	NUM_PERIOD: 110,
	NUM_DIVISION: 111,
	F1: 112,
	F2: 113,
	F3: 114,
	F4: 115,
	F5: 116,
	F6: 117,
	F7: 118,
	F8: 119,
	F9: 120,
	F10: 121,
	F11: 122,
	F12: 123,
	NUMLOCK: 144,
	SEMICOLON: 186,
	DASH: 189,
	EQUALS: 187,
	COMMA: 188,
	PERIOD: 190,
	SLASH: 191,
	APOSTROPHE: 192,
	SINGLE_QUOTE: 222,
	OPEN_SQUARE_BRACKET: 219,
	BACKSLASH: 220,
	CLOSE_SQUARE_BRACKET: 221,
	WIN_KEY: 224,
	MAC_FF_META: 224,
	WIN_IME: 229,
	isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
		var keyCode = e.keyCode;
		if (e.altKey && !e.ctrlKey || e.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) return false;
		switch (keyCode) {
			case KeyCode.ALT:
			case KeyCode.CAPS_LOCK:
			case KeyCode.CONTEXT_MENU:
			case KeyCode.CTRL:
			case KeyCode.DOWN:
			case KeyCode.END:
			case KeyCode.ESC:
			case KeyCode.HOME:
			case KeyCode.INSERT:
			case KeyCode.LEFT:
			case KeyCode.MAC_FF_META:
			case KeyCode.META:
			case KeyCode.NUMLOCK:
			case KeyCode.NUM_CENTER:
			case KeyCode.PAGE_DOWN:
			case KeyCode.PAGE_UP:
			case KeyCode.PAUSE:
			case KeyCode.PRINT_SCREEN:
			case KeyCode.RIGHT:
			case KeyCode.SHIFT:
			case KeyCode.UP:
			case KeyCode.WIN_KEY:
			case KeyCode.WIN_KEY_RIGHT: return false;
			default: return true;
		}
	},
	isCharacterKey: function isCharacterKey(keyCode) {
		if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) return true;
		if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) return true;
		if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) return true;
		if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) return true;
		switch (keyCode) {
			case KeyCode.SPACE:
			case KeyCode.QUESTION_MARK:
			case KeyCode.NUM_PLUS:
			case KeyCode.NUM_MINUS:
			case KeyCode.NUM_PERIOD:
			case KeyCode.NUM_DIVISION:
			case KeyCode.SEMICOLON:
			case KeyCode.DASH:
			case KeyCode.EQUALS:
			case KeyCode.COMMA:
			case KeyCode.PERIOD:
			case KeyCode.SLASH:
			case KeyCode.APOSTROPHE:
			case KeyCode.SINGLE_QUOTE:
			case KeyCode.OPEN_SQUARE_BRACKET:
			case KeyCode.BACKSLASH:
			case KeyCode.CLOSE_SQUARE_BRACKET: return true;
			default: return false;
		}
	}
};
var KeyCode_default = KeyCode;

//#endregion
//#region node_modules/ant-design-vue/es/vc-overflow/context.js
var OverflowContextProviderKey = Symbol("OverflowContextProviderKey");
var OverflowContextProvider = defineComponent({
	compatConfig: { MODE: 3 },
	name: "OverflowContextProvider",
	inheritAttrs: false,
	props: { value: { type: Object } },
	setup: function setup(props, _ref) {
		var slots = _ref.slots;
		provide(OverflowContextProviderKey, computed(function() {
			return props.value;
		}));
		return function() {
			var _slots$default;
			return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
		};
	}
});
var useInjectOverflowContext = function useInjectOverflowContext$1() {
	return inject(OverflowContextProviderKey, computed(function() {
		return null;
	}));
};

//#endregion
//#region node_modules/ant-design-vue/es/vc-overflow/Item.js
var _excluded$3 = [
	"prefixCls",
	"invalidate",
	"item",
	"renderItem",
	"responsive",
	"registerSize",
	"itemKey",
	"display",
	"order",
	"component"
];
var UNDEFINED = void 0;
var Item_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Item",
	props: {
		prefixCls: String,
		item: vue_types_default.any,
		renderItem: Function,
		responsive: Boolean,
		itemKey: { type: [String, Number] },
		registerSize: Function,
		display: Boolean,
		order: Number,
		component: vue_types_default.any,
		invalidate: Boolean
	},
	setup: function setup(props, _ref) {
		var slots = _ref.slots, expose = _ref.expose;
		var mergedHidden = computed(function() {
			return props.responsive && !props.display;
		});
		var itemNodeRef = ref();
		expose({ itemNodeRef });
		function internalRegisterSize(width) {
			props.registerSize(props.itemKey, width);
		}
		onUnmounted(function() {
			internalRegisterSize(null);
		});
		return function() {
			var _slots$default, prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive;
			props.registerSize;
			props.itemKey;
			props.display;
			var order = props.order, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded$3);
			var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
			var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
			var overflowStyle;
			if (!invalidate) overflowStyle = {
				opacity: mergedHidden.value ? 0 : 1,
				height: mergedHidden.value ? 0 : UNDEFINED,
				overflowY: mergedHidden.value ? "hidden" : UNDEFINED,
				order: responsive ? order : UNDEFINED,
				pointerEvents: mergedHidden.value ? "none" : UNDEFINED,
				position: mergedHidden.value ? "absolute" : UNDEFINED
			};
			var overflowProps = {};
			if (mergedHidden.value) overflowProps["aria-hidden"] = true;
			return createVNode(vc_resize_observer_default, {
				"disabled": !responsive,
				"onResize": function onResize(_ref2) {
					var offsetWidth = _ref2.offsetWidth;
					internalRegisterSize(offsetWidth);
				}
			}, { default: function _default() {
				return createVNode(Component, _objectSpread2(_objectSpread2(_objectSpread2({
					"class": classNames_default(!invalidate && prefixCls),
					"style": overflowStyle
				}, overflowProps), restProps), {}, { "ref": itemNodeRef }), { default: function _default$1() {
					return [childNode];
				} });
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-overflow/RawItem.js
var _excluded$2 = ["component"], _excluded2 = ["className"], _excluded3 = ["class"];
var RawItem_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "RawItem",
	inheritAttrs: false,
	props: {
		component: vue_types_default.any,
		title: vue_types_default.any,
		id: String,
		onMouseenter: { type: Function },
		onMouseleave: { type: Function },
		onClick: { type: Function },
		onKeydown: { type: Function },
		onFocus: { type: Function }
	},
	setup: function setup(props, _ref) {
		var slots = _ref.slots, attrs = _ref.attrs;
		var context = useInjectOverflowContext();
		return function() {
			if (!context.value) {
				var _slots$default;
				var _props$component = props.component;
				return createVNode(_props$component === void 0 ? "div" : _props$component, _objectSpread2(_objectSpread2({}, _objectWithoutProperties(props, _excluded$2)), attrs), { default: function _default() {
					return [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
				} });
			}
			var _context$value = context.value, contextClassName = _context$value.className, restContext = _objectWithoutProperties(_context$value, _excluded2);
			var className = attrs.class, restProps = _objectWithoutProperties(attrs, _excluded3);
			return createVNode(OverflowContextProvider, { "value": null }, { default: function _default() {
				return [createVNode(Item_default, _objectSpread2(_objectSpread2(_objectSpread2({ "class": classNames_default(contextClassName, className) }, restContext), restProps), props), slots)];
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-overflow/Overflow.js
var _excluded$1 = ["class", "style"];
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
	return "+ ".concat(omittedItems.length, " ...");
}
var Overflow = defineComponent({
	name: "Overflow",
	inheritAttrs: false,
	props: function overflowProps() {
		return {
			id: String,
			prefixCls: String,
			data: Array,
			itemKey: [
				String,
				Number,
				Function
			],
			itemWidth: {
				type: Number,
				default: 10
			},
			renderItem: Function,
			renderRawItem: Function,
			maxCount: [Number, String],
			renderRest: Function,
			renderRawRest: Function,
			suffix: vue_types_default.any,
			component: String,
			itemComponent: vue_types_default.any,
			onVisibleChange: Function,
			ssr: String,
			onMousedown: Function
		};
	}(),
	emits: ["visibleChange"],
	setup: function setup(props, _ref) {
		var attrs = _ref.attrs, emit = _ref.emit, slots = _ref.slots;
		var fullySSR = computed(function() {
			return props.ssr === "full";
		});
		var containerWidth = ref(null);
		var mergedContainerWidth = computed(function() {
			return containerWidth.value || 0;
		});
		var itemWidths = ref(/* @__PURE__ */ new Map());
		var prevRestWidth = ref(0);
		var restWidth = ref(0);
		var suffixWidth = ref(0);
		var suffixFixedStart = ref(null);
		var displayCount = ref(null);
		var mergedDisplayCount = computed(function() {
			if (displayCount.value === null && fullySSR.value) return Number.MAX_SAFE_INTEGER;
			return displayCount.value || 0;
		});
		var restReady = ref(false);
		var itemPrefixCls = computed(function() {
			return "".concat(props.prefixCls, "-item");
		});
		var mergedRestWidth = computed(function() {
			return Math.max(prevRestWidth.value, restWidth.value);
		});
		var isResponsive = computed(function() {
			return !!(props.data.length && props.maxCount === RESPONSIVE);
		});
		var invalidate = computed(function() {
			return props.maxCount === INVALIDATE;
		});
		/**
		* When is `responsive`, we will always render rest node to get the real width of it for calculation
		*/
		var showRest = computed(function() {
			return isResponsive.value || typeof props.maxCount === "number" && props.data.length > props.maxCount;
		});
		var mergedData = computed(function() {
			var items = props.data;
			if (isResponsive.value) if (containerWidth.value === null && fullySSR.value) items = props.data;
			else items = props.data.slice(0, Math.min(props.data.length, mergedContainerWidth.value / props.itemWidth));
			else if (typeof props.maxCount === "number") items = props.data.slice(0, props.maxCount);
			return items;
		});
		var omittedItems = computed(function() {
			if (isResponsive.value) return props.data.slice(mergedDisplayCount.value + 1);
			return props.data.slice(mergedData.value.length);
		});
		var getKey = function getKey$1(item, index) {
			var _ref2;
			if (typeof props.itemKey === "function") return props.itemKey(item);
			return (_ref2 = props.itemKey && (item === null || item === void 0 ? void 0 : item[props.itemKey])) !== null && _ref2 !== void 0 ? _ref2 : index;
		};
		var mergedRenderItem = computed(function() {
			return props.renderItem || function(item) {
				return item;
			};
		});
		var updateDisplayCount = function updateDisplayCount$1(count, notReady) {
			displayCount.value = count;
			if (!notReady) {
				restReady.value = count < props.data.length - 1;
				emit("visibleChange", count);
			}
		};
		var onOverflowResize = function onOverflowResize$1(_, element) {
			containerWidth.value = element.clientWidth;
		};
		var registerSize = function registerSize$1(key, width) {
			var clone = new Map(itemWidths.value);
			if (width === null) clone.delete(key);
			else clone.set(key, width);
			itemWidths.value = clone;
		};
		var registerOverflowSize = function registerOverflowSize$1(_, width) {
			prevRestWidth.value = restWidth.value;
			restWidth.value = width;
		};
		var registerSuffixSize = function registerSuffixSize$1(_, width) {
			suffixWidth.value = width;
		};
		var getItemWidth = function getItemWidth$1(index) {
			return itemWidths.value.get(getKey(mergedData.value[index], index));
		};
		watch([
			mergedContainerWidth,
			itemWidths,
			restWidth,
			suffixWidth,
			function() {
				return props.itemKey;
			},
			mergedData
		], function() {
			if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {
				var totalWidth = suffixWidth.value;
				var len = mergedData.value.length;
				var lastIndex = len - 1;
				if (!len) {
					updateDisplayCount(0);
					suffixFixedStart.value = null;
					return;
				}
				for (var i = 0; i < len; i += 1) {
					var currentItemWidth = getItemWidth(i);
					if (currentItemWidth === void 0) {
						updateDisplayCount(i - 1, true);
						break;
					}
					totalWidth += currentItemWidth;
					if (lastIndex === 0 && totalWidth <= mergedContainerWidth.value || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value) {
						updateDisplayCount(lastIndex);
						suffixFixedStart.value = null;
						break;
					} else if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {
						updateDisplayCount(i - 1);
						suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;
						break;
					}
				}
				if (props.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value) suffixFixedStart.value = null;
			}
		});
		return function() {
			var displayRest = restReady.value && !!omittedItems.value.length;
			var itemComponent = props.itemComponent, renderRawItem = props.renderRawItem, renderRawRest = props.renderRawRest, renderRest = props.renderRest, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, suffix = props.suffix, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, id = props.id, onMousedown = props.onMousedown;
			var className = attrs.class, style = attrs.style, restAttrs = _objectWithoutProperties(attrs, _excluded$1);
			var suffixStyle = {};
			if (suffixFixedStart.value !== null && isResponsive.value) suffixStyle = {
				position: "absolute",
				left: "".concat(suffixFixedStart.value, "px"),
				top: 0
			};
			var itemSharedProps = {
				prefixCls: itemPrefixCls.value,
				responsive: isResponsive.value,
				component: itemComponent,
				invalidate: invalidate.value
			};
			var internalRenderItemNode = renderRawItem ? function(item, index) {
				var key = getKey(item, index);
				return createVNode(OverflowContextProvider, {
					"key": key,
					"value": _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
						order: index,
						item,
						itemKey: key,
						registerSize,
						display: index <= mergedDisplayCount.value
					})
				}, { default: function _default() {
					return [renderRawItem(item, index)];
				} });
			} : function(item, index) {
				var key = getKey(item, index);
				return createVNode(Item_default, _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
					"order": index,
					"key": key,
					"item": item,
					"renderItem": mergedRenderItem.value,
					"itemKey": key,
					"registerSize": registerSize,
					"display": index <= mergedDisplayCount.value
				}), null);
			};
			var restNode = function restNode$1() {
				return null;
			};
			var restContextProps = {
				order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,
				className: "".concat(itemPrefixCls.value, " ").concat(itemPrefixCls.value, "-rest"),
				registerSize: registerOverflowSize,
				display: displayRest
			};
			if (!renderRawRest) {
				var mergedRenderRest = renderRest || defaultRenderRest;
				restNode = function restNode$1() {
					return createVNode(Item_default, _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps), { default: function _default() {
						return typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems.value) : mergedRenderRest;
					} });
				};
			} else if (renderRawRest) restNode = function restNode$1() {
				return createVNode(OverflowContextProvider, { "value": _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps) }, { default: function _default() {
					return [renderRawRest(omittedItems.value)];
				} });
			};
			var overflowNode = function overflowNode$1() {
				var _slots$default;
				return createVNode(Component, _objectSpread2({
					"id": id,
					"class": classNames_default(!invalidate.value && prefixCls, className),
					"style": style,
					"onMousedown": onMousedown
				}, restAttrs), { default: function _default() {
					return [
						mergedData.value.map(internalRenderItemNode),
						showRest.value ? restNode() : null,
						suffix && createVNode(Item_default, _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
							"order": mergedDisplayCount.value,
							"class": "".concat(itemPrefixCls.value, "-suffix"),
							"registerSize": registerSuffixSize,
							"display": true,
							"style": suffixStyle
						}), { default: function _default$1() {
							return suffix;
						} }),
						(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)
					];
				} });
			};
			return createVNode(vc_resize_observer_default, {
				"disabled": !isResponsive.value,
				"onResize": onOverflowResize
			}, { default: overflowNode });
		};
	}
});
Overflow.Item = RawItem_default;
Overflow.RESPONSIVE = RESPONSIVE;
Overflow.INVALIDATE = INVALIDATE;
var Overflow_default = Overflow;

//#endregion
//#region node_modules/ant-design-vue/es/vc-overflow/index.js
var vc_overflow_default = Overflow_default;

//#endregion
//#region node_modules/ant-design-vue/es/vc-tooltip/src/placements.js
var autoAdjustOverflow$1 = {
	adjustX: 1,
	adjustY: 1
};
var targetOffset$1 = [0, 0];
var placements$1 = {
	left: {
		points: ["cr", "cl"],
		overflow: autoAdjustOverflow$1,
		offset: [-4, 0],
		targetOffset: targetOffset$1
	},
	right: {
		points: ["cl", "cr"],
		overflow: autoAdjustOverflow$1,
		offset: [4, 0],
		targetOffset: targetOffset$1
	},
	top: {
		points: ["bc", "tc"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	bottom: {
		points: ["tc", "bc"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	},
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	leftTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflow$1,
		offset: [-4, 0],
		targetOffset: targetOffset$1
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	rightTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflow$1,
		offset: [4, 0],
		targetOffset: targetOffset$1
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	},
	rightBottom: {
		points: ["bl", "br"],
		overflow: autoAdjustOverflow$1,
		offset: [4, 0],
		targetOffset: targetOffset$1
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	},
	leftBottom: {
		points: ["br", "bl"],
		overflow: autoAdjustOverflow$1,
		offset: [-4, 0],
		targetOffset: targetOffset$1
	}
};

//#endregion
//#region node_modules/ant-design-vue/es/vc-tooltip/src/Content.js
var tooltipContentProps = {
	prefixCls: String,
	id: String,
	overlayInnerStyle: vue_types_default.any
};
var Content_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Content",
	props: tooltipContentProps,
	slots: ["overlay"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots;
		return function() {
			var _slots$overlay;
			return createVNode("div", {
				"class": "".concat(props.prefixCls, "-inner"),
				"id": props.id,
				"role": "tooltip",
				"style": props.overlayInnerStyle
			}, [(_slots$overlay = slots.overlay) === null || _slots$overlay === void 0 ? void 0 : _slots$overlay.call(slots)]);
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-tooltip/src/Tooltip.js
var _excluded = [
	"overlayClassName",
	"trigger",
	"mouseEnterDelay",
	"mouseLeaveDelay",
	"overlayStyle",
	"prefixCls",
	"afterVisibleChange",
	"transitionName",
	"animation",
	"placement",
	"align",
	"destroyTooltipOnHide",
	"defaultVisible"
];
function noop$1() {}
var Tooltip_default$1 = defineComponent({
	compatConfig: { MODE: 3 },
	name: "Tooltip",
	inheritAttrs: false,
	props: {
		trigger: vue_types_default.any.def(["hover"]),
		defaultVisible: {
			type: Boolean,
			default: void 0
		},
		visible: {
			type: Boolean,
			default: void 0
		},
		placement: vue_types_default.string.def("right"),
		transitionName: String,
		animation: vue_types_default.any,
		afterVisibleChange: vue_types_default.func.def(function() {}),
		overlayStyle: {
			type: Object,
			default: void 0
		},
		overlayClassName: String,
		prefixCls: vue_types_default.string.def("rc-tooltip"),
		mouseEnterDelay: vue_types_default.number.def(.1),
		mouseLeaveDelay: vue_types_default.number.def(.1),
		getPopupContainer: Function,
		destroyTooltipOnHide: {
			type: Boolean,
			default: false
		},
		align: vue_types_default.object.def(function() {
			return {};
		}),
		arrowContent: vue_types_default.any.def(null),
		tipId: String,
		builtinPlacements: vue_types_default.object,
		overlayInnerStyle: {
			type: Object,
			default: void 0
		},
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		onVisibleChange: Function,
		onPopupAlign: Function
	},
	slots: ["arrowContent", "overlay"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
		var triggerDOM = ref();
		var getPopupElement = function getPopupElement$1() {
			var prefixCls = props.prefixCls, tipId = props.tipId, overlayInnerStyle = props.overlayInnerStyle;
			return [createVNode("div", {
				"class": "".concat(prefixCls, "-arrow"),
				"key": "arrow"
			}, [getPropsSlot(slots, props, "arrowContent")]), createVNode(Content_default, {
				"key": "content",
				"prefixCls": prefixCls,
				"id": tipId,
				"overlayInnerStyle": overlayInnerStyle
			}, { overlay: slots.overlay })];
		};
		expose({
			getPopupDomNode: function getPopupDomNode() {
				return triggerDOM.value.getPopupDomNode();
			},
			triggerDOM,
			forcePopupAlign: function forcePopupAlign() {
				var _triggerDOM$value;
				return (_triggerDOM$value = triggerDOM.value) === null || _triggerDOM$value === void 0 ? void 0 : _triggerDOM$value.forcePopupAlign();
			}
		});
		var destroyTooltip = ref(false);
		var autoDestroy = ref(false);
		watchEffect(function() {
			var destroyTooltipOnHide = props.destroyTooltipOnHide;
			if (typeof destroyTooltipOnHide === "boolean") destroyTooltip.value = destroyTooltipOnHide;
			else if (destroyTooltipOnHide && _typeof(destroyTooltipOnHide) === "object") {
				var keepParent = destroyTooltipOnHide.keepParent;
				destroyTooltip.value = keepParent === true;
				autoDestroy.value = keepParent === false;
			}
		});
		return function() {
			var overlayClassName = props.overlayClassName, trigger = props.trigger, mouseEnterDelay = props.mouseEnterDelay, mouseLeaveDelay = props.mouseLeaveDelay, overlayStyle = props.overlayStyle, prefixCls = props.prefixCls, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, placement = props.placement, align = props.align;
			props.destroyTooltipOnHide;
			var defaultVisible = props.defaultVisible;
			var extraProps = _objectSpread2({}, _objectWithoutProperties(props, _excluded));
			if (props.visible !== void 0) extraProps.popupVisible = props.visible;
			return createVNode(vc_trigger_default, _objectSpread2(_objectSpread2(_objectSpread2({
				popupClassName: overlayClassName,
				prefixCls,
				action: trigger,
				builtinPlacements: placements$1,
				popupPlacement: placement,
				popupAlign: align,
				afterPopupVisibleChange: afterVisibleChange,
				popupTransitionName: transitionName,
				popupAnimation: animation,
				defaultPopupVisible: defaultVisible,
				destroyPopupOnHide: destroyTooltip.value,
				autoDestroy: autoDestroy.value,
				mouseLeaveDelay,
				popupStyle: overlayStyle,
				mouseEnterDelay
			}, extraProps), attrs), {}, {
				onPopupVisibleChange: props.onVisibleChange || noop$1,
				onPopupAlign: props.onPopupAlign || noop$1,
				ref: triggerDOM,
				popup: getPopupElement()
			}), { default: slots.default });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-tooltip/index.js
var vc_tooltip_default = Tooltip_default$1;

//#endregion
//#region node_modules/ant-design-vue/es/_util/colors.js
var PresetStatusColorTypes = tuple("success", "processing", "error", "default", "warning");
var PresetColorTypes = tuple("pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue", "magenta", "volcano", "gold", "lime");

//#endregion
//#region node_modules/ant-design-vue/es/tooltip/abstractTooltipProps.js
var abstractTooltipProps_default = (function() {
	return {
		trigger: [String, Array],
		visible: {
			type: Boolean,
			default: void 0
		},
		defaultVisible: {
			type: Boolean,
			default: void 0
		},
		placement: String,
		color: String,
		transitionName: String,
		overlayStyle: {
			type: Object,
			default: void 0
		},
		overlayClassName: String,
		openClassName: String,
		prefixCls: String,
		mouseEnterDelay: Number,
		mouseLeaveDelay: Number,
		getPopupContainer: Function,
		arrowPointAtCenter: {
			type: Boolean,
			default: void 0
		},
		autoAdjustOverflow: {
			type: [Boolean, Object],
			default: void 0
		},
		destroyTooltipOnHide: {
			type: Boolean,
			default: void 0
		},
		align: {
			type: Object,
			default: void 0
		},
		builtinPlacements: {
			type: Object,
			default: void 0
		},
		children: Array,
		onVisibleChange: Function,
		"onUpdate:visible": Function
	};
});

//#endregion
//#region node_modules/ant-design-vue/es/tooltip/placements.js
var autoAdjustOverflowEnabled = {
	adjustX: 1,
	adjustY: 1
};
var autoAdjustOverflowDisabled = {
	adjustX: 0,
	adjustY: 0
};
var targetOffset = [0, 0];
function getOverflowOptions(autoAdjustOverflow$2) {
	if (typeof autoAdjustOverflow$2 === "boolean") return autoAdjustOverflow$2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
	return _objectSpread2(_objectSpread2({}, autoAdjustOverflowDisabled), autoAdjustOverflow$2);
}
function getPlacements(config) {
	var _config$arrowWidth = config.arrowWidth, arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth, _config$horizontalArr = config.horizontalArrowShift, horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr, _config$verticalArrow = config.verticalArrowShift, verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow, autoAdjustOverflow$2 = config.autoAdjustOverflow, arrowPointAtCenter = config.arrowPointAtCenter;
	var placementMap = {
		left: {
			points: ["cr", "cl"],
			offset: [-4, 0]
		},
		right: {
			points: ["cl", "cr"],
			offset: [4, 0]
		},
		top: {
			points: ["bc", "tc"],
			offset: [0, -4]
		},
		bottom: {
			points: ["tc", "bc"],
			offset: [0, 4]
		},
		topLeft: {
			points: ["bl", "tc"],
			offset: [-(horizontalArrowShift + arrowWidth), -4]
		},
		leftTop: {
			points: ["tr", "cl"],
			offset: [-4, -(verticalArrowShift + arrowWidth)]
		},
		topRight: {
			points: ["br", "tc"],
			offset: [horizontalArrowShift + arrowWidth, -4]
		},
		rightTop: {
			points: ["tl", "cr"],
			offset: [4, -(verticalArrowShift + arrowWidth)]
		},
		bottomRight: {
			points: ["tr", "bc"],
			offset: [horizontalArrowShift + arrowWidth, 4]
		},
		rightBottom: {
			points: ["bl", "cr"],
			offset: [4, verticalArrowShift + arrowWidth]
		},
		bottomLeft: {
			points: ["tl", "bc"],
			offset: [-(horizontalArrowShift + arrowWidth), 4]
		},
		leftBottom: {
			points: ["br", "cl"],
			offset: [-4, verticalArrowShift + arrowWidth]
		}
	};
	Object.keys(placementMap).forEach(function(key) {
		placementMap[key] = arrowPointAtCenter ? _objectSpread2(_objectSpread2({}, placementMap[key]), {}, {
			overflow: getOverflowOptions(autoAdjustOverflow$2),
			targetOffset
		}) : _objectSpread2(_objectSpread2({}, placements$1[key]), {}, { overflow: getOverflowOptions(autoAdjustOverflow$2) });
		placementMap[key].ignoreShake = true;
	});
	return placementMap;
}

//#endregion
//#region node_modules/ant-design-vue/es/_util/firstNotUndefined.js
function firstNotUndefined() {
	var arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
	for (var i = 0, len = arr.length; i < len; i++) if (arr[i] !== void 0) return arr[i];
}
var firstNotUndefined_default = firstNotUndefined;

//#endregion
//#region node_modules/ant-design-vue/es/tooltip/Tooltip.js
var splitObject = function splitObject$1(obj, keys$1) {
	var picked = {};
	var omitted = _objectSpread2({}, obj);
	keys$1.forEach(function(key) {
		if (obj && key in obj) {
			picked[key] = obj[key];
			delete omitted[key];
		}
	});
	return {
		picked,
		omitted
	};
};
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$"));
var tooltipProps = function tooltipProps$1() {
	return _objectSpread2(_objectSpread2({}, abstractTooltipProps_default()), {}, { title: vue_types_default.any });
};
var tooltipDefaultProps = function tooltipDefaultProps$1() {
	return {
		trigger: "hover",
		transitionName: "zoom-big-fast",
		align: {},
		placement: "top",
		mouseEnterDelay: .1,
		mouseLeaveDelay: .1,
		arrowPointAtCenter: false,
		autoAdjustOverflow: true
	};
};
var Tooltip_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "ATooltip",
	inheritAttrs: false,
	props: initDefaultProps_default(tooltipProps(), {
		trigger: "hover",
		transitionName: "zoom-big-fast",
		align: {},
		placement: "top",
		mouseEnterDelay: .1,
		mouseLeaveDelay: .1,
		arrowPointAtCenter: false,
		autoAdjustOverflow: true
	}),
	slots: ["title"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
		var _useConfigInject = useConfigInject_default("tooltip", props), prefixCls = _useConfigInject.prefixCls, getPopupContainer = _useConfigInject.getPopupContainer;
		var visible = ref(firstNotUndefined_default([props.visible, props.defaultVisible]));
		var tooltip = ref();
		onMounted(function() {
			warning_default(props.defaultVisible === void 0, "Tooltip", "'defaultVisible' is deprecated, please use 'v-model:visible'");
		});
		var rafId;
		watch(function() {
			return props.visible;
		}, function(val) {
			wrapperRaf.cancel(rafId);
			rafId = wrapperRaf(function() {
				visible.value = !!val;
			});
		});
		var isNoTitle = function isNoTitle$1() {
			var _props$title;
			var title = (_props$title = props.title) !== null && _props$title !== void 0 ? _props$title : slots.title;
			return !title && title !== 0;
		};
		var handleVisibleChange = function handleVisibleChange$1(val) {
			var noTitle = isNoTitle();
			if (props.visible === void 0) visible.value = noTitle ? false : val;
			if (!noTitle) {
				emit("update:visible", val);
				emit("visibleChange", val);
			}
		};
		expose({
			getPopupDomNode: function getPopupDomNode() {
				return tooltip.value.getPopupDomNode();
			},
			visible,
			forcePopupAlign: function forcePopupAlign() {
				var _tooltip$value;
				return (_tooltip$value = tooltip.value) === null || _tooltip$value === void 0 ? void 0 : _tooltip$value.forcePopupAlign();
			}
		});
		var tooltipPlacements = computed(function() {
			var builtinPlacements = props.builtinPlacements, arrowPointAtCenter = props.arrowPointAtCenter, autoAdjustOverflow$2 = props.autoAdjustOverflow;
			return builtinPlacements || getPlacements({
				arrowPointAtCenter,
				autoAdjustOverflow: autoAdjustOverflow$2
			});
		});
		var isTrueProps = function isTrueProps$1(val) {
			return val || val === "";
		};
		var getDisabledCompatibleChildren = function getDisabledCompatibleChildren$1(ele) {
			var elementType = ele.type;
			if (_typeof(elementType) === "object" && ele.props) {
				if ((elementType.__ANT_BUTTON === true || elementType === "button") && isTrueProps(ele.props.disabled) || elementType.__ANT_SWITCH === true && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading))) {
					var _splitObject = splitObject(getStyle(ele), [
						"position",
						"left",
						"right",
						"top",
						"bottom",
						"float",
						"display",
						"zIndex"
					]), picked = _splitObject.picked, omitted = _splitObject.omitted;
					var spanStyle = _objectSpread2(_objectSpread2({ display: "inline-block" }, picked), {}, {
						cursor: "not-allowed",
						lineHeight: 1,
						width: ele.props && ele.props.block ? "100%" : null
					});
					var child = cloneElement(ele, { style: _objectSpread2(_objectSpread2({}, omitted), {}, { pointerEvents: "none" }) }, true);
					return createVNode("span", {
						"style": spanStyle,
						"class": "".concat(prefixCls.value, "-disabled-compatible-wrapper")
					}, [child]);
				}
			}
			return ele;
		};
		var getOverlay = function getOverlay$1() {
			var _props$title2, _slots$title;
			return (_props$title2 = props.title) !== null && _props$title2 !== void 0 ? _props$title2 : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
		};
		var onPopupAlign = function onPopupAlign$1(domNode, align) {
			var placements$2 = tooltipPlacements.value;
			var placement = Object.keys(placements$2).filter(function(key) {
				return placements$2[key].points[0] === align.points[0] && placements$2[key].points[1] === align.points[1];
			})[0];
			if (!placement) return;
			var rect = domNode.getBoundingClientRect();
			var transformOrigin = {
				top: "50%",
				left: "50%"
			};
			if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
			else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) transformOrigin.top = "".concat(-align.offset[1], "px");
			if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
			else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) transformOrigin.left = "".concat(-align.offset[0], "px");
			domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
		};
		return function() {
			var _filterEmpty, _slots$default, _classNames;
			var openClassName = props.openClassName, color = props.color, overlayClassName = props.overlayClassName;
			var children = (_filterEmpty = filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))) !== null && _filterEmpty !== void 0 ? _filterEmpty : null;
			children = children.length === 1 ? children[0] : children;
			var tempVisible = visible.value;
			if (props.visible === void 0 && isNoTitle()) tempVisible = false;
			if (!children) return null;
			var child = getDisabledCompatibleChildren(isValidElement(children) ? children : createVNode("span", null, [children]));
			var childCls = classNames_default((_classNames = {}, _defineProperty(_classNames, openClassName || "".concat(prefixCls.value, "-open"), true), _defineProperty(_classNames, child.props && child.props.class, child.props && child.props.class), _classNames));
			var customOverlayClassName = classNames_default(overlayClassName, _defineProperty({}, "".concat(prefixCls.value, "-").concat(color), color && PresetColorRegex.test(color)));
			var formattedOverlayInnerStyle;
			var arrowContentStyle;
			if (color && !PresetColorRegex.test(color)) {
				formattedOverlayInnerStyle = { backgroundColor: color };
				arrowContentStyle = { backgroundColor: color };
			}
			return createVNode(vc_tooltip_default, _objectSpread2(_objectSpread2(_objectSpread2({}, attrs), props), {}, {
				prefixCls: prefixCls.value,
				getPopupContainer: getPopupContainer.value,
				builtinPlacements: tooltipPlacements.value,
				visible: tempVisible,
				ref: tooltip,
				overlayClassName: customOverlayClassName,
				overlayInnerStyle: formattedOverlayInnerStyle,
				onVisibleChange: handleVisibleChange,
				onPopupAlign
			}), {
				default: function _default() {
					return [visible.value ? cloneElement(child, { class: childCls }) : child];
				},
				arrowContent: function arrowContent() {
					return createVNode("span", {
						"class": "".concat(prefixCls.value, "-arrow-content"),
						"style": arrowContentStyle
					}, null);
				},
				overlay: getOverlay
			});
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/tooltip/index.js
var tooltip_default = withInstall(Tooltip_default);

//#endregion
//#region node_modules/ant-design-vue/es/_util/shallowequal.js
function shallowEqual(objA, objB, compare, compareContext) {
	var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
	if (ret !== void 0) return !!ret;
	if (objA === objB) return true;
	if (_typeof(objA) !== "object" || !objA || _typeof(objB) !== "object" || !objB) return false;
	var keysA = Object.keys(objA);
	var keysB = Object.keys(objB);
	if (keysA.length !== keysB.length) return false;
	var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
	for (var idx = 0; idx < keysA.length; idx++) {
		var key = keysA[idx];
		if (!bHasOwnProperty(key)) return false;
		var valueA = objA[key];
		var valueB = objB[key];
		ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
		if (ret === false || ret === void 0 && valueA !== valueB) return false;
	}
	return true;
}
function shallowequal_default(value, other, customizer, thisArg) {
	return shallowEqual(toRaw(value), toRaw(other), customizer, thisArg);
}

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/hooks/useMenuContext.js
var MenuContextKey = Symbol("menuContextKey");
var useProvideMenu = function useProvideMenu$1(props) {
	provide(MenuContextKey, props);
};
var useInjectMenu = function useInjectMenu$1() {
	return inject(MenuContextKey);
};
var ForceRenderKey = Symbol("ForceRenderKey");
var useProvideForceRender = function useProvideForceRender$1(forceRender) {
	provide(ForceRenderKey, forceRender);
};
var useInjectForceRender = function useInjectForceRender$1() {
	return inject(ForceRenderKey, false);
};
var MenuFirstLevelContextKey = Symbol("menuFirstLevelContextKey");
var useProvideFirstLevel = function useProvideFirstLevel$1(firstLevel) {
	provide(MenuFirstLevelContextKey, firstLevel);
};
var useInjectFirstLevel = function useInjectFirstLevel$1() {
	return inject(MenuFirstLevelContextKey, true);
};
var MenuContextProvider = defineComponent({
	compatConfig: { MODE: 3 },
	name: "MenuContextProvider",
	inheritAttrs: false,
	props: {
		mode: {
			type: String,
			default: void 0
		},
		overflowDisabled: {
			type: Boolean,
			default: void 0
		},
		isRootMenu: {
			type: Boolean,
			default: void 0
		}
	},
	setup: function setup(props, _ref) {
		var slots = _ref.slots;
		var newContext = _objectSpread2({}, useInjectMenu());
		if (props.mode !== void 0) newContext.mode = toRef(props, "mode");
		if (props.isRootMenu !== void 0) newContext.isRootMenu = toRef(props, "isRootMenu");
		if (props.overflowDisabled !== void 0) newContext.overflowDisabled = toRef(props, "overflowDisabled");
		useProvideMenu(newContext);
		return function() {
			var _slots$default;
			return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
		};
	}
});
var useMenuContext_default = useProvideMenu;

//#endregion
//#region node_modules/lodash-es/_baseFindIndex.js
/**
* The base implementation of `_.findIndex` and `_.findLastIndex` without
* support for iteratee shorthands.
*
* @private
* @param {Array} array The array to inspect.
* @param {Function} predicate The function invoked per iteration.
* @param {number} fromIndex The index to search from.
* @param {boolean} [fromRight] Specify iterating from right to left.
* @returns {number} Returns the index of the matched value, else `-1`.
*/
function baseFindIndex(array, predicate, fromIndex, fromRight) {
	var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
	while (fromRight ? index-- : ++index < length) if (predicate(array[index], index, array)) return index;
	return -1;
}
var _baseFindIndex_default = baseFindIndex;

//#endregion
//#region node_modules/lodash-es/_baseIsNaN.js
/**
* The base implementation of `_.isNaN` without support for number objects.
*
* @private
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
*/
function baseIsNaN(value) {
	return value !== value;
}
var _baseIsNaN_default = baseIsNaN;

//#endregion
//#region node_modules/lodash-es/_strictIndexOf.js
/**
* A specialized version of `_.indexOf` which performs strict equality
* comparisons of values, i.e. `===`.
*
* @private
* @param {Array} array The array to inspect.
* @param {*} value The value to search for.
* @param {number} fromIndex The index to search from.
* @returns {number} Returns the index of the matched value, else `-1`.
*/
function strictIndexOf(array, value, fromIndex) {
	var index = fromIndex - 1, length = array.length;
	while (++index < length) if (array[index] === value) return index;
	return -1;
}
var _strictIndexOf_default = strictIndexOf;

//#endregion
//#region node_modules/lodash-es/_baseIndexOf.js
/**
* The base implementation of `_.indexOf` without `fromIndex` bounds checks.
*
* @private
* @param {Array} array The array to inspect.
* @param {*} value The value to search for.
* @param {number} fromIndex The index to search from.
* @returns {number} Returns the index of the matched value, else `-1`.
*/
function baseIndexOf(array, value, fromIndex) {
	return value === value ? _strictIndexOf_default(array, value, fromIndex) : _baseFindIndex_default(array, _baseIsNaN_default, fromIndex);
}
var _baseIndexOf_default = baseIndexOf;

//#endregion
//#region node_modules/lodash-es/_arrayIncludes.js
/**
* A specialized version of `_.includes` for arrays without support for
* specifying an index to search from.
*
* @private
* @param {Array} [array] The array to inspect.
* @param {*} target The value to search for.
* @returns {boolean} Returns `true` if `target` is found, else `false`.
*/
function arrayIncludes(array, value) {
	return !!(array == null ? 0 : array.length) && _baseIndexOf_default(array, value, 0) > -1;
}
var _arrayIncludes_default = arrayIncludes;

//#endregion
//#region node_modules/lodash-es/_arrayIncludesWith.js
/**
* This function is like `arrayIncludes` except that it accepts a comparator.
*
* @private
* @param {Array} [array] The array to inspect.
* @param {*} target The value to search for.
* @param {Function} comparator The comparator invoked per element.
* @returns {boolean} Returns `true` if `target` is found, else `false`.
*/
function arrayIncludesWith(array, value, comparator) {
	var index = -1, length = array == null ? 0 : array.length;
	while (++index < length) if (comparator(value, array[index])) return true;
	return false;
}
var _arrayIncludesWith_default = arrayIncludesWith;

//#endregion
//#region node_modules/lodash-es/noop.js
/**
* This method returns `undefined`.
*
* @static
* @memberOf _
* @since 2.3.0
* @category Util
* @example
*
* _.times(2, _.noop);
* // => [undefined, undefined]
*/
function noop() {}
var noop_default = noop;

//#endregion
//#region node_modules/lodash-es/_createSet.js
/**
* Creates a set object of `values`.
*
* @private
* @param {Array} values The values to add to the set.
* @returns {Object} Returns the new set.
*/
var createSet = !(_Set_default && 1 / _setToArray_default(new _Set_default([, -0]))[1] == Infinity) ? noop_default : function(values) {
	return new _Set_default(values);
};
var _createSet_default = createSet;

//#endregion
//#region node_modules/lodash-es/_baseUniq.js
/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;
/**
* The base implementation of `_.uniqBy` without support for iteratee shorthands.
*
* @private
* @param {Array} array The array to inspect.
* @param {Function} [iteratee] The iteratee invoked per element.
* @param {Function} [comparator] The comparator invoked per element.
* @returns {Array} Returns the new duplicate free array.
*/
function baseUniq(array, iteratee, comparator) {
	var index = -1, includes = _arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;
	if (comparator) {
		isCommon = false;
		includes = _arrayIncludesWith_default;
	} else if (length >= LARGE_ARRAY_SIZE) {
		var set = iteratee ? null : _createSet_default(array);
		if (set) return _setToArray_default(set);
		isCommon = false;
		includes = _cacheHas_default;
		seen = new _SetCache_default();
	} else seen = iteratee ? [] : result;
	outer: while (++index < length) {
		var value = array[index], computed$1 = iteratee ? iteratee(value) : value;
		value = comparator || value !== 0 ? value : 0;
		if (isCommon && computed$1 === computed$1) {
			var seenIndex = seen.length;
			while (seenIndex--) if (seen[seenIndex] === computed$1) continue outer;
			if (iteratee) seen.push(computed$1);
			result.push(value);
		} else if (!includes(seen, computed$1, comparator)) {
			if (seen !== result) seen.push(computed$1);
			result.push(value);
		}
	}
	return result;
}
var _baseUniq_default = baseUniq;

//#endregion
//#region node_modules/lodash-es/uniq.js
/**
* Creates a duplicate-free version of an array, using
* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
* for equality comparisons, in which only the first occurrence of each element
* is kept. The order of result values is determined by the order they occur
* in the array.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Array
* @param {Array} array The array to inspect.
* @returns {Array} Returns the new duplicate free array.
* @example
*
* _.uniq([2, 1, 2]);
* // => [2, 1]
*/
function uniq(array) {
	return array && array.length ? _baseUniq_default(array) : [];
}
var uniq_default = uniq;

//#endregion
//#region node_modules/ant-design-vue/es/layout/injectionKey.js
var SiderCollapsedKey = Symbol("siderCollapsed");
var SiderHookProviderKey = Symbol("siderHookProvider");

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/hooks/useKeyPath.js
var OVERFLOW_KEY = "$$__vc-menu-more__key";
var KeyPathContext = Symbol("KeyPathContext");
var useInjectKeyPath = function useInjectKeyPath$1() {
	return inject(KeyPathContext, {
		parentEventKeys: computed(function() {
			return [];
		}),
		parentKeys: computed(function() {
			return [];
		}),
		parentInfo: {}
	});
};
var useProvideKeyPath = function useProvideKeyPath$1(eventKey, key, menuInfo) {
	var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentKeys = _useInjectKeyPath.parentKeys;
	var eventKeys = computed(function() {
		return [].concat(_toConsumableArray(parentEventKeys.value), [eventKey]);
	});
	var keys$1 = computed(function() {
		return [].concat(_toConsumableArray(parentKeys.value), [key]);
	});
	provide(KeyPathContext, {
		parentEventKeys: eventKeys,
		parentKeys: keys$1,
		parentInfo: menuInfo
	});
	return keys$1;
};
var measure = Symbol("measure");
var PathContext = defineComponent({
	compatConfig: { MODE: 3 },
	setup: function setup(_props, _ref) {
		var slots = _ref.slots;
		provide(measure, true);
		return function() {
			var _slots$default;
			return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
		};
	}
});
var useMeasure = function useMeasure$1() {
	return inject(measure, false);
};
var useKeyPath_default = useProvideKeyPath;

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/hooks/useDirectionStyle.js
function useDirectionStyle(level) {
	var _useInjectMenu = useInjectMenu(), mode = _useInjectMenu.mode, rtl = _useInjectMenu.rtl, inlineIndent = _useInjectMenu.inlineIndent;
	return computed(function() {
		return mode.value !== "inline" ? null : rtl.value ? { paddingRight: "".concat(level.value * inlineIndent.value, "px") } : { paddingLeft: "".concat(level.value * inlineIndent.value, "px") };
	});
}

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/MenuItem.js
var indexGuid$1 = 0;
var menuItemProps = function menuItemProps$1() {
	return {
		id: String,
		role: String,
		disabled: Boolean,
		danger: Boolean,
		title: {
			type: [String, Boolean],
			default: void 0
		},
		icon: vue_types_default.any,
		onMouseenter: Function,
		onMouseleave: Function,
		onClick: Function,
		onKeydown: Function,
		onFocus: Function
	};
};
var MenuItem_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "AMenuItem",
	inheritAttrs: false,
	props: menuItemProps(),
	slots: ["icon", "title"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
		var instance = getCurrentInstance();
		var isMeasure = useMeasure();
		var key = _typeof(instance.vnode.key) === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
		devWarning_default(_typeof(instance.vnode.key) !== "symbol", "MenuItem", "MenuItem `:key=\"".concat(String(key), "\"` not support Symbol type"));
		var eventKey = "menu_item_".concat(++indexGuid$1, "_$$_").concat(key);
		var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentKeys = _useInjectKeyPath.parentKeys;
		var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, activeKeys = _useInjectMenu.activeKeys, disabled = _useInjectMenu.disabled, changeActiveKeys = _useInjectMenu.changeActiveKeys, rtl = _useInjectMenu.rtl, inlineCollapsed = _useInjectMenu.inlineCollapsed, siderCollapsed = _useInjectMenu.siderCollapsed, onItemClick = _useInjectMenu.onItemClick, selectedKeys = _useInjectMenu.selectedKeys, registerMenuInfo = _useInjectMenu.registerMenuInfo, unRegisterMenuInfo = _useInjectMenu.unRegisterMenuInfo;
		var firstLevel = useInjectFirstLevel();
		var isActive = ref(false);
		var keysPath = computed(function() {
			return [].concat(_toConsumableArray(parentKeys.value), [key]);
		});
		registerMenuInfo(eventKey, {
			eventKey,
			key,
			parentEventKeys,
			parentKeys,
			isLeaf: true
		});
		onBeforeUnmount(function() {
			unRegisterMenuInfo(eventKey);
		});
		watch(activeKeys, function() {
			isActive.value = !!activeKeys.value.find(function(val) {
				return val === key;
			});
		}, { immediate: true });
		var mergedDisabled = computed(function() {
			return disabled.value || props.disabled;
		});
		var selected = computed(function() {
			return selectedKeys.value.includes(key);
		});
		var classNames = computed(function() {
			var _ref2;
			var itemCls = "".concat(prefixCls.value, "-item");
			return _ref2 = {}, _defineProperty(_ref2, "".concat(itemCls), true), _defineProperty(_ref2, "".concat(itemCls, "-danger"), props.danger), _defineProperty(_ref2, "".concat(itemCls, "-active"), isActive.value), _defineProperty(_ref2, "".concat(itemCls, "-selected"), selected.value), _defineProperty(_ref2, "".concat(itemCls, "-disabled"), mergedDisabled.value), _ref2;
		});
		var getEventInfo = function getEventInfo$1(e) {
			return {
				key,
				eventKey,
				keyPath: keysPath.value,
				eventKeyPath: [].concat(_toConsumableArray(parentEventKeys.value), [eventKey]),
				domEvent: e,
				item: _objectSpread2(_objectSpread2({}, props), attrs)
			};
		};
		var onInternalClick = function onInternalClick$1(e) {
			if (mergedDisabled.value) return;
			var info = getEventInfo(e);
			emit("click", e);
			onItemClick(info);
		};
		var onMouseEnter = function onMouseEnter$1(event) {
			if (!mergedDisabled.value) {
				changeActiveKeys(keysPath.value);
				emit("mouseenter", event);
			}
		};
		var onMouseLeave = function onMouseLeave$1(event) {
			if (!mergedDisabled.value) {
				changeActiveKeys([]);
				emit("mouseleave", event);
			}
		};
		var onInternalKeyDown = function onInternalKeyDown$1(e) {
			emit("keydown", e);
			if (e.which === KeyCode_default.ENTER) {
				var info = getEventInfo(e);
				emit("click", e);
				onItemClick(info);
			}
		};
		/**
		* Used for accessibility. Helper will focus element without key board.
		* We should manually trigger an active
		*/
		var onInternalFocus = function onInternalFocus$1(e) {
			changeActiveKeys(keysPath.value);
			emit("focus", e);
		};
		var renderItemChildren = function renderItemChildren$1(icon, children) {
			var wrapNode = createVNode("span", { "class": "".concat(prefixCls.value, "-title-content") }, [children]);
			if (!icon || isValidElement(children) && children.type === "span") {
				if (children && inlineCollapsed.value && firstLevel && typeof children === "string") return createVNode("div", { "class": "".concat(prefixCls.value, "-inline-collapsed-noicon") }, [children.charAt(0)]);
			}
			return wrapNode;
		};
		var directionStyle = useDirectionStyle(computed(function() {
			return keysPath.value.length;
		}));
		return function() {
			var _props$title, _slots$title, _slots$default, _ref3;
			if (isMeasure) return null;
			var title = (_props$title = props.title) !== null && _props$title !== void 0 ? _props$title : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
			var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
			var childrenLength = children.length;
			var tooltipTitle = title;
			if (typeof title === "undefined") tooltipTitle = firstLevel && childrenLength ? children : "";
			else if (title === false) tooltipTitle = "";
			var tooltipProps$1 = { title: tooltipTitle };
			if (!siderCollapsed.value && !inlineCollapsed.value) {
				tooltipProps$1.title = null;
				tooltipProps$1.visible = false;
			}
			var optionRoleProps = {};
			if (props.role === "option") optionRoleProps["aria-selected"] = selected.value;
			var icon = getPropsSlot(slots, props, "icon");
			return createVNode(tooltip_default, _objectSpread2(_objectSpread2({}, tooltipProps$1), {}, {
				"placement": rtl.value ? "left" : "right",
				"overlayClassName": "".concat(prefixCls.value, "-inline-collapsed-tooltip")
			}), { default: function _default() {
				return [createVNode(vc_overflow_default.Item, _objectSpread2(_objectSpread2(_objectSpread2({ "component": "li" }, attrs), {}, {
					"id": props.id,
					"style": _objectSpread2(_objectSpread2({}, attrs.style || {}), directionStyle.value),
					"class": [classNames.value, (_ref3 = {}, _defineProperty(_ref3, "".concat(attrs.class), !!attrs.class), _defineProperty(_ref3, "".concat(prefixCls.value, "-item-only-child"), (icon ? childrenLength + 1 : childrenLength) === 1), _ref3)],
					"role": props.role || "menuitem",
					"tabindex": props.disabled ? null : -1,
					"data-menu-id": key,
					"aria-disabled": props.disabled
				}, optionRoleProps), {}, {
					"onMouseenter": onMouseEnter,
					"onMouseleave": onMouseLeave,
					"onClick": onInternalClick,
					"onKeydown": onInternalKeyDown,
					"onFocus": onInternalFocus,
					"title": typeof title === "string" ? title : void 0
				}), { default: function _default$1() {
					return [cloneElement(icon, { class: "".concat(prefixCls.value, "-item-icon") }, false), renderItemChildren(icon, children)];
				} })];
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/placements.js
var autoAdjustOverflow = {
	adjustX: 1,
	adjustY: 1
};
var placements = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow,
		offset: [0, -7]
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow,
		offset: [0, 7]
	},
	leftTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflow,
		offset: [-4, 0]
	},
	rightTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflow,
		offset: [4, 0]
	}
};
var placementsRtl = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow,
		offset: [0, -7]
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow,
		offset: [0, 7]
	},
	rightTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflow,
		offset: [-4, 0]
	},
	leftTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflow,
		offset: [4, 0]
	}
};

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/PopupTrigger.js
var popupPlacementMap = {
	horizontal: "bottomLeft",
	vertical: "rightTop",
	"vertical-left": "rightTop",
	"vertical-right": "leftTop"
};
var PopupTrigger_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "PopupTrigger",
	inheritAttrs: false,
	props: {
		prefixCls: String,
		mode: String,
		visible: Boolean,
		popupClassName: String,
		popupOffset: Array,
		disabled: Boolean,
		onVisibleChange: Function
	},
	slots: ["popup"],
	emits: ["visibleChange"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots, emit = _ref.emit;
		var innerVisible = ref(false);
		var _useInjectMenu = useInjectMenu(), getPopupContainer = _useInjectMenu.getPopupContainer, rtl = _useInjectMenu.rtl, subMenuOpenDelay = _useInjectMenu.subMenuOpenDelay, subMenuCloseDelay = _useInjectMenu.subMenuCloseDelay, builtinPlacements = _useInjectMenu.builtinPlacements, triggerSubMenuAction = _useInjectMenu.triggerSubMenuAction, isRootMenu = _useInjectMenu.isRootMenu, forceSubMenuRender = _useInjectMenu.forceSubMenuRender, motion = _useInjectMenu.motion, defaultMotions = _useInjectMenu.defaultMotions;
		var forceRender = useInjectForceRender();
		var placement = computed(function() {
			return rtl.value ? _objectSpread2(_objectSpread2({}, placementsRtl), builtinPlacements.value) : _objectSpread2(_objectSpread2({}, placements), builtinPlacements.value);
		});
		var popupPlacement = computed(function() {
			return popupPlacementMap[props.mode];
		});
		var visibleRef = ref();
		watch(function() {
			return props.visible;
		}, function(visible) {
			wrapperRaf.cancel(visibleRef.value);
			visibleRef.value = wrapperRaf(function() {
				innerVisible.value = visible;
			});
		}, { immediate: true });
		onBeforeUnmount(function() {
			wrapperRaf.cancel(visibleRef.value);
		});
		var onVisibleChange = function onVisibleChange$1(visible) {
			emit("visibleChange", visible);
		};
		var mergedMotion = computed(function() {
			var _defaultMotions$value, _defaultMotions$value2;
			var m = motion.value || ((_defaultMotions$value = defaultMotions.value) === null || _defaultMotions$value === void 0 ? void 0 : _defaultMotions$value[props.mode]) || ((_defaultMotions$value2 = defaultMotions.value) === null || _defaultMotions$value2 === void 0 ? void 0 : _defaultMotions$value2.other);
			var res = typeof m === "function" ? m() : m;
			return res ? getTransitionProps(res.name, { css: true }) : void 0;
		});
		return function() {
			var prefixCls = props.prefixCls, popupClassName = props.popupClassName, mode = props.mode, popupOffset = props.popupOffset, disabled = props.disabled;
			return createVNode(vc_trigger_default, {
				"prefixCls": prefixCls,
				"popupClassName": classNames_default("".concat(prefixCls, "-popup"), _defineProperty({}, "".concat(prefixCls, "-rtl"), rtl.value), popupClassName),
				"stretch": mode === "horizontal" ? "minWidth" : null,
				"getPopupContainer": isRootMenu.value ? getPopupContainer.value : function(triggerNode) {
					return triggerNode.parentNode;
				},
				"builtinPlacements": placement.value,
				"popupPlacement": popupPlacement.value,
				"popupVisible": innerVisible.value,
				"popupAlign": popupOffset && { offset: popupOffset },
				"action": disabled ? [] : [triggerSubMenuAction.value],
				"mouseEnterDelay": subMenuOpenDelay.value,
				"mouseLeaveDelay": subMenuCloseDelay.value,
				"onPopupVisibleChange": onVisibleChange,
				"forceRender": forceRender || forceSubMenuRender.value,
				"popupAnimation": mergedMotion.value
			}, {
				popup: slots.popup,
				default: slots.default
			});
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/SubMenuList.js
var InternalSubMenuList = function InternalSubMenuList$1(_props, _ref) {
	var _slots$default;
	var slots = _ref.slots, attrs = _ref.attrs;
	var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, mode = _useInjectMenu.mode;
	return createVNode("ul", _objectSpread2(_objectSpread2({}, attrs), {}, {
		"class": classNames_default(prefixCls.value, "".concat(prefixCls.value, "-sub"), "".concat(prefixCls.value, "-").concat(mode.value === "inline" ? "inline" : "vertical")),
		"data-menu-list": true
	}), [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
};
InternalSubMenuList.displayName = "SubMenuList";
var SubMenuList_default = InternalSubMenuList;

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/InlineSubMenuList.js
var InlineSubMenuList_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "InlineSubMenuList",
	inheritAttrs: false,
	props: {
		id: String,
		open: Boolean,
		keyPath: Array
	},
	setup: function setup(props, _ref) {
		var slots = _ref.slots;
		var fixedMode = computed(function() {
			return "inline";
		});
		var _useInjectMenu = useInjectMenu(), motion = _useInjectMenu.motion, mode = _useInjectMenu.mode, defaultMotions = _useInjectMenu.defaultMotions;
		var sameModeRef = computed(function() {
			return mode.value === fixedMode.value;
		});
		var destroy = ref(!sameModeRef.value);
		var mergedOpen = computed(function() {
			return sameModeRef.value ? props.open : false;
		});
		watch(mode, function() {
			if (sameModeRef.value) destroy.value = false;
		}, { flush: "post" });
		var mergedMotion = computed(function() {
			var _defaultMotions$value, _defaultMotions$value2;
			var m = motion.value || ((_defaultMotions$value = defaultMotions.value) === null || _defaultMotions$value === void 0 ? void 0 : _defaultMotions$value[fixedMode.value]) || ((_defaultMotions$value2 = defaultMotions.value) === null || _defaultMotions$value2 === void 0 ? void 0 : _defaultMotions$value2.other);
			return _objectSpread2(_objectSpread2({}, typeof m === "function" ? m() : m), {}, { appear: props.keyPath.length <= 1 });
		});
		return function() {
			var _slots$default;
			if (destroy.value) return null;
			return createVNode(MenuContextProvider, { "mode": fixedMode.value }, { default: function _default() {
				return [createVNode(transition_default, mergedMotion.value, { default: function _default$1() {
					return [withDirectives(createVNode(SubMenuList_default, { "id": props.id }, { default: function _default$2() {
						return [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
					} }), [[vShow, mergedOpen.value]])];
				} })];
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/SubMenu.js
var indexGuid = 0;
var subMenuProps = function subMenuProps$1() {
	return {
		icon: vue_types_default.any,
		title: vue_types_default.any,
		disabled: Boolean,
		level: Number,
		popupClassName: String,
		popupOffset: Array,
		internalPopupClose: Boolean,
		eventKey: String,
		expandIcon: Function,
		onMouseenter: Function,
		onMouseleave: Function,
		onTitleClick: Function
	};
};
var SubMenu_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "ASubMenu",
	inheritAttrs: false,
	props: subMenuProps(),
	slots: [
		"icon",
		"title",
		"expandIcon"
	],
	setup: function setup(props, _ref) {
		var _props$eventKey, _parentInfo$childrenE;
		var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
		useProvideFirstLevel(false);
		var isMeasure = useMeasure();
		var instance = getCurrentInstance();
		var vnodeKey = _typeof(instance.vnode.key) === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
		devWarning_default(_typeof(instance.vnode.key) !== "symbol", "SubMenu", "SubMenu `:key=\"".concat(String(vnodeKey), "\"` not support Symbol type"));
		var key = isValid_default(vnodeKey) ? vnodeKey : "sub_menu_".concat(++indexGuid, "_$$_not_set_key");
		var eventKey = (_props$eventKey = props.eventKey) !== null && _props$eventKey !== void 0 ? _props$eventKey : isValid_default(vnodeKey) ? "sub_menu_".concat(++indexGuid, "_$$_").concat(vnodeKey) : key;
		var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentInfo = _useInjectKeyPath.parentInfo, parentKeys = _useInjectKeyPath.parentKeys;
		var keysPath = computed(function() {
			return [].concat(_toConsumableArray(parentKeys.value), [key]);
		});
		var menuInfo = {
			eventKey,
			key,
			parentEventKeys,
			childrenEventKeys: ref([]),
			parentKeys
		};
		(_parentInfo$childrenE = parentInfo.childrenEventKeys) === null || _parentInfo$childrenE === void 0 || _parentInfo$childrenE.value.push(eventKey);
		onBeforeUnmount(function() {
			if (parentInfo.childrenEventKeys) {
				var _parentInfo$childrenE2;
				parentInfo.childrenEventKeys.value = (_parentInfo$childrenE2 = parentInfo.childrenEventKeys) === null || _parentInfo$childrenE2 === void 0 ? void 0 : _parentInfo$childrenE2.value.filter(function(k) {
					return k != eventKey;
				});
			}
		});
		useKeyPath_default(eventKey, key, menuInfo);
		var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, activeKeys = _useInjectMenu.activeKeys, contextDisabled = _useInjectMenu.disabled, changeActiveKeys = _useInjectMenu.changeActiveKeys, mode = _useInjectMenu.mode, inlineCollapsed = _useInjectMenu.inlineCollapsed, antdMenuTheme = _useInjectMenu.antdMenuTheme, openKeys = _useInjectMenu.openKeys, overflowDisabled = _useInjectMenu.overflowDisabled, onOpenChange = _useInjectMenu.onOpenChange, registerMenuInfo = _useInjectMenu.registerMenuInfo, unRegisterMenuInfo = _useInjectMenu.unRegisterMenuInfo, selectedSubMenuKeys = _useInjectMenu.selectedSubMenuKeys, menuExpandIcon = _useInjectMenu.expandIcon;
		var hasKey = vnodeKey !== void 0 && vnodeKey !== null;
		var forceRender = !isMeasure && (useInjectForceRender() || !hasKey);
		useProvideForceRender(forceRender);
		if (isMeasure && hasKey || !isMeasure && !hasKey || forceRender) {
			registerMenuInfo(eventKey, menuInfo);
			onBeforeUnmount(function() {
				unRegisterMenuInfo(eventKey);
			});
		}
		var subMenuPrefixCls = computed(function() {
			return "".concat(prefixCls.value, "-submenu");
		});
		var mergedDisabled = computed(function() {
			return contextDisabled.value || props.disabled;
		});
		var elementRef = ref();
		var popupRef = ref();
		var originOpen = computed(function() {
			return openKeys.value.includes(key);
		});
		var open = computed(function() {
			return !overflowDisabled.value && originOpen.value;
		});
		var childrenSelected = computed(function() {
			return selectedSubMenuKeys.value.includes(key);
		});
		var isActive = ref(false);
		watch(activeKeys, function() {
			isActive.value = !!activeKeys.value.find(function(val) {
				return val === key;
			});
		}, { immediate: true });
		var onInternalTitleClick = function onInternalTitleClick$1(e) {
			if (mergedDisabled.value) return;
			emit("titleClick", e, key);
			if (mode.value === "inline") onOpenChange(key, !originOpen.value);
		};
		var onMouseEnter = function onMouseEnter$1(event) {
			if (!mergedDisabled.value) {
				changeActiveKeys(keysPath.value);
				emit("mouseenter", event);
			}
		};
		var onMouseLeave = function onMouseLeave$1(event) {
			if (!mergedDisabled.value) {
				changeActiveKeys([]);
				emit("mouseleave", event);
			}
		};
		var directionStyle = useDirectionStyle(computed(function() {
			return keysPath.value.length;
		}));
		var onPopupVisibleChange = function onPopupVisibleChange$1(newVisible) {
			if (mode.value !== "inline") onOpenChange(key, newVisible);
		};
		/**
		* Used for accessibility. Helper will focus element without key board.
		* We should manually trigger an active
		*/
		var onInternalFocus = function onInternalFocus$1() {
			changeActiveKeys(keysPath.value);
		};
		var popupId = eventKey && "".concat(eventKey, "-popup");
		var popupClassName = computed(function() {
			return classNames_default(prefixCls.value, "".concat(prefixCls.value, "-").concat(antdMenuTheme.value), props.popupClassName);
		});
		var renderTitle = function renderTitle$1(title, icon) {
			if (!icon) return inlineCollapsed.value && !parentKeys.value.length && title && typeof title === "string" ? createVNode("div", { "class": "".concat(prefixCls.value, "-inline-collapsed-noicon") }, [title.charAt(0)]) : createVNode("span", { "class": "".concat(prefixCls.value, "-title-content") }, [title]);
			var titleIsSpan = isValidElement(title) && title.type === "span";
			return createVNode(Fragment, null, [cloneElement(icon, { class: "".concat(prefixCls.value, "-item-icon") }, false), titleIsSpan ? title : createVNode("span", { "class": "".concat(prefixCls.value, "-title-content") }, [title])]);
		};
		var triggerModeRef = computed(function() {
			return mode.value !== "inline" && keysPath.value.length > 1 ? "vertical" : mode.value;
		});
		var renderMode = computed(function() {
			return mode.value === "horizontal" ? "vertical" : mode.value;
		});
		var subMenuTriggerModeRef = computed(function() {
			return triggerModeRef.value === "horizontal" ? "vertical" : triggerModeRef.value;
		});
		var baseTitleNode = function baseTitleNode$1() {
			var subMenuPrefixClsValue = subMenuPrefixCls.value;
			var icon = getPropsSlot(slots, props, "icon");
			var expandIcon = props.expandIcon || slots.expandIcon || menuExpandIcon.value;
			var title = renderTitle(getPropsSlot(slots, props, "title"), icon);
			return createVNode("div", {
				"style": directionStyle.value,
				"class": "".concat(subMenuPrefixClsValue, "-title"),
				"tabindex": mergedDisabled.value ? null : -1,
				"ref": elementRef,
				"title": typeof title === "string" ? title : null,
				"data-menu-id": key,
				"aria-expanded": open.value,
				"aria-haspopup": true,
				"aria-controls": popupId,
				"aria-disabled": mergedDisabled.value,
				"onClick": onInternalTitleClick,
				"onFocus": onInternalFocus
			}, [title, mode.value !== "horizontal" && expandIcon ? expandIcon(_objectSpread2(_objectSpread2({}, props), {}, { isOpen: open.value })) : createVNode("i", { "class": "".concat(subMenuPrefixClsValue, "-arrow") }, null)]);
		};
		return function() {
			var _classNames;
			if (isMeasure) {
				var _slots$default;
				if (!hasKey) return null;
				return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
			}
			var subMenuPrefixClsValue = subMenuPrefixCls.value;
			var titleNode = function titleNode$1() {
				return null;
			};
			if (!overflowDisabled.value && mode.value !== "inline") titleNode = function titleNode$1() {
				return createVNode(PopupTrigger_default, {
					"mode": triggerModeRef.value,
					"prefixCls": subMenuPrefixClsValue,
					"visible": !props.internalPopupClose && open.value,
					"popupClassName": popupClassName.value,
					"popupOffset": props.popupOffset,
					"disabled": mergedDisabled.value,
					"onVisibleChange": onPopupVisibleChange
				}, {
					default: function _default() {
						return [baseTitleNode()];
					},
					popup: function popup() {
						return createVNode(MenuContextProvider, {
							"mode": subMenuTriggerModeRef.value,
							"isRootMenu": false
						}, { default: function _default() {
							return [createVNode(SubMenuList_default, {
								"id": popupId,
								"ref": popupRef
							}, { default: slots.default })];
						} });
					}
				});
			};
			else titleNode = function titleNode$1() {
				return createVNode(PopupTrigger_default, null, { default: baseTitleNode });
			};
			return createVNode(MenuContextProvider, { "mode": renderMode.value }, { default: function _default() {
				return [createVNode(vc_overflow_default.Item, _objectSpread2(_objectSpread2({ "component": "li" }, attrs), {}, {
					"role": "none",
					"class": classNames_default(subMenuPrefixClsValue, "".concat(subMenuPrefixClsValue, "-").concat(mode.value), attrs.class, (_classNames = {}, _defineProperty(_classNames, "".concat(subMenuPrefixClsValue, "-open"), open.value), _defineProperty(_classNames, "".concat(subMenuPrefixClsValue, "-active"), isActive.value), _defineProperty(_classNames, "".concat(subMenuPrefixClsValue, "-selected"), childrenSelected.value), _defineProperty(_classNames, "".concat(subMenuPrefixClsValue, "-disabled"), mergedDisabled.value), _classNames)),
					"onMouseenter": onMouseEnter,
					"onMouseleave": onMouseLeave,
					"data-submenu-id": key
				}), { default: function _default$1() {
					return createVNode(Fragment, null, [titleNode(), !overflowDisabled.value && createVNode(InlineSubMenuList_default, {
						"id": popupId,
						"open": open.value,
						"keyPath": keysPath.value
					}, { default: slots.default })]);
				} })];
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/vc-util/Dom/class.js
function hasClass(node, className) {
	if (node.classList) return node.classList.contains(className);
	var originClass = node.className;
	return " ".concat(originClass, " ").indexOf(" ".concat(className, " ")) > -1;
}
function addClass(node, className) {
	if (node.classList) node.classList.add(className);
	else if (!hasClass(node, className)) node.className = "".concat(node.className, " ").concat(className);
}
function removeClass(node, className) {
	if (node.classList) node.classList.remove(className);
	else if (hasClass(node, className)) {
		var originClass = node.className;
		node.className = " ".concat(originClass, " ").replace(" ".concat(className, " "), " ");
	}
}

//#endregion
//#region node_modules/ant-design-vue/es/_util/collapseMotion.js
var collapseMotion = function collapseMotion$1() {
	var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse";
	return {
		name,
		appear: arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true,
		css: true,
		onBeforeEnter: function onBeforeEnter(node) {
			node.style.height = "0px";
			node.style.opacity = "0";
			addClass(node, name);
		},
		onEnter: function onEnter(node) {
			nextTick(function() {
				node.style.height = "".concat(node.scrollHeight, "px");
				node.style.opacity = "1";
			});
		},
		onAfterEnter: function onAfterEnter(node) {
			if (node) {
				removeClass(node, name);
				node.style.height = null;
				node.style.opacity = null;
			}
		},
		onBeforeLeave: function onBeforeLeave(node) {
			addClass(node, name);
			node.style.height = "".concat(node.offsetHeight, "px");
			node.style.opacity = null;
		},
		onLeave: function onLeave(node) {
			setTimeout(function() {
				node.style.height = "0px";
				node.style.opacity = "0";
			});
		},
		onAfterLeave: function onAfterLeave(node) {
			if (node) {
				removeClass(node, name);
				if (node.style) {
					node.style.height = null;
					node.style.opacity = null;
				}
			}
		}
	};
};
var collapseMotion_default = collapseMotion;

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/Menu.js
var menuProps = function menuProps$1() {
	return {
		id: String,
		prefixCls: String,
		disabled: Boolean,
		inlineCollapsed: Boolean,
		disabledOverflow: Boolean,
		forceSubMenuRender: Boolean,
		openKeys: Array,
		selectedKeys: Array,
		activeKey: String,
		selectable: {
			type: Boolean,
			default: true
		},
		multiple: {
			type: Boolean,
			default: false
		},
		motion: Object,
		theme: {
			type: String,
			default: "light"
		},
		mode: {
			type: String,
			default: "vertical"
		},
		inlineIndent: {
			type: Number,
			default: 24
		},
		subMenuOpenDelay: {
			type: Number,
			default: .1
		},
		subMenuCloseDelay: {
			type: Number,
			default: .1
		},
		builtinPlacements: { type: Object },
		triggerSubMenuAction: {
			type: String,
			default: "hover"
		},
		getPopupContainer: Function,
		expandIcon: Function,
		onOpenChange: Function,
		onSelect: Function,
		onDeselect: Function,
		onClick: [Function, Array],
		onFocus: Function,
		onBlur: Function,
		onMousedown: Function,
		"onUpdate:openKeys": Function,
		"onUpdate:selectedKeys": Function,
		"onUpdate:activeKey": Function
	};
};
var EMPTY_LIST = [];
var Menu_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "AMenu",
	inheritAttrs: false,
	props: menuProps(),
	slots: ["expandIcon", "overflowedIndicator"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
		var _useConfigInject = useConfigInject_default("menu", props), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPrefixCls = _useConfigInject.getPrefixCls;
		var store = ref({});
		var siderCollapsed = inject(SiderCollapsedKey, ref(void 0));
		var inlineCollapsed = computed(function() {
			if (siderCollapsed.value !== void 0) return siderCollapsed.value;
			return props.inlineCollapsed;
		});
		var isMounted = ref(false);
		onMounted(function() {
			isMounted.value = true;
		});
		watchEffect(function() {
			devWarning_default(!(props.inlineCollapsed === true && props.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline.");
			devWarning_default(!(siderCollapsed.value !== void 0 && props.inlineCollapsed === true), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
		});
		var activeKeys = ref([]);
		var mergedSelectedKeys = ref([]);
		var keyMapStore = ref({});
		watch(store, function() {
			var newKeyMapStore = {};
			for (var _i = 0, _Object$values = Object.values(store.value); _i < _Object$values.length; _i++) {
				var menuInfo = _Object$values[_i];
				newKeyMapStore[menuInfo.key] = menuInfo;
			}
			keyMapStore.value = newKeyMapStore;
		}, { flush: "post" });
		watchEffect(function() {
			if (props.activeKey !== void 0) {
				var keys$1 = [];
				var menuInfo = props.activeKey ? keyMapStore.value[props.activeKey] : void 0;
				if (menuInfo && props.activeKey !== void 0) keys$1 = uniq_default([].concat(unref(menuInfo.parentKeys), props.activeKey));
				else keys$1 = [];
				if (!shallowequal_default(activeKeys.value, keys$1)) activeKeys.value = keys$1;
			}
		});
		watch(function() {
			return props.selectedKeys;
		}, function(selectedKeys) {
			if (selectedKeys) mergedSelectedKeys.value = selectedKeys.slice();
		}, {
			immediate: true,
			deep: true
		});
		var selectedSubMenuKeys = ref([]);
		watch([keyMapStore, mergedSelectedKeys], function() {
			var subMenuParentKeys = [];
			mergedSelectedKeys.value.forEach(function(key) {
				var menuInfo = keyMapStore.value[key];
				if (menuInfo) subMenuParentKeys = subMenuParentKeys.concat(unref(menuInfo.parentKeys));
			});
			subMenuParentKeys = uniq_default(subMenuParentKeys);
			if (!shallowequal_default(selectedSubMenuKeys.value, subMenuParentKeys)) selectedSubMenuKeys.value = subMenuParentKeys;
		}, { immediate: true });
		var triggerSelection = function triggerSelection$1(info) {
			if (!props.selectable) return;
			var targetKey = info.key;
			var exist = mergedSelectedKeys.value.includes(targetKey);
			var newSelectedKeys;
			if (props.multiple) if (exist) newSelectedKeys = mergedSelectedKeys.value.filter(function(key) {
				return key !== targetKey;
			});
			else newSelectedKeys = [].concat(_toConsumableArray(mergedSelectedKeys.value), [targetKey]);
			else newSelectedKeys = [targetKey];
			var selectInfo = _objectSpread2(_objectSpread2({}, info), {}, { selectedKeys: newSelectedKeys });
			if (!shallowequal_default(newSelectedKeys, mergedSelectedKeys.value)) {
				if (props.selectedKeys === void 0) mergedSelectedKeys.value = newSelectedKeys;
				emit("update:selectedKeys", newSelectedKeys);
				if (exist && props.multiple) emit("deselect", selectInfo);
				else emit("select", selectInfo);
			}
			if (mergedMode.value !== "inline" && !props.multiple && mergedOpenKeys.value.length) triggerOpenKeys(EMPTY_LIST);
		};
		var mergedOpenKeys = ref([]);
		watch(function() {
			return props.openKeys;
		}, function() {
			var openKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mergedOpenKeys.value;
			if (!shallowequal_default(mergedOpenKeys.value, openKeys)) mergedOpenKeys.value = openKeys.slice();
		}, {
			immediate: true,
			deep: true
		});
		var timeout;
		var changeActiveKeys = function changeActiveKeys$1(keys$1) {
			clearTimeout(timeout);
			timeout = setTimeout(function() {
				if (props.activeKey === void 0) activeKeys.value = keys$1;
				emit("update:activeKey", keys$1[keys$1.length - 1]);
			});
		};
		var disabled = computed(function() {
			return !!props.disabled;
		});
		var isRtl = computed(function() {
			return direction.value === "rtl";
		});
		var mergedMode = ref("vertical");
		var mergedInlineCollapsed = ref(false);
		watchEffect(function() {
			if ((props.mode === "inline" || props.mode === "vertical") && inlineCollapsed.value) {
				mergedMode.value = "vertical";
				mergedInlineCollapsed.value = inlineCollapsed.value;
			} else {
				mergedMode.value = props.mode;
				mergedInlineCollapsed.value = false;
			}
		});
		var isInlineMode = computed(function() {
			return mergedMode.value === "inline";
		});
		var triggerOpenKeys = function triggerOpenKeys$1(keys$1) {
			mergedOpenKeys.value = keys$1;
			emit("update:openKeys", keys$1);
			emit("openChange", keys$1);
		};
		var inlineCacheOpenKeys = ref(mergedOpenKeys.value);
		var mountRef = ref(false);
		watch(mergedOpenKeys, function() {
			if (isInlineMode.value) inlineCacheOpenKeys.value = mergedOpenKeys.value;
		}, { immediate: true });
		watch(isInlineMode, function() {
			if (!mountRef.value) {
				mountRef.value = true;
				return;
			}
			if (isInlineMode.value) mergedOpenKeys.value = inlineCacheOpenKeys.value;
			else triggerOpenKeys(EMPTY_LIST);
		}, { immediate: true });
		var className = computed(function() {
			var _ref2;
			return _ref2 = {}, _defineProperty(_ref2, "".concat(prefixCls.value), true), _defineProperty(_ref2, "".concat(prefixCls.value, "-root"), true), _defineProperty(_ref2, "".concat(prefixCls.value, "-").concat(mergedMode.value), true), _defineProperty(_ref2, "".concat(prefixCls.value, "-inline-collapsed"), mergedInlineCollapsed.value), _defineProperty(_ref2, "".concat(prefixCls.value, "-rtl"), isRtl.value), _defineProperty(_ref2, "".concat(prefixCls.value, "-").concat(props.theme), true), _ref2;
		});
		var rootPrefixCls = computed(function() {
			return getPrefixCls();
		});
		var defaultMotions = computed(function() {
			return {
				horizontal: { name: "".concat(rootPrefixCls.value, "-slide-up") },
				inline: collapseMotion_default,
				other: { name: "".concat(rootPrefixCls.value, "-zoom-big") }
			};
		});
		useProvideFirstLevel(true);
		var getChildrenKeys = function getChildrenKeys$1() {
			var eventKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
			var keys$1 = [];
			var storeValue = store.value;
			eventKeys.forEach(function(eventKey) {
				var _storeValue$eventKey = storeValue[eventKey], key = _storeValue$eventKey.key, childrenEventKeys = _storeValue$eventKey.childrenEventKeys;
				keys$1.push.apply(keys$1, [key].concat(_toConsumableArray(getChildrenKeys$1(unref(childrenEventKeys)))));
			});
			return keys$1;
		};
		/**
		* Click for item. SubMenu do not have selection status
		*/
		var onInternalClick = function onInternalClick$1(info) {
			emit("click", info);
			triggerSelection(info);
		};
		var onInternalOpenChange = function onInternalOpenChange$1(key, open) {
			var _keyMapStore$value$ke;
			var childrenEventKeys = ((_keyMapStore$value$ke = keyMapStore.value[key]) === null || _keyMapStore$value$ke === void 0 ? void 0 : _keyMapStore$value$ke.childrenEventKeys) || [];
			var newOpenKeys = mergedOpenKeys.value.filter(function(k) {
				return k !== key;
			});
			if (open) newOpenKeys.push(key);
			else if (mergedMode.value !== "inline") {
				var subPathKeys = getChildrenKeys(unref(childrenEventKeys));
				newOpenKeys = uniq_default(newOpenKeys.filter(function(k) {
					return !subPathKeys.includes(k);
				}));
			}
			if (!shallowequal_default(mergedOpenKeys, newOpenKeys)) triggerOpenKeys(newOpenKeys);
		};
		var registerMenuInfo = function registerMenuInfo$1(key, info) {
			store.value = _objectSpread2(_objectSpread2({}, store.value), {}, _defineProperty({}, key, info));
		};
		var unRegisterMenuInfo = function unRegisterMenuInfo$1(key) {
			delete store.value[key];
			store.value = _objectSpread2({}, store.value);
		};
		var lastVisibleIndex = ref(0);
		var expandIcon = computed(function() {
			return props.expandIcon || slots.expandIcon ? function(opt) {
				var icon = props.expandIcon || slots.expandIcon;
				icon = typeof icon === "function" ? icon(opt) : icon;
				return cloneElement(icon, { class: "".concat(prefixCls.value, "-submenu-expand-icon") }, false);
			} : null;
		});
		useMenuContext_default({
			store,
			prefixCls,
			activeKeys,
			openKeys: mergedOpenKeys,
			selectedKeys: mergedSelectedKeys,
			changeActiveKeys,
			disabled,
			rtl: isRtl,
			mode: mergedMode,
			inlineIndent: computed(function() {
				return props.inlineIndent;
			}),
			subMenuCloseDelay: computed(function() {
				return props.subMenuCloseDelay;
			}),
			subMenuOpenDelay: computed(function() {
				return props.subMenuOpenDelay;
			}),
			builtinPlacements: computed(function() {
				return props.builtinPlacements;
			}),
			triggerSubMenuAction: computed(function() {
				return props.triggerSubMenuAction;
			}),
			getPopupContainer: computed(function() {
				return props.getPopupContainer;
			}),
			inlineCollapsed: mergedInlineCollapsed,
			antdMenuTheme: computed(function() {
				return props.theme;
			}),
			siderCollapsed,
			defaultMotions: computed(function() {
				return isMounted.value ? defaultMotions.value : null;
			}),
			motion: computed(function() {
				return isMounted.value ? props.motion : null;
			}),
			overflowDisabled: ref(void 0),
			onOpenChange: onInternalOpenChange,
			onItemClick: onInternalClick,
			registerMenuInfo,
			unRegisterMenuInfo,
			selectedSubMenuKeys,
			isRootMenu: ref(true),
			expandIcon,
			forceSubMenuRender: computed(function() {
				return props.forceSubMenuRender;
			})
		});
		return function() {
			var _slots$default, _slots$overflowedIndi;
			var childList = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
			var allVisible = lastVisibleIndex.value >= childList.length - 1 || mergedMode.value !== "horizontal" || props.disabledOverflow;
			var wrappedChildList = mergedMode.value !== "horizontal" || props.disabledOverflow ? childList : childList.map(function(child, index) {
				return createVNode(MenuContextProvider, {
					"key": child.key,
					"overflowDisabled": index > lastVisibleIndex.value
				}, { default: function _default() {
					return child;
				} });
			});
			var overflowedIndicator = ((_slots$overflowedIndi = slots.overflowedIndicator) === null || _slots$overflowedIndi === void 0 ? void 0 : _slots$overflowedIndi.call(slots)) || createVNode(EllipsisOutlined_default, null, null);
			return createVNode(vc_overflow_default, _objectSpread2(_objectSpread2({}, attrs), {}, {
				"onMousedown": props.onMousedown,
				"prefixCls": "".concat(prefixCls.value, "-overflow"),
				"component": "ul",
				"itemComponent": MenuItem_default,
				"class": [className.value, attrs.class],
				"role": "menu",
				"id": props.id,
				"data": wrappedChildList,
				"renderRawItem": function renderRawItem(node) {
					return node;
				},
				"renderRawRest": function renderRawRest(omitItems) {
					var len = omitItems.length;
					var originOmitItems = len ? childList.slice(-len) : null;
					return createVNode(Fragment, null, [createVNode(SubMenu_default, {
						"eventKey": OVERFLOW_KEY,
						"key": OVERFLOW_KEY,
						"title": overflowedIndicator,
						"disabled": allVisible,
						"internalPopupClose": len === 0
					}, { default: function _default() {
						return originOmitItems;
					} }), createVNode(PathContext, null, { default: function _default() {
						return [createVNode(SubMenu_default, {
							"eventKey": OVERFLOW_KEY,
							"key": OVERFLOW_KEY,
							"title": overflowedIndicator,
							"disabled": allVisible,
							"internalPopupClose": len === 0
						}, { default: function _default$1() {
							return originOmitItems;
						} })];
					} })]);
				},
				"maxCount": mergedMode.value !== "horizontal" || props.disabledOverflow ? vc_overflow_default.INVALIDATE : vc_overflow_default.RESPONSIVE,
				"ssr": "full",
				"data-menu-list": true,
				"onVisibleChange": function onVisibleChange(newLastIndex) {
					lastVisibleIndex.value = newLastIndex;
				}
			}), { default: function _default() {
				return [createVNode(Teleport, { "to": "body" }, { default: function _default$1() {
					return [createVNode("div", {
						"style": { display: "none" },
						"aria-hidden": true
					}, [createVNode(PathContext, null, { default: function _default$2() {
						return [wrappedChildList];
					} })])];
				} })];
			} });
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/ItemGroup.js
var menuItemGroupProps = function menuItemGroupProps$1() {
	return { title: vue_types_default.any };
};
var ItemGroup_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "AMenuItemGroup",
	inheritAttrs: false,
	props: menuItemGroupProps(),
	slots: ["title"],
	setup: function setup(props, _ref) {
		var slots = _ref.slots, attrs = _ref.attrs;
		var prefixCls = useInjectMenu().prefixCls;
		var groupPrefixCls = computed(function() {
			return "".concat(prefixCls.value, "-item-group");
		});
		var isMeasure = useMeasure();
		return function() {
			var _slots$default, _slots$default2;
			if (isMeasure) return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
			return createVNode("li", _objectSpread2(_objectSpread2({}, attrs), {}, {
				"onClick": function onClick(e) {
					return e.stopPropagation();
				},
				"class": groupPrefixCls.value
			}), [createVNode("div", {
				"title": typeof props.title === "string" ? props.title : void 0,
				"class": "".concat(groupPrefixCls.value, "-title")
			}, [getPropsSlot(slots, props, "title")]), createVNode("ul", { "class": "".concat(groupPrefixCls.value, "-list") }, [(_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots)])]);
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/menu/src/Divider.js
var menuDividerProps = function menuDividerProps$1() {
	return {
		prefixCls: String,
		dashed: Boolean
	};
};
var Divider_default = defineComponent({
	compatConfig: { MODE: 3 },
	name: "AMenuDivider",
	props: menuDividerProps(),
	setup: function setup(props) {
		var prefixCls = useConfigInject_default("menu", props).prefixCls;
		var cls = computed(function() {
			var _ref;
			return _ref = {}, _defineProperty(_ref, "".concat(prefixCls.value, "-item-divider"), true), _defineProperty(_ref, "".concat(prefixCls.value, "-item-divider-dashed"), !!props.dashed), _ref;
		});
		return function() {
			return createVNode("li", { "class": cls.value }, null);
		};
	}
});

//#endregion
//#region node_modules/ant-design-vue/es/menu/index.js
/* istanbul ignore next */
Menu_default.install = function(app) {
	app.component(Menu_default.name, Menu_default);
	app.component(MenuItem_default.name, MenuItem_default);
	app.component(SubMenu_default.name, SubMenu_default);
	app.component(Divider_default.name, Divider_default);
	app.component(ItemGroup_default.name, ItemGroup_default);
	return app;
};
Menu_default.Item = MenuItem_default;
Menu_default.Divider = Divider_default;
Menu_default.SubMenu = SubMenu_default;
Menu_default.ItemGroup = ItemGroup_default;
var menu_default = Menu_default;

//#endregion
export { isVisible_default as $, _getAllKeys_default as A, isArguments_default as B, vc_trigger_default as C, isEqual_default as D, useProviderTrigger as E, _nodeUtil_default as F, _arrayPush_default as G, stubArray_default as H, _baseUnary_default as I, _SetCache_default as J, _Uint8Array_default as K, isLength_default as L, isArrayLike_default as M, _isPrototype_default as N, _baseIsEqual_default as O, _arrayLikeKeys_default as P, eq_default as Q, _isIndex_default as R, KeyCode_default as S, useProvidePortal as T, _baseGetAllKeys_default as U, _getSymbols_default as V, isArray_default as W, _MapCache_default as X, _Stack_default as Y, _getNative_default as Z, getPlacements as _, SubMenu_default as a, PresetStatusColorTypes as b, SiderHookProviderKey as c, _baseFindIndex_default as d, contains as et, shallowequal_default as f, firstNotUndefined_default as g, tooltipProps as h, collapseMotion_default as i, keys_default as j, _getTag_default as k, _arrayIncludesWith_default as l, tooltipDefaultProps as m, Divider_default as n, vc_resize_observer_default as nt, MenuItem_default as o, tooltip_default as p, _cacheHas_default as q, ItemGroup_default as r, SiderCollapsedKey as s, menu_default as t, addEventListenerWrap as tt, _arrayIncludes_default as u, abstractTooltipProps_default as v, Portal_default as w, vc_overflow_default as x, PresetColorTypes as y, isBuffer_default as z };
//# sourceMappingURL=menu-DP3L13lL.js.map